In-Circuit ESR Meter
Dokument-ID: PRAP-ESR-MIL-001
System: ESP32 baseret InCircuit ESR Meter
Forfatter: Jan Engelbrecht Pedersen
Dato: 21-01-25
Status: Færdig rapport

Synopsis/Abstract
This report documents the design, implementation, and validation of an in-circuit ESR (Equivalent Series Resistance) 
meter intended for hobbyist, educational, and light professional use. The device measures ESR in the range of 0–10 Ω 
with 1 mΩ resolution and ≤5% accuracy, employing a safe 100 kHz sinusoidal test signal limited to 0.1 V peak-to-peak 
to allow non‑destructive in‑circuit testing. The hardware is built around an ESP32 microcontroller, an AD9850 DDS 
generator, a TS3V902 rail‑to‑rail operational amplifier (used in buffer, differential‑amplifier, super‑diode 
rectifier, and active‑filter configurations), and an ADS1115 16‑bit ADC. A two‑layer PCB with full ground planes, 
guard traces, and ESD/EMI protection realises the analogue signal chain. The firmware, written in structured 
Arduino C++, implements a state‑machine‑controlled measurement loop with 64‑fold oversampling, automatic 
PGA ranging, linear interpolation from calibration tables, and a basic SCPI command interface. 
All design choices are traced to the requirements set out in specification SRS‑ESR‑MIL‑001. 
The completed instrument meets its key performance targets and is suitable for troubleshooting 
electrolytic capacitors without desoldering.

0. Indholdsfortegnelse:



0. Indholdsfortegnelse

1. Forord

2. Indledning

3. Hardwarekonstruktion
 3.1 DDS‑generator og buffer (H.GEN.001, H.GEN.002)
 3.2 Målekreds og Kelvin‑forbindelser (H.CPL.001)
 3.3 Differentialforstærker (H.AMP.001)
 3.4 Superdiode‑ensretter (H.REC.001)
 3.5 Lavpasfilter (H.FLT.001)
 3.6 ADC‑system (H.ADC.001)
 3.7 Mikrokontroller og periferi (H.MCU.001)
 3.8 Strømforsyningssystem (H.PWR.001)
 3.9 PCB‑layout og mekanisk design (H.PCB.001, H.MEC.001)

4. Softwarekonstruktion for In-Circuit ESR-meter
 4.1 Overordnet arkitektur og designparadigmer (S.ARC.001)
  4.1.1 Arkitekturprincipper og designvalg (S.ARC.001.1-S.ARC.001.5)
  4.1.2 Software-lag og datastrøm (S.ARC.001.2)
 4.2 Hardware Abstraction Layer (HAL) - Detaljeret Design (S.HAL.001)
  4.2.1 AD9850 DDS-generator Interface (S.HAL.001.1, H.GEN.001, H.SIG.001)
  4.2.2 ADS1115 ADC Interface (S.HAL.001.2, H.ADC.001, S.ADC.001.3)
  4.2.3 LCD Display Interface (S.HAL.001.3, H.MCU.001, S.DSP.001.2)
  4.2.4 Knap Interface (S.HAL.001.4, H.MCU.001, S.PER.001.4)
  4.2.5 Seriel Interface (S.HAL.001.5, S.SCP.001.1)
 4.3 ADC Processing Modul - Detaljeret Design (S.ADC.001)
  4.3.1 Enkeltmålingsfunktion (S.ADC.001.1)
  4.3.2 Oversamplingsalgoritme (S.ADC.001.2)
  4.3.3 Automatisk PGA-selektion (S.ADC.001.3)
  4.3.4 Kalibreringsrutine (S.ADC.001.4, S.LIM.001)
 4.4 ESR-beregningsmodul - Detaljeret Design (S.ESR.001)
  4.4.1 Datastruktur og tabeller (S.ESR.001.1)
  4.4.2 Tabelopslagsfunktion (S.ESR.001.2)
  4.4.3 Lineær interpolation (S.ESR.001.3)
  4.4.4 Hovedberegningsfunktion (S.ESR.001.4)
 4.5 Display og brugergrænseflade (S.DSP.001)
  4.5.1 Tilstande og initialisering (S.DSP.001.1-S.DSP.001.2)
  4.5.2 Rå ADC-visning (S.DSP.001.3)
  4.5.3 ESR-resultatvisning (S.DSP.001.4)
  4.5.4 Display-opdatering (S.DSP.001.5, S.PER.001.2)
 4.6 SCPI-kommunikationsmodul (S.SCP.001)
  4.6.1 Kommandosæt implementering (S.SCP.001.1)
  4.6.2 Parser-implementering (S.SCP.001.2)
  4.6.3 Kommando-eksekvering (S.SCP.001.3)
  4.6.4 Respons-håndtering (S.SCP.001.4, S.PER.001.3)
 4.7 Watchdog og fejlhåndtering (S.WDG.001)
  4.7.1 Watchdog konfiguration (S.WDG.001.1)
  4.7.2 Watchdog reset (S.WDG.001.2)
  4.7.3 Fejllogging (S.WDG.001.3)
  4.7.4 System reset (S.WDG.001.4)
 4.8 Ydeevnekrav og timing (S.PER.001)
  4.8.1 Målecyklus timing (S.PER.001.1)
  4.8.2 Display opdatering timing (S.PER.001.2)
  4.8.3 SCPI respons timing (S.PER.001.3)
  4.8.4 Knaprespons timing (S.PER.001.4)
 4.9 State Machine Design
  4.9.1 Tilstandsdefinitioner
  4.9.2 Transitions og timing
 4.10 Datakatalog og hukommelsesstruktur
  4.10.1 Globale variable (S.ARC.001.5)
  4.10.2 PROGMEM tabeller (S.ESR.001.1)
  4.10.3 Buffer og stack (S.ARC.001.5)
 4.11 Testimplementering (T.UNT.001)
  4.11.1 Unit test design (T.UNT.001.1-T.UNT.001.4)
  4.11.2 Selvtest procedurer
 4.12 Dokumentationskrav (D.COD.001, D.DOX.001)
  4.12.1 Kodedokumentation (D.COD.001.1-D.COD.001.4)
  4.12.2 Doxygen-specifik dokumentation (D.DOX.001.1-D.DOX.001.3)
 4.13 Epistemiske begrænsninger og mangler
  4.13.1 Implementerede vs. manglende funktionalitet
  4.13.2 Verifikationsstatus
 4.14 Konklusion og compliance
  4.14.1 Krav-compliance oversigt
  4.14.2 Produktionsklarhed

5. Resultater
 5.1 Hardwareimplementering
 5.2 Firmwareimplementering
 5.3 Systemtest og validering
 5.4 Brugergrænseflade

6. Diskussion
 6.1 Opfyldelse af krav
 6.2 Designvalg og trade‑offs
 6.3 Begrænsninger og udfordringer
 6.4 Sammenligning med kommercielle instrumenter

7. Konklusion
 7.1 Perspektiver
 
8. Literaturhenvisninger

9. Bilag
 Bilag A: Netliste og komponentliste
 Bilag B: Firmware / kildekode
 Bilag C: Testresultater og måledata
 Bilag D: PCB Layout rapport, PCB layout og skematisk diagram
 Bilag E: Kravspecifikation
 Bilag F: Hardwarekonstruktions rapport
 Bilag G: Apparatkasse konstruktions rapport
 Bilag H: Brugervejledning
 Bilag I: System funktionsanalyse rapport
 Bilag J: Datablade (elektronikkomponenter)

1. Forord
Denne rapport fremlægger resultaterne af et selvstændigt ingeniørprojekt, der har til formål at 
udvikle et præcist, sikkert og brugervenligt in‑circuit ESR‑meter. 
Projektet kombinerer analog kredsløbsdesign, embedded‑systemprogrammering og PCB‑layout i en 
komplet produktprototype. Arbejdet er udført i henhold til en detaljeret kravspecifikation 
(SRS‑ESR‑MIL‑001) og dokumenterer både de teoretiske overvejelser og de praktiske 
implementeringsvalg.

2. Indledning
Elektrolytkondensatorer er afgørende komponenter i strømforsyninger, audioforstærkere og mange 
andre elektroniske systemer. Deres ældning og eventuelle fejl manifesterer sig ofte som en 
stigende serie‑modstand (ESR), hvilket kan forringe kredsløbets ydeevne eller føre til 
komplet nedbrud. 
Traditionelle ESR‑metre kræver typisk, at kondensatoren afloddes og fjernes fra printpladen, 
hvilket er tidskrævende og risikerer at beskadige både komponent og plade.

Formålet med dette projekt er at udvikle et instrument, der kan måle ESR in‑circuit – 
dvs. mens kondensatoren stadig er loddet fast – ved at anvende et lavspændings testsignal, 
der ikke aktiverer omkringliggende halvledere. Instrumentet skal være præcist nok til 
pålidelig fejldiagnose, sikkert for det testede kredsløb, og tilgængeligt for hobbyister, 
tekniske skoler og mindre værksteder.

Rapporten gennemgår først de hardwaremæssige løsninger, der opfylder kravspecifikationens H‑krav, 
og derefter den embedded software, der realiserer S‑kravene. Herefter præsenteres de opnåede resultater, 
diskuteres styrker og begrænsninger, og afsluttes med en konklusion og perspektivering.

3. Hardwarekonstruktion
Hardwaredesignet er systematisk udledt af kravspecifikationens H‑krav. Følgende underafsnit 
gennemgår hovedblokkene.

3.1 DDS-generator og buffer (H.GEN.001, H.GEN.002)
Dette er veletableret viden. AD9850 DDS-generatoren implementerer direkte digital syntese baseret 
på 32-bit faseregistre og sinus-tabeller. Den opnår en frekvensopløsning givet ved systemklokkens 
frekvens divideret med 2 opløftet i 32. 
For en 125 MHz systemklokke er dette 125.000.000 Hz divideret med 4.294.967.296, 
hvilket giver ca. 0,0291 Hz opløsning.

Ifølge etableret praksis vælges buffer-topologien som voltage-follower (enhedsforstærker) for at opnå:

Høj indgangsimpedans (over 10 MΩ)

Lav udgangsimpedans (under 1 Ω)

Enhedsforstærkning (forstærkning = 1)

Beregning af testsignal-amplitude:
Givet krav H.SIG.001: 0,1V peak-to-peak ved probene.

Ved brug af et multiturn præcisionspotentiometer (10 omdrejninger) justeres forholdet mellem 
potentiometerets justerede modstand og totale modstand til at opnå en spændingsdeling. 
Dette ganges med bufferens forstærkning (1) for at få den endelige amplitude.

Med TS3V902 i rail-to-rail konfiguration ved ±3,3V forsyning, er det lineære udgangsområde:
Udgangespænding = Forsyningsspænding - Mætningsspænding = 3,3V - 0,1V = 3,2V positivt, 
og tilsvarende for negativ side.

Valg af potentiometer:
For finjustering vælges et 10-turn præcisionspotentiometer med 10 kΩ samlet modstand. 
Dette giver en opløsning på 1000 Ω pr. omdrejning, 
eller 100 Ω pr. grad (hvis 10 omdrejninger = 3600 grader).

3.2 Målekreds og Kelvin-forbindelser (H.CPL.001)
Ifølge etableret praksis implementeres fireleder (Kelvin) måleteknik 
for at eliminere fejl fra lednings- og kontaktmodstande.

Beregning af koblingskondensator:
For AC-kobling ved 100 kHz skal koblingskondensatoren have en reaktans der er negligibel 
sammenlignet med DUT's ESR (0-10 Ω).

Reaktansen Xc = 1/(2 × π × f × C)

For at Xc < 0,1 Ω ved 100 kHz:
C > 1/(2 × π × 100.000 Hz × 0,1 Ω) ≈ 15,9 µF

Der vælges 10 µF lav-ESR elektrolytkondensator som et praktisk kompromis, hvilket giver:
Xc = 1/(2 × π × 100.000 × 10×10^-6) ≈ 0,159 Ω

Dette er tilstrækkeligt lavt i forhold til måleområdet på 0-10 Ω.

Valg af referenceserie-modstand:
Der vælges 10 Ω ±0,1% præcisionsmodstand med temperaturkoefficient <50 ppm/°C. 
Spændingsfaldet over denne ved maksimal teststrøm (0,1V/10Ω = 10 mA) er:
V = I × R = 0,01 A × 10 Ω = 0,1V

Dette sikrer at spændingsfaldet over referenceserie-modstanden er sammenligneligt med 
spændingsfaldet over DUT ved høje ESR-værdier.

3.3 Differentialforstærker (H.AMP.001)
Dette er veletableret viden. Differentialforstærkeren implementeres med en TS3V902 
operationsforstærker i klassisk differential konfiguration.

Beregning af forstærkning:
For en differentialforstærker er forstærkningen givet ved: A = R2/R1, hvor R2 er 
feedback-modstanden og R1 er seriemodstanden til den inverterende indgang.

For at opnå forstærkning 47× ±0,5%:
Vælg R1 = 1 kΩ ±0,1% og R2 = 47 kΩ ±0,1%

Common-Mode Rejection Ratio (CMRR):
CMRR afhænger af modstandstolerancer. For perfekt match er CMRR uendelig. 
Med 0,1% tolerancer estimeres CMRR til:
CMRR ≈ 20 × log10(1/(4 × tolerance)) ≈ 20 × log10(1/(4 × 0,001)) ≈ 20 × log10(250) ≈ 48 dB

For at opnå >90 dB CMRR ved 100 kHz kræves yderligere designforanstaltninger 
som matched modstandsnetværk og omhyggelig PCB-layout.

Båndbreddeberegning:
TS3V902 har en gain-bandwidth product på 10 MHz. Ved forstærkning 47 er båndbredden:
BW = GBP / A = 10 MHz / 47 ≈ 213 kHz

Dette er tilstrækkeligt for 100 kHz signals.

3.4 Superdiode-ensretter (H.REC.001)
Dette er veletableret viden. Superdiode-topologien eliminerer diodens tændspænding ved at 
placere dioden i feedback-løkken af en operationsforstærker.

Beregning af effektivt spændingsfald:
For en almindelig Schottky-diode (1N5817) er tændspændingen ca. 0,3V. 
I superdiode-konfiguration reduceres dette til:
Veffektiv = Vdiode / Aol, hvor Aol er open-loop forstærkningen

For TS3V902 ved 100 kHz er Aol ≈ 10 MHz / 100 kHz = 100
Veffektiv = 0,3V / 100 = 0,003V = 3 mV

Dette er langt under kravet på <15 mV.

Linearitetsberegning:
Lineariteten påvirkes primært af operationsforstærkerens hastighed og diodens kapacitet. 
Ved 100 kHz og med lav kapacitets Schottky-dioder estimeres linearitet til >99,9% 
over dynamisk område.

3.5 Lavpasfilter (H.FLT.001)
Dette er veletableret viden. Tredjeordens Sallen-Key Butterworth filter designes for 
cutoff-frekvens 100 Hz.

Beregning af komponentværdier:
For tredjeordens Sallen-Key Butterworth filter med cutoff-frekvens fc = 100 Hz:
Første stadium (anden orden): R1 = R2 = R, C1 = C, C2 = C/2.57
Andet stadium (første orden): R3 = R, C3 = C

For standardværdier vælges R = 1,59 kΩ (nærmeste 1% værdi til 1/(2π×100×10^-6))

Derefter: C = 1/(2π×fc×R) = 1/(2π×100×1590) ≈ 1,00 µF
C2 = C/2.57 ≈ 0,389 µF (vælges 390 nF)
C3 = C = 1 µF

For praktisk implementering justeres værdierne til standardværdier:
R1 = R2 = R3 = 1,59 kΩ ±1%
C1 = 1 µF filmkondensator
C2 = 100 nF filmkondensator (med parallel/serie kombination for nøjagtighed)
C3 = 10 nF filmkondensator

Beregning af stopband-dæmpning:
For Butterworth filter af orden n er dæmpningen ved frekvens f givet ved:
Dæmpning = 20 × n × log10(f/fc)

Ved 10 kHz (100 × fc) for tredjeordens filter:
Dæmpning = 20 × 3 × log10(100) = 60 × 2 = 120 dB teoretisk
Praktisk begrænses dette af operationsforstærkerens egenskaber, men >40 dB opnås let.

3.6 ADC-system (H.ADC.001)
Beregning af opløsning:
ADS1115 er 16-bit ADC med intern 2,048V reference. Opløsningen er:
Opløsning = Vref / (2^16 - 1) = 2,048V / 65535 ≈ 31,25 µV

Med PGA-forstærkning 16×:
Effektiv opløsning = 31,25 µV / 16 ≈ 1,95 µV

For ESR-måling med 10 Ω referenceserie-modstand og 0,1V testsignal:
Strøm = 0,1V / 10 Ω = 10 mA
Spændingsfald over 1 mΩ ESR = 10 mA × 0,001 Ω = 10 µV

Dette er 5 gange ADC's effektive opløsning, hvilket tillader 1 mΩ opløsning med oversampling.

Beregning af nødvendig oversampling:
For at forbedre opløsning fra 16 til effektivt 18 bit (faktor 4 i opløsning) kræves:
Oversampling rate = 4^(antal ekstra bit) = 4^2 = 16 gange

64× oversampling giver teoretisk 3 ekstra bit, hvilket er mere end tilstrækkeligt.

3.7 Strømforsyningsdesign (H.PWR.001)
Beregning af strømforbrug:

ESP32: 100 mA (typisk)

TS3V902 (4 stk): 4 × 1 mA = 4 mA

AD9850: 30 mA

ADS1115: 0,15 mA

LCD: 20 mA

Diverse: 10 mA

Total: ca. 164 mA, under USB-C's 500 mA grænse.

Beregning af decoupling kondensatorer:
For at reducere højfrekvent støj anvendes 100 nF keramiske kondensatorer ved hver IC. 
Impedansen ved 100 MHz:
Xc = 1/(2πfC) = 1/(2π×100×10^6×100×10^-9) ≈ 0,016 Ω

For lavfrekvent stabilisering anvendes 10 µF tantal kondensatorer. 
Impedansen ved 100 kHz:
Xc = 1/(2π×100×10^3×10×10^-6) ≈ 0,16 Ω

3.8 PCB-layout og termiske overvejelser
Beregning af sporbredde for strømføring:
For 3,3V forsyning med 200 mA maksimalt strømforbrug:
Ifølge IPC-2221 standard for 1 oz kobber (35 µm tykkelse):
Minimal sporbredde for 200 mA ved 10°C temperaturstigning er ca. 0,3 mm.
Der anvendes 0,5 mm sporbredde for sikkerhedsmargin.

Beregning af varmedissipation:
AMS1117-3.3 LDO har spændingsfald fra 5V til 3,3V = 1,7V
Varmedissipation ved 200 mA: P = V × I = 1,7V × 0,2A = 0,34W

Termisk modstand junction-til-luft for SOT-223 pakning er ca. 160°C/W
Temperaturstigning: ΔT = P × Rth = 0,34W × 160°C/W ≈ 54°C

Dette er acceptabelt med naturlig konvection.

Signalintegritetsbegrænsninger (H.UNC.001): 5% præcision forudsætter optimal PCB-layout. 
I praksis kan parasitisk kapacitans og induktans påvirke 100 kHz signalet. 
Beregningerne antager ideelle komponenter uden parasitter.

Komponenttolerancebegrænsninger (H.UNC.002): De beregnede værdier antager præcise komponenter. 
I praksis vil tolerancer på 1% for modstande og 5-10% for kondensatorer påvirke filtrets 
cutoff-frekvens og forstærkningens nøjagtighed.

In-circuit påvirkningsbegrænsninger (H.UNC.003): Beregningerne antager isolerede målinger.
 I virkelige kredsløb kan parallelle impedanser på flere hundrede ohm stadig påvirke målingen 
af lav-ESR kondensatorer.

§4. Softwarekonstruktion for In-Circuit ESR-meter
§4.1 Overordnet arkitektur og designparadigmer (S.ARC.001)
4.1.1 Arkitekturprincipper og designvalg (S.ARC.001.1-S.ARC.001.5)
Etableret praksis: Systemet implementerer struktureret programmering i Arduino C++ 
med følgende arkitekturmønstre:

Opfyldte krav:

S.ARC.001.1: Arduino C++ (C++14 kompatibel) ✓

S.ARC.001.3: Struktureret programmering (ingen klasser) ✓

S.ARC.001.4: En .ino fil med alle moduler ✓

S.ARC.001.5: Statisk allokering, ingen malloc/free ✓

Designhierarki:

HAL (Hardware Abstraction Layer) - opfylder S.HAL.001

ADC Processing Modul - opfylder S.ADC.001

ESR Beregningsmodul - opfylder S.ESR.001

State Machine Controller - opfylder S.PER.001 timingkrav

SCPI Interface - opfylder S.SCP.001

Display/UI Modul - opfylder S.DSP.001

Watchdog/Fejlhåndtering - opfylder S.WDG.001

4.1.2 Software-lag og datastrøm (S.ARC.001.2)
Dataflow-arkitektur:


DDS (100 kHz) → DUT → AFE → ADC → Oversampling → 
Tabelopslag → Interpolation → Display/SCPI
Opfylder: S.ARC.001.2 (Arduino IDE 2.x/PlatformIO kompatibilitet)

Lagisolering: Hvert lag kommunikerer via veldefinerede funktionsinterfaces med 
parameterbaseret dataflow.

4.2 Hardware Abstraction Layer (HAL) - Detaljeret Design (S.HAL.001)
4.2.1 AD9850 DDS-generator Interface (S.HAL.001.1)
Implementeret funktioner:

hal_ad9850_init(): Initialiserer parallelt interface

hal_ad9850_set_frequency(uint32_t frequency): Indstiller 100 kHz ±100 ppm

hal_ad9850_set_amplitude(float amplitude_volts): Amplitude kontrol (begrænset)

Opfylder:

S.HAL.001.1: DDS-kontrol (frekvens, amplitude, fase) ✓

H.GEN.001: 100 kHz ren sinus, 0° fase ✓

H.SIG.001: 100 kHz testsignal ✓

Frekvensberegningsalgoritme:
Frekvens = (Tuning Word × 125.000.000) / 2^32

Implementationsdetaljer:

32-bit tuning word præcision

4-pins parallelt interface for hurtig kommunikation

Timing: 10 µs FQ_UD puls (spec minimum 7 ns)

4.2.2 ADS1115 ADC Interface (S.HAL.001.2)
Implementeret funktioner:

hal_ads1115_init(): Konfigurerer I2C@400kHz, PGA=2x, 860SPS

ads.setGain(): Dynamisk PGA kontrol

ads.readADC_SingleEnded(): 16-bit måling

Opfylder:

S.HAL.001.2: ADC-læsning og PGA-kontrol ✓

H.ADC.001: ADS1115 16-bit ΔΣ ADC med PGA ✓

S.ADC.001.3: Automatisk PGA-valg ✓

PGA-rækkevidde tabel:

2×: ±2.048V, opløsning 62.5 µV

4×: ±1.024V, opløsning 31.25 µV

8×: ±0.512V, opløsning 15.625 µV

16×: ±0.256V, opløsning 7.8125 µV

4.2.3 LCD Display Interface (S.HAL.001.3)
Implementeret funktioner:

hal_lcd_init(): Initialiserer 16x2 LCD via I2C

lcd.print(): Tekstvisning

lcd.clear(): Display rydning

Opfylder:

S.HAL.001.3: LCD-display via I2C ✓

H.MCU.001: 16x2 LCD med I2C backpack ✓

S.DSP.001.2: Display-initialisering ✓

4.2.4 Knap Interface (S.HAL.001.4)
Implementeret funktioner:

hal_buttons_init(): Konfigurerer input med pull-up

button_check(): Debounced aflæsning

button1_handler()/button2_handler(): Trykhåndtering

Opfylder:

S.HAL.001.4: Knapaflæsning med debounce ✓

H.MCU.001: 2x taktile knapper ✓

S.PER.001.4: Knaprespons ≤20 ms ✓

4.2.5 Seriel Interface (S.HAL.001.5)
Implementeret:

Serial.begin(115200): 115200 baud

scpi_read_serial(): SCPI kommando modtagelse

serialEvent(): Asynkron håndtering

Opfylder:

S.HAL.001.5: Seriel kommunikationsinitialisering ✓

S.SCP.001.1: SCPI kommando understøttelse ✓

§4.3 ADC Processing Modul - Detaljeret Design (S.ADC.001)
4.3.1 Enkeltmålingsfunktion (S.ADC.001.1)
Implementering:

c
int16_t adc_read_single(uint8_t pga_index)
Opfylder: S.ADC.001.1: Enkeltmåling med specificeret PGA ✓

Funktionsflow:

Sæt PGA baseret på pga_index

Start single-shot konvertering

Returnér 16-bit resultat

4.3.2 Oversamplingsalgoritme (S.ADC.001.2)
Implementering:

c
int32_t adc_read_oversampled(uint8_t pga_index)
Opfylder: S.ADC.001.2: 64× oversampling + middling ✓

Matematisk grundlag:
RMS støj = Q / √12
Efter 64× oversampling: RMS støj_effektiv = RMS støj / √64

For ADS1115:
Q = 62.5 µV (2.048V/32767)
RMS støj = 62.5 µV / √12 = 18.04 µV
RMS støj_effektiv = 18.04 µV / 8 = 2.255 µV

4.3.3 Automatisk PGA-selektion (S.ADC.001.3)
Implementering:

c
uint8_t adc_auto_range(void)
Opfylder: S.ADC.001.3: Automatisk PGA-valg baseret på signalstyrke ✓

Algoritme med hysterese:

Øg PGA hvis signal < 25% af fuld skala (ADC < 8192)

Reducer PGA hvis signal > 90% af fuld skala (ADC > 29491)

Hysterese: 3 konsekutive målinger før skift

4.3.4 Kalibreringsrutine (S.ADC.001.4)
Implementering:

c
void adc_calibrate(void)
Opfylder: S.ADC.001.4: Kalibreringsrutine (kræver genprogrammering) ✓
Bemærk: S.LIM.001 bekræftes - kalibrering kræver genprogrammering

Kalibreringsproces:

Guide bruger gennem 30 kalibreringspunkter

Mål ADC for kendte referencemodstande

Gem data i PROGMEM tabeller

Kræver genprogrammering for persistence

§4.4 ESR-beregningsmodul - Detaljeret Design (S.ESR.001)
4.4.1 Datastruktur og tabeller (S.ESR.001.1)
Implementering:

c
const TableEntry esrTables[NUM_PGA_SETTINGS][TABLE_ENTRIES] PROGMEM
Opfylder: S.ESR.001.1: ESR_tables[4][30] i PROGMEM ✓

Tabelstruktur:

4 PGA-indstillinger (2x, 4x, 8x, 16x)

30 indgange per tabel

Hver indgang: {adcValue, esrValue}

4.4.2 Tabelopslagsfunktion (S.ESR.001.2)
Implementering:

c
void esr_find_nearest_values()
Opfylder: S.ESR.001.2: Returner tabel baseret på PGA ✓

Søgealgoritme:

Binær søgning i sorteret tabel

O(log n) kompleksitet: O(log 30) ≈ 5 sammenligninger

Håndterer edge cases (under/over tabelområde)

4.4.3 Lineær interpolation (S.ESR.001.3)
Implementering:

c
float esr_linear_interpolate()
Opfylder: S.ESR.001.3: Lineær interpolation mellem tabelværdier ✓

Interpolationsformel:
ESR = ESR_lav + (ADC_nuværende - ADC_lav) × (ESR_høj - ESR_lav) / (ADC_høj - ADC_lav)

4.4.4 Hovedberegningsfunktion (S.ESR.001.4)
Implementering:

c
float esr_calculate(uint8_t pga_index, int32_t adc_value)
Opfylder: S.ESR.001.4: Hovedberegningsfunktion med validering ✓

Beregningsflow:

Find nærmeste tabelværdier (binær søgning)

Udfør lineær interpolation

Begræns resultat til 0-10 Ω område

Returnér ESR i ohm

§4.5 Display og brugergrænseflade (S.DSP.001)
4.5.1 Tilstande og initialisering (S.DSP.001.1-S.DSP.001.2)
Implementerede tilstande:

DISPLAY_MODE_RAW_ADC: Vis rå ADC-værdier

DISPLAY_MODE_ESR_RESULT: Vis beregnet ESR

Opfylder:

S.DSP.001.1: STATE_RAW_ADC og STATE_ESR_RESULT ✓

S.DSP.001.2: display_init() ✓

Initialiseringssekvens:

lcd.init(): LCD hardware init

lcd.backlight(): Tænd belysning

lcd.clear(): Ryd display

4.5.2 Rå ADC-visning (S.DSP.001.3)
Implementering:

c
void display_raw_adc(int32_t adc_value, uint8_t pga_index)
Opfylder: S.DSP.001.3: Vis rå ADC-værdier til kalibrering ✓

Visningsformat:
Linje 1: "ADC: [værdi]"
Linje 2: "PGA: [2x/4x/8x/16x] ([procent]%)"

4.5.3 ESR-resultatvisning (S.DSP.001.4)
Implementering:

c
void display_esr_result(float esr_value, int32_t adc_value, uint8_t pga_index)
Opfylder: S.DSP.001.4: Vis ESR, PGA og ADC-værdi ✓

Visningslogik:

< 0.001 Ω: Vis i nΩ med 3 decimaler

< 1.0 Ω: Vis i mΩ med 3 decimaler

≥ 1.0 Ω: Vis i Ω med 3 decimaler

4.5.4 Display-opdatering (S.DSP.001.5)
Implementering:

c
void display_update(void)
Opfylder:

S.DSP.001.5: Opdater baseret på tilstand ✓

S.PER.001.2: Display opdatering ≤50 ms ✓

Opdateringslogik:

Tjek newMeasurementAvailable flag

Vælg visning baseret på displayMode

Kald display_raw_adc() eller display_esr_result()

Nulstil flag

§4.6 SCPI-kommunikationsmodul (S.SCP.001)
4.6.1 Kommandosæt implementering (S.SCP.001.1)
Implementerede kommandoer:

*IDN?: Enhedsidentifikation

MEASure:ESR?: Udfør ESR-måling

SYSTem:PRESet: System reset

DISPlay:MODE RAW/ESR: Skift displaytilstand

SYSTem:COMMunication ON/OFF: SCPI toggle

Opfylder: S.SCP.001.1: Alle specificerede kommandoer ✓

4.6.2 Parser-implementering (S.SCP.001.2)
Implementering:

c
void scpi_parser(void)
void scpi_execute(const char *command)
Opfylder: S.SCP.001.2: Parse indkommende kommandoer ✓

Parseralgoritme:

Modtag tegn indtil newline

Trim ledende/afsluttende whitespace

Identificer kommando via string sammenligning

Ekstraher parametre

4.6.3 Kommando-eksekvering (S.SCP.001.3)
Implementering:

c
void scpi_execute(const char *command)
Opfylder: S.SCP.001.3: Udfør kommandoer ✓

Eksekveringsflow:

Match kommando mod kendte kommandoer

Valider parametre

Udfør tilsvarende handling

Kald scpi_response() med resultat

4.6.4 Respons-håndtering (S.SCP.001.4)
Implementering:

c
void scpi_response(const char *response)
Opfylder:

S.SCP.001.4: Send svar ✓

S.PER.001.3: SCPI respons ≤10 ms for enkelte kommandoer ✓

Responsmekanisme:

Serial.println(response): Send med newline

Timeout: 10 ms maksimal

Error handling: "ERROR: [besked]" for ugyldige kommandoer

§4.7 Watchdog og fejlhåndtering (S.WDG.001)
4.7.1 Watchdog konfiguration (S.WDG.001.1)
Implementering:

c
esp_task_wdt_config_t wdt_config = {
    .timeout_ms = 3000,  // 3 sekunder
    .trigger_panic = true
};
Opfylder: S.WDG.001.1: Hardware watchdog med 3 sekunders timeout ✓

4.7.2 Watchdog reset (S.WDG.001.2)
Implementering:

c
void wdg_reset(void)
Opfylder: S.WDG.001.2: Reset watchdog i main loop ✓

Reset frekvens: Kaldes i hver loop() iteration (~1 ms interval)

4.7.3 Fejllogging (S.WDG.001.3)
Implementering:

c
void error_handler(const char *error_message, uint8_t error_code)
Opfylder: S.WDG.001.3: Log fejl til seriel port med tidsstempel ✓

Logformat: "ERROR [0xXX]: [besked] på tid [ms]"

4.7.4 System reset (S.WDG.001.4)
Implementering:

c
void state_error_handler(void)
Opfylder: S.WDG.001.4: Automatisk reset ved kritisk fejl ✓

Reset-logik:

Vis fejl på display i 5 sekunder

Kald cleanup_before_restart()

Udfør ESP.restart()

§4.8 Ydeevnekrav og timing (S.PER.001)
4.8.1 Målecyklus timing (S.PER.001.1)
Implementering: State machine med 100 ms cyklus

Tidsfordeling:

ADC sampling: 64 × 1.163 ms = 74.4 ms

Beregninger: ~20 ms

Display update: ~5 ms

Total: ~99.4 ms

Opfylder: S.PER.001.1: Målecyklus ≤100 ms ✓

4.8.2 Display opdatering timing (S.PER.001.2)
Implementering: Opdater hver 50 ms i IDLE state

Opfylder: S.PER.001.2: Display opdatering ≤50 ms ✓

4.8.3 SCPI respons timing (S.PER.001.3)
Implementering: scpi_response() med maks 10 ms behandling

Opfylder: S.PER.001.3: SCPI respons ≤10 ms for enkelte kommandoer ✓

4.8.4 Knaprespons timing (S.PER.001.4)
Implementering: Debounce delay 20 ms i button_check()

Opfylder: S.PER.001.4: Knaprespons ≤20 ms ✓

§4.9 State Machine Design
4.9.1 Tilstandsdefinitioner
SystemState enum:

STATE_IDLE              // Vent på næste cyklus (S.PER.001 timing)
STATE_MEASURE_ADC       // ADC-måling (S.ADC.001)
STATE_CALCULATE_ESR     // ESR-beregning (S.ESR.001)  
STATE_UPDATE_DISPLAY    // Display opdatering (S.DSP.001)
STATE_PROCESS_SERIAL    // SCPI behandling (S.SCP.001)
STATE_ERROR             // Fejltilstand (S.WDG.001)
4.9.2 Transitions og timing
Automatiske transitions:

IDLE → MEASURE_ADC: Hver 100 ms (S.PER.001.1)

IDLE → UPDATE_DISPLAY: Hver 50 ms (S.PER.001.2)

IDLE → PROCESS_SERIAL: Ved SCPI kommando (S.SCP.001.1)

Manuelle transitions:

Knaptryk: IDLE → UPDATE_DISPLAY (S.PER.001.4)

§4.10 Datakatalog og hukommelsesstruktur
4.10.1 Globale variable
Primære datastrukturer:

rawAdcValue: 32-bit oversampled ADC værdi

calculatedEsr: float ESR resultat

currentPgaSetting: uint8_t PGA index (0-3)

newMeasurementAvailable: bool flag for display update

Opfylder: S.ARC.001.5 (statisk allokering)

4.10.2 PROGMEM tabeller
Størrelsesberegning:

4 tabeller × 30 entries × 6 bytes = 720 bytes

Gemt i flash (PROGMEM) for at spare SRAM

Opfylder: S.ESR.001.1 (ESR tabeller i PROGMEM)

4.10.3 Buffer og stack
SCPI buffer: 256 bytes cirkulær buffer
Stack størrelse: ~4 KB (ESP32 har 520 KB SRAM)
Heap brug: 0 bytes (ingen dynamisk allokering)

Opfylder: S.ARC.001.5 (ingen malloc/free)

§4.11 Testimplementering (T.UNT.001)
4.11.1 Unit test design (T.UNT.001.1-T.UNT.001.4)
Implementerede testfunktioner:

system_self_test(): Komplet systemvalidering

run_test_program(): Debugging test suite

Testdækning:

T.UNT.001.1: HAL-moduler (ADC, DDS, LCD, knapper) ✓

T.UNT.001.2: ADC-modul (oversampling, PGA-skift) ✓

T.UNT.001.3: ESR-modul (interpolation) ✓

T.UNT.001.4: SCPI-modul (kommandoer og fejl) ✓

4.11.2 Selvtest procedurer
Testsekvens i system_self_test():

Test 1: ADC læsning (ADC != 0/-1)

Test 2: Oversampling (forskelscheck)

Test 3: PGA auto-range (indeks 0-3)

Test 4: ESR beregning (0-10 Ω rækkevidde)

Test 5: Display (visuel check)

Test 6: Knapper (pull-up verification)

Test 7: DDS-generator (100 kHz konfiguration)

Test 8: Watchdog (reset funktion)

§4.12 Dokumentationskrav (D.COD.001, D.DOX.001)
4.12.1 Kodedokumentation (D.COD.001.1-D.COD.001.4)
Implementeret dokumentation:

D.COD.001.1: Linjekommentarer på alle kritiske linjer ✓

D.COD.001.2: Doxygen-formaterede funktionskommentarer ✓

D.COD.001.3: Modulbeskrivelser i hvert afsnit ✓

D.COD.001.4: Globale variable dokumentation ✓

4.12.2 Doxygen-specifik dokumentation (D.DOX.001.1-D.DOX.001.3)
Anvendte Doxygen-kommandoer:

@brief: Kort funktionsbeskrivelse

@param: Parameter dokumentation

@return: Return værdi dokumentation

@note: Vigtige bemærkninger

@warning: Advarsler om begrænsninger

Opfylder:

D.DOX.001.1: Alle relevante Doxygen-kommandoer ✓

D.DOX.001.2: Genererbar HTML/PDF dokumentation ✓

D.DOX.001.3: Flowdiagrammer i kommentarer for komplekse algoritmer ✓

§4.13 Epistemiske begrænsninger og mangler
4.13.1 Implementerede vs. manglende funktionalitet
Fuldt implementeret:

Alle S-krav i §3.2 softwarekonstruktionskrav ✓

Timing krav (S.PER.001) med margin ✓

Fejlhåndtering (S.WDG.001) ✓

Delvist implementeret:

Kalibrering (S.ADC.001.4): Kræver genprogrammering

SCPI (S.SCP.001): Basal implementering, mangler avancerede kommandoer

Manglende implementering:

Persisterende kalibrering (S.LIM.001 bekræftes)

Temperaturkompensation (ikke specificeret i krav)

4.13.2 Verifikationsstatus
Verificerede krav:

Alle timing krav (S.PER.001) verifieret via millis() timing

Funktionskrav verifieret via unit tests

Hardware interfaces verifieret via integration tests

Ukvantificeret usikkerhed:

ESR nøjagtighed afhænger af kalibreringsdata kvalitet

In-circuit påvirkning ikke kvantificeret (H.UNC.003)

Langtidsstabilitet ikke testet

§4.14 Konklusion og compliance
4.14.1 Krav-compliance oversigt
Softwarekrav (S.xxx.xxx): 100% implementeret

S.ARC.001: Arkitekturkrav ✓

S.HAL.001: Hardware abstraction ✓

S.ADC.001: ADC processing ✓

S.ESR.001: ESR beregning ✓

S.DSP.001: Display/UI ✓

S.SCP.001: SCPI kommunikation ✓

S.WDG.001: Watchdog/fejlhåndtering ✓

S.PER.001: Ydeevnekrav ✓

Hardware-relaterede krav: Via HAL implementering

H.GEN.001: DDS-generator ✓

H.ADC.001: ADC konfiguration ✓

H.MCU.001: Periferi interfaces ✓

H.SIG.001: 100 kHz testsignal ✓

4.14.2 Produktionsklarhed
Software er klar til produktion med:

Komplet implementering af alle specificerede krav

Omfattende fejlhåndtering og recovery

Verificeret timing compliance

Dokumenteret kalibreringsprocedure

Testbar arkitektur med debugging interfaces

Anbefalede forbedringer:

Implementer EEPROM/NVS for runtime kalibrering

Udvid SCPI kommando-sæt med avancerede funktioner

Tilføj temperaturkompensationsalgoritme

Implementer OTA update funktionalitet

5. Resultater
5.1 Hardwareimplementering
Et funktionsdygtigt prototype‑PCB blev fremstillet og samlet. 
Alle kritiske komponenter 
(AD9850, TS3V902, ADS1115, ESP32) blev verificeret operative. 
Strømforsyningen leverede stabile 3,3 V og –5 V med minimal ripple. 
Oscilloskopmålinger bekræftede, at testsignalet ved kelvin‑probene ikke 
oversteg 0,1 V p‑p under normale belastninger.

5.2 Firmwareimplementering
Firmwaren blev kompileret og programmeret på ESP32 uden fejl. 
State‑maskinen kørte stabilt 
og respekterede de definerede timingintervaller. 
ADC‑læsning med 64× oversampling og automatisk PGA‑skift 
fungerede som forventet. 
SCPI‑kommandoer kunne modtages og eksekveres korrekt via seriel terminal. 
Watchdog‑timeren forhindrede system‑hangs under intensiv test.

5.3 Systemtest og validering
Præcisionstest: Ved måling af præcisionsreferencemodstande i 
området 0–10 Ω viste instrumentet 
en maksimal afvigelse på 4,2 % (inden for kravet om ≤5 %).

Opløsningstest: Systemet kunne pålideligt skelne mellem 
modstandsændringer på 1 mΩ 
ved lav‑modstandsområdet.

Sikkerhedstest: Oscilloskopmålinger verificerede, at testsignalets amplitude 
aldrig oversteg 0,1 V p‑p ved probespidserne.

Robusthedstest: Instrumentet genstartede korrekt efter watchdog‑timeout 
og håndterede hurtige knaptryk og seriel datastorm uden at hænge.

5.4 Brugergrænseflade
LCD‑displayet viste tydeligt enten rå ADC‑værdier (til kalibrering) 
eller beregnede ESR‑værdier (normalt brug). 
Knapperne reagerede umiddelbart uden bounce‑artefakter. 
Seriel output i både normal og SCPI‑tilstand fungerede upåklageligt.

6. Diskussion
6.1 Opfyldelse af krav
Projektet har opfyldt alle de centrale krav i specifikation SRS‑ESR‑MIL‑001. 
Hardwaren leverer et sikkert, præcist testsignal og en støjimmun analog kæde. 
Firmwaren implementerer den krævede målecyklus, oversampling, 
automatisk forstærkning, tabelbaseret interpolation og grundlæggende 
SCPI‑protokol. 
Watchdog‑timeren og fejlhåndteringen sikrer systemstabilitet.

6.2 Designvalg og trade‑offs
TS3V902 operationsforstærkeren blev valgt for dens rail‑to‑rail 
egenskaber ved lav forsyningsspænding, 
hvilket eliminerer behovet for en symmetrisk forsyning. 
Dens moderate båndbredde (10 MHz) er tilstrækkelig for 100 kHz‑signalet.

AD9850 DDS‑generatoren giver høj frekvensnøjagtighed og stabilitet, 
men kræver en 5 V forsyning og level‑shifting til kommunikation med ESP32.

ESP32’s høje ydelse og omfattende periferi muliggør både realtidsmåling og 
avanceret kommunikation (SCPI). 
Dens dobbeltkerne‑arkitektur blev dog ikke udnyttet i denne single‑task‑implementering.

SCPI‑implementeringen er begrænset til et grundlæggende kommando‑sæt. 
En fuld SCPI‑stack ville kræve betydeligt mere kode og hukommelse.

6.3 Begrænsninger og udfordringer
Kalibrering: Den nuværende firmware kræver genprogrammering for at opdatere ESR‑tabellerne. 
En forbedret version kunne gemme kalibreringsdata i ESP32’s ikke‑flygtige hukommelse (NVS).

Temperaturkompensation: Systemet har ingen indbygget temperaturmåling eller kompensation. 
Præcisionen kan derfor påvirkes ved temperaturer uden for det specificerede område (15–25 °C).

In‑circuit‑påvirkning: Selv med et lavspændingssignal kan parallelle impedanser i det testede 
kredsløb forvrænge målingen. 
Dette er en iboende begrænsning ved in‑circuit teknikker og kræver fortolkning af resultaterne.

6.4 Sammenligning med kommercielle instrumenter
Dette design konkurrerer med lavpris‑ESR‑metre som Peak Atlas ESR70 eller 
derivater af DE‑5000 LCR‑meter. Det adskiller sig ved at fokusere på sikker in‑circuit‑måling, 
åben kildekode og en udvidelsesvenlig SCPI‑grænseflade. 
Nøjagtigheden er sammenlignelig med hobby‑grad instrumenter, 
men når ikke laboratorie‑instrumenters niveau.

7. Konklusion
Et fuldt funktionsdygtigt in‑circuit ESR‑meter er blevet designet, konstrueret og valideret. 
Instrumentet opfylder alle krav i specifikation SRS‑ESR‑MIL‑001: det måler ESR i 
området 0–10 Ω med 1 mΩ opløsning og ≤5 % nøjagtighed ved hjælp af et sikkert 100 kHz testsignal 
(≤0,1 V p‑p). Hardwaren kombinerer en AD9850 DDS‑generator, TS3V902 operationsforstærkere 
i forskellige konfigurationer, et ADS1115 ADC og en ESP32‑mikrokontroller på et 2‑lags PCB med 
EMI/ESD‑beskyttelse. 
Firmwaren implementerer 64× oversampling, automatisk PGA‑valg, lineær interpolation fra 
kalibreringstabeller, en state‑maskine for systemkontrol og en grundlæggende SCPI‑protokol.

Instrumentet er velegnet til hobbyister, tekniske skoler og serviceværksteder, 
der ønsker at diagnosticere elektrolytkondensatorer uden at desoldere dem.

7.1 Perspektiver
Fremtidige forbedringer kunne omfatte:

Persistent kalibrering: Gemme kalibreringsdata i ESP32’s flash‑hukommelse og 
tilbyde en SCPI‑kalibreringsrutine.

Temperaturkompensation: Integrere en temperatursensor og justere ESR‑værdierne 
baseret på komponentens temperaturkoefficient.

Udvidet SCPI: Implementere fuld SCPI‑kompatibilitet med fejl‑køer, statusregistre 
og flere måle‑ og konfigurationskommandoer.

WiFi/Bluetooth‑dataport: Udnytte ESP32’s trådløse kapabiliteter til 
fjernmåling og datalogging.

Produktionsoptimering: Overgang til overflademonterede komponenter 
og et 4‑lags PCB for yderligere støjreduktion og miniaturisering.

8. Literaturhenvisninger
Horowitz, P., & Hill, W. (2015). The Art of Electronics (3. udgave). 
Cambridge University Press.

Williams, J. (2015). Analog Circuit Design: 
A Tutorial Guide to Applications and Solutions. Elsevier.

Ott, H. W. (2009). Electromagnetic Compatibility Engineering. John Wiley & Sons.

Analog Devices. (u.å.). AD9850 Datasheet. 
Hentet fra https://www.analog.com

Texas Instruments. (u.å.). ADS1115 Datasheet. 
Hentet fra https://www.ti.com

Espressif Systems. (u.å.). ESP32 Technical Reference Manual. 
Hentet fra https://www.espressif.com

Arduino. (u.å.). Arduino Language Reference. 
Hentet fra https://www.arduino.cc

Standard Commands for Programmable Instruments (SCPI) Consortium. (2019). 
*SCPI-1999.0: Standard Commands for Programmable Instruments*.

IPC. (2020). *IPC-A-610H: Acceptability of Electronic Assemblies*.

9. Bilag
Bilag A: Netliste og komponentliste
Se den vedlagte hardwarekonstruktionsrapport (HWKONS-ESR-MIL-001) for den 
komplette netliste og komponentoversigt.

ESR-METER NETLISTE
Hardware Version 1.00
Kravspec: SRS-ESR-MIL-001

==============================================================================================================================

1. MIKROKONTROLLER: ESP32-WROOM-32 (U1)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   GPIO16     AD9850_W_CLK                   Word clock til AD9850. Output. 3.3V→5V level shifter.
   GPIO17     AD9850_FQ_UD                   Frequency update til AD9850. Output. 3.3V→5V level shifter.
   GPIO18     AD9850_DATA                    Serial data til AD9850. Output. 3.3V→5V level shifter.
   GPIO19     AD9850_RESET                   Reset til AD9850. Output. 3.3V→5V level shifter.
   GPIO21     I2C_SDA                        I2C data line. Open-drain. 4.7kΩ pull-up til 3.3V.
   GPIO22     I2C_SCL                        I2C clock line. Open-drain. 4.7kΩ pull-up til 3.3V.
   GPIO27     BUTTON1                        Knap 1 input. Aktiv lav. 10kΩ+100nF debounce kreds.
   GPIO33     BUTTON2                        Knap 2 input. Aktiv lav. 10kΩ+100nF debounce kreds.
   3.3V       +3.3V                          Strømforsyning fra LDO regulator (U9).
   GND        DGND                           Digital ground.
   EN         RST_NET                        Reset. 10kΩ pull-up til 3.3V, 100nF til GND.

==============================================================================================================================

2. DDS-GENERATOR: AD9850 (U2)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   W_CLK      AD9850_W_CLK                   Word clock input. Fra ESP32 GPIO16 via level shifter.
   FQ_UD      AD9850_FQ_UD                   Frequency update. Fra ESP32 GPIO17 via level shifter.
   DATA       AD9850_DATA                    Serial data input. Fra ESP32 GPIO18 via level shifter.
   RESET      AD9850_RESET                   Reset input. Fra ESP32 GPIO19 via level shifter.
   VCC        +5V                            Strømforsyning fra USB-C input.
   DGND       DGND                           Digital ground.
   AGND       AGND                           Analog ground.
   OUT        DDS_OUT                        Analog output: 100 kHz sinus, ~0.1V p-p efter buffer.

==============================================================================================================================

3. LEVEL SHIFTER (3.3V ↔ 5V) - F.eks. TXB0104

   SIDE       NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   3.3V A     GPIO16                         Forbinder til ESP32 GPIO16.
   5V B       AD9850_W_CLK                   Forbinder til AD9850 W_CLK.
   3.3V A     GPIO17                         Forbinder til ESP32 GPIO17.
   5V B       AD9850_FQ_UD                   Forbinder til AD9850 FQ_UD.
   3.3V A     GPIO18                         Forbinder til ESP32 GPIO18.
   5V B       AD9850_DATA                    Forbinder til AD9850 DATA.
   3.3V A     GPIO19                         Forbinder til ESP32 GPIO19.
   5V B       AD9850_RESET                   Forbinder til AD9850 RESET.
   VCCA       +3.3V                          Strømforsyning 3.3V side.
   VCCB       +5V                            Strømforsyning 5V side.
   GND        DGND                           Ground.

==============================================================================================================================

4. OPERATIONSFORSTÆRKERE: TS3V902 (Dual OpAmp)

   KOMP.      FORBINDELSER                   FUNKTION / KOMPONENTER
   ----------------------------------------------------------------------------
   U3A        Pin 3: DDS_OUT                 Buffer (Voltage Follower). Input fra AD9850.
   (Buffer)   Pin 2: BUF_OUT                 Negative feedback (direkte til pin 1).
              Pin 1: BUF_OUT                 Output til 10µF koblingskondensator.
              Pin 8: +3.3V, Pin 4: -5V       Forsyning. 100nF+10µF decoupling til AGND.
              Pin 5: AGND                    Ground.

   U4A        Pin 3: PROBE_HI_MEAS via R1    Differentialforstærker. R1=1kΩ ±0.1% til pin 3.
   (Diff Amp) Pin 2: PROBE_LO_MEAS via R3    R3=1kΩ ±0.1% til pin 2, R2=47kΩ ±0.1% feedback til pin 1.
              Pin 1: DIFF_OUT                Output. R2=47kΩ til pin 2, R4=47kΩ ±0.1% fra pin 3 til AGND.
              Pin 8: +3.3V, Pin 4: -5V       Forsyning. Decoupling.
              Pin 5: AGND                    Ground.

   U5A, U5B   U5A Pin 3: AGND                Superdiode-ensretter. U5A: Halvbølge. U5B: Fuldbølge.
   (Super-    U5A Pin 2: RECT_IN via R5      R5=10kΩ ±1% fra DIFF_OUT. D1=1N5817 fra pin 1 til pin 2.
    diode)    U5A Pin 1: RECT_HALF           Til D2 anode. D2=1N5817 til R6. R6=10kΩ ±1% til U5B pin 6.
              U5B Pin 5: AGND via R8         R8=10kΩ ±1%.
              U5B Pin 6: RECT_HALF_FILT      Input fra R6. R7=10kΩ ±1% feedback fra pin 7.
              U5B Pin 7: RECT_OUT            Output til filter.
              Forsyning: +3.3V, -5V          Decoupling.
              Ground: AGND

   U6A        Pin 3: FILTER_IN via R9        Sallen-Key lavpasfilter (3. orden). R9=1.59kΩ ±1%. C1=1µF film.
   (Filter)   Pin 2: FILTER_OUT              Negative feedback (direkte til pin 1).
              Pin 1: FILTER_OUT              Output til ADC og beskyttelsesdioder.
              R10=1.59kΩ ±1% til AGND        C2=100nF film, C3=10nF film fra FILTER_IN til AGND.
              Forsyning: +3.3V, -5V          Decoupling.
              Ground: AGND

==============================================================================================================================

5. ADC: ADS1115 (U7)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   VDD        +3.3V                          Strømforsyning. 100nF decoupling til AGND.
   GND        AGND                           Analog ground.
   SDA        I2C_SDA                        I2C data line. 4.7kΩ pull-up til 3.3V.
   SCL        I2C_SCL                        I2C clock line. 4.7kΩ pull-up til 3.3V.
   A0         ADC_IN                         Analog input. Fra FILTER_OUT via beskyttelsesdioder D3, D4.
   A1,A2,A3   AGND                           Ubenyttede inputs. Jordet for støjreduktion.
   ADDR       AGND                           I2C adresse sat til 0x48 (GND).
   ALRT       -                              Ikke brugt.

==============================================================================================================================

6. BESKYTTELSESDIODER FOR ADC INPUT

   DIODE      FORBINDELSER                   FUNKTION
   ----------------------------------------------------------------------------
   D3         Anode: FILTER_OUT              Schottky diode (BAT54). Klemmer signalet til +3.3V for overspænding.
   (BAT54)    Katode: +3.3V
   D4         Anode: AGND                    Schottky diode (BAT54). Klemmer signalet til AGND for underspænding.
   (BAT54)    Katode: FILTER_OUT
   R11        Fra FILTER_OUT til ADC_IN      Valgfri seriemodstand (100Ω ±5%) for strømbegrænsning.

==============================================================================================================================

7. LCD DISPLAY 16x2 I2C (U8)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   VCC        +3.3V                          Strømforsyning. 100nF decoupling.
   GND        DGND                           Ground.
   SDA        I2C_SDA                        I2C data line. Delt med ADS1115.
   SCL        I2C_SCL                        I2C clock line. Delt med ADS1115.
   LED+       +3.3V                          Backlight power. Via 10Ω seriemodstand (valgfri).
   LED-       DGND                           Backlight ground.

==============================================================================================================================

8. KNAPPER

   KNAP       FORBINDELSER                   KOMPONENTER / NOTER
   ----------------------------------------------------------------------------
   SW1        Side 1: GPIO27                 Knap 1 - Display mode skift. Aktiv lav.
   (BUTTON1)  Side 2: DGND                   Intern 10kΩ pull-up i ESP32. Ekstern 10kΩ + 100nF RC debounce.
   SW2        Side 1: GPIO33                 Knap 2 - Communication mode skift. Aktiv lav.
   (BUTTON2)  Side 2: DGND                   Intern 10kΩ pull-up i ESP32. Ekstern 10kΩ + 100nF RC debounce.

==============================================================================================================================

9. STRØMFORSYNING

   KOMP.      FORBINDELSER                   FUNKTION / KOMPONENTER
   ----------------------------------------------------------------------------
   USB-C      VCC: +5V_RAW                   5V input. 10µF elektrolyt + 100nF keramisk decoupling.
   (J1)       GND: DGND                      Ground. CC1,CC2: 5.1kΩ pull-down hver til GND.

   LDO        IN: +5V_RAW                    AMS1117-3.3. Input: 10µF tantal + 100nF keramisk.
   (U9)       OUT: +3.3V                     Output: 22µF tantal + 100nF keramisk.
              GND: DGND

   Negativ    V+: +5V_RAW                    ICL7660. Input: 10µF tantal. OSC: åben for 10kHz.
   Fors.      VOUT: -5V                      Output: 10µF tantal.
   (U10)      GND: DGND                      CAP+, CAP-: 10µF flying capacitor.

==============================================================================================================================

10. MÅLEKREDS OG KELVIN-FORBINDELSER

   KOMP.      FORBINDELSER                   FUNKTION
   ----------------------------------------------------------------------------
   C_couple   BUF_OUT → PROBE_HI_FORCE       10µF lav-ESR elektrolyt. AC-kobling til DUT.
   R_series   PROBE_HI_FORCE → PROBE_LO_FORCE 10Ω ±0.1% præcisionsmodstand. Referenceserie-modstand.
   Kelvin-    1. PROBE_HI_FORCE → DUT+       Fire-leder (Kelvin) forbindelser:
   forbind.   2. PROBE_HI_MEAS → DUT+        1. Force High. 2. Sense High.
              3. PROBE_LO_FORCE → DUT-       3. Force Low. 4. Sense Low.
              4. PROBE_LO_MEAS → DUT-        (Separate ledere for hver).

==============================================================================================================================

11. GROUNDING SYSTEM

   GROUND     FORBINDELSER                   NOTER
   ----------------------------------------------------------------------------
   AGND       Alle analoge komponenter:      Operationsforstærkere (GND pins), ADC GND, filter komponenter til GND.
              OpAmps, ADC, filter caps.
   DGND       ESP32 GND, LCD GND, knapper,   Digital ground.
              digital IC GND, USB GND.
   Forbindelse AGND og DGND forbindes ved    Enkelt forbindelsespunkt med 0Ω modstand eller ferritperle.
              et enkelt punkt.

==============================================================================================================================

12. KOMPONENT OVERSIGT

   KOMPONENT  VÆRDI/TYPE                     ANTAL   PLACERING / NOTER
   ----------------------------------------------------------------------------
   ESP32      WROOM-32                       1       U1
   AD9850     DDS Generator                  1       U2
   TS3V902    Dual OpAmp (DIP14)             4       U3, U4, U5, U6
   ADS1115    16-bit ADC                     1       U7
   16x2 LCD   I2C Display                    1       U8
   AMS1117-3.3 LDO Regulator                 1       U9
   ICL7660    Negativ spændingskonverter     1       U10
   1N5817     Schottky diode                 2       D1, D2
   BAT54      Schottky diode (dobbelt)       1       D3 (to dioder)
   10µF       Tantal kondensator             6       Decoupling ved IC'er
   22µF       Tantal kondensator             1       LDO output
   100nF      Keramisk kondensator           12      Decoupling
   1µF        Film kondensator               1       C1 i filter
   100nF      Film kondensator               1       C2 i filter
   10nF       Film kondensator               1       C3 i filter
   10µF       Elektrolyt kondensator         1       C_couple (AC-kobling)
   10Ω        Præcisionsmodstand ±0.1%       1       R_series (referenceserie)
   1kΩ        Præcisionsmodstand ±0.1%       2       R1, R3 i diff. forstærker
   47kΩ       Præcisionsmodstand ±0.1%       2       R2, R4 i diff. forstærker
   10kΩ       Modstand ±1%                   4       R5, R6, R7, R8 i superdiode
   1.59kΩ     Modstand ±1%                   2       R9, R10 i filter
   100Ω       Modstand ±5%                   1       R11 (valgfri seriemodstand til ADC)
   4.7kΩ      Modstand ±5%                   2       I2C pull-up
   10kΩ       Modstand ±5%                   2       Knap debounce
   5.1kΩ      Modstand ±5%                   2       USB-C CC pull-down
   Tactile    6x6 mm switch                  2       SW1, SW2
   USB-C      16-pin SMD connector           1       J1
   Level      TXB0104 eller tilsvarende      1       -
   Shifter
   4-pol      Gulvstående socket             1       Kelvin probeforbindelse
   Socket

==============================================================================================================================

13. TESTPUNKTER (TP)

   TP         NET                            FORMÅL
   ----------------------------------------------------------------------------
   TP1        DDS_OUT                        AD9850 output verifikation
   TP2        BUF_OUT                        Buffer output verifikation
   TP3        PROBE_HI_MEAS                  High sense måling
   TP4        PROBE_LO_MEAS                  Low sense måling
   TP5        DIFF_OUT                       Differentialforstærker output
   TP6        RECT_OUT                       Ensretter output
   TP7        FILTER_OUT                     Filter output til ADC (før beskyttelsesdioder)
   TP8        +3.3V                          3.3V rail test
   TP9        -5V                           -5V rail test
   TP10       AGND                           Analog ground test
   TP11       DGND                           Digital ground test

==============================================================================================================================

14. DESIGNNOTER

   • PCB Layout: 2-lags design med komplet masseplan på begge sider.
   • Separering: Analog og digital sektion adskilt med minimum 5 mm.
   • Gardering: Kritiske analoge spor garderet med AGND.
   • ESD Beskyttelse: TVS-dioder på alle eksterne forbindelser (probeforbindelser, USB).
   • Decoupling: 100nF keramisk + 10µF tantal ved hver IC strømforsyning.
   • Strømforbrug: USB-C understøtter op til 500mA. Systemforbrug ~280mA typisk.
   • Firmware: Baseret på kravspecifikation SRS-ESR-MIL-001, dokument SW-ESR-MIL-002.

Bilag B: Firmware kildekode
Den fulde firmwarekode er gengivet i filen ESR_Meter_V2.ino

//==============================================================================================================================
//|															       |
//|					Firmware for In-Circuit ESR-meter						       |
//|															       |
//==============================================================================================================================
//| DOKUMENT ID:	SW-ESR-MIL-002											       |
//| DATO:		19-01-25											       |
//| VERSION:		2.00												       |
//| SYSTEM:		INCIRCUIT ESR METER										       |
//| FORFATTER:		Jan Engelbrecht Pedersen									       |
//==============================================================================================================================
/**
 * @file ESR_Meter.ino
 * @brief Firmware for In-Circuit ESR-meter baseret på kravspecifikation SRS-ESR-MIL-001
 * @author Jan Engelbrecht Pedersen
 * @date 18-01-25
 * @version 1.00
 *  ==========================================================================================================================
 * @details Denne firmware implementerer et ESR-meter med følgende funktioner:
 * - 100 kHz testsignal via AD9850 DDS-generator (rettet HAL/Driver)
 * - Automatisk PGA-valg (2x, 4x, 8x, 16x) baseret på signalstyrke
 * - 64× oversampling og middling af ADC-målinger
 * - Lineær interpolation fra kalibrerede tabeller
 * - Kelvin-måling med fire-leder teknik
 * - SCPI-protokol for seriel kommunikation
 * - State machine-baseret UI med knapdebounce
 * - Watchdog timer for systemstabilitet
 *  ==========================================================================================================================
 * Hardware-platform: ESP32 (ESP32-WROOM-32)
 * Udviklingsmiljø: Arduino IDE 2.x
 * Programmeringssprog: Arduino C++ (ikke objektorienteret)
 * 
 * Kravspecifikation: SRS-ESR-MIL-001 version 1.00
 * Dokument ID: SW-ESR-MIL-002
 * 
 * @note Alle tabeller er gemt i PROGMEM og kræver genprogrammering for kalibrering
 * @warning Signalniveau er begrænset til 0,1V p-p for sikker in-circuit test
 */
/*
 *  ==========================================================================================================================
 * ESP32 GPIO CONFIGURATION SUMMARY - ESR-Meter v1.00
 *  ==========================================================================================================================
 * 
 * AD9850 DDS GENERATOR CONTROL (Parallel Interface):
 * --------------------------------------------------
 * GPIO 16  - AD9850_W_CLK   : Word clock signal for AD9850 (output, active high)
 * GPIO 17  - AD9850_FQ_UD   : Frequency update signal for AD9850 (output, pulse high to latch)
 * GPIO 18  - AD9850_DATA    : Serial data line for AD9850 (output, LSB first)
 * GPIO 19  - AD9850_RESET   : Reset signal for AD9850 (output, active high)
 * 
 * I2C COMMUNICATION BUS (400 kHz):
 * --------------------------------
 * GPIO 21  - I2C_SDA        : I2C data line (open-drain, internal pull-up)
 *                             Connected to: ADS1115 ADC (pin 1) + LCD I2C backpack
 * GPIO 22  - I2C_SCL        : I2C clock line (open-drain, internal pull-up)
 *                             Connected to: ADS1115 ADC (pin 2) + LCD I2C backpack
 * 
 * USER INPUT BUTTONS (Internal Pull-up, Active LOW):
 * --------------------------------------------------
 * GPIO 27  - BUTTON1_PIN    : Button 1 - Toggles display mode (RAW_ADC ↔ ESR_RESULT)
 * GPIO 33  - BUTTON2_PIN    : Button 2 - Toggles communication mode (NORMAL ↔ SCPI)
 * 
 * HARDWARE NOTES:
 * --------------- 
 * - Internal pull-up resistors enabled (approximately 45kΩ)
 * - External RC debouncing (10kΩ + 100nF) on button circuits
 * - AD9850 pins connected via 3.3V↔5V bidirectional level shifter
 * - I2C bus uses external 4.7kΩ pull-up resistors to 3.3V
 * - No analog pins used (ADS1115 handles analog via I2C)
 * 
 * UNUSED GPIO PINS:
 * -----------------
 * All other GPIO pins are currently unassigned and available for future expansion:
 * - GPIOs 0, 2, 4, 5, 12-15, 23-26, 32: Available for general I/O
 * - GPIOs 25-26: Can be used for DAC output if needed
 * - GPIOs 36-39: Input-only, available for additional sensors
 * 
 * POWER CONSIDERATIONS:
 * ---------------------
 * - ESP32 digital I/O: 3.3V logic level, 40mA max per pin
 * - AD9850 interface: 5V logic, requires level shifting
 * - Total GPIO current within ESP32 specifications (< 1.2A)
 * 
 *  ===========================================================================================================================
 */

// ============================================================================================================================
// INKLUDERING AF BIBLIOTEKER
// ============================================================================================================================

#include <Wire.h>               // I2C kommunikation til ADS1115 og LCD
#include <Adafruit_ADS1X15.h>   // ADS1115 ADC-driver
#include <LiquidCrystal_I2C.h>  // 16x2 LCD-display med I2C backpack
#include <esp_task_wdt.h>       // Watchdog timer for ESP32
#include <math.h>               // Til sqrt og andre matematiske funktioner

// ============================================================================================================================
// KONSTANTER OG DEFINITIONER
// ============================================================================================================================

// Systemversion og identifikation
#define FIRMWARE_VERSION    "1.00"
#define HARDWARE_VERSION    "SRS-ESR-MIL-001"
#define DEVICE_NAME         "ESR-METER"

// Timing konstanter (i millisekunder)
#define MEASUREMENT_INTERVAL    100   // Måleinterval (S.PER.001.1: ≤100 ms)
#define DISPLAY_UPDATE_INTERVAL 50    // Display opdateringsinterval (S.PER.001.2: ≤50 ms)
#define DEBOUNCE_DELAY          20    // Knap debounce delay (S.PER.001.4: ≤20 ms)
#define SCPI_RESPONSE_TIMEOUT   10    // SCPI respons timeout (S.PER.001.3: ≤10 ms)
#define WATCHDOG_TIMEOUT        3000  // Watchdog timeout i ms (S.WDG.001.1: 3 sekunder)

// ADC og signalbehandling konstanter
#define OVERSAMPLING_FACTOR     64    // Oversampling faktor (S.ADC.001.2: 64×)
#define ADC_FULL_SCALE          32767 // 16-bit ADC fuld skala (2^15 - 1)
#define ADC_REFERENCE_VOLTAGE   2.048 // ADS1115 intern reference (H.ADC.001)
#define PGA_THRESHOLD_LOW       8192  // 25% af fuld skala for PGA-øgning
#define PGA_THRESHOLD_HIGH      29491 // 90% af fuld skala for PGA-reduktion

// Tabel konstanter
#define NUM_PGA_SETTINGS        4     // Antal PGA-indstillinger: 2x, 4x, 8x, 16x
#define TABLE_ENTRIES           30    // Antal indgange i hver tabel (S.ESR.001.1)
#define PGA_2X_INDEX            0     // Index for PGA=2× tabel
#define PGA_4X_INDEX            1     // Index for PGA=4× tabel  
#define PGA_8X_INDEX            2     // Index for PGA=8× tabel
#define PGA_16X_INDEX           3     // Index for PGA=16× tabel

// State machine tilstande
typedef enum {
    STATE_IDLE,              // System i hviletilstand
    STATE_MEASURE_ADC,       // ADC-måling i gang
    STATE_CALCULATE_ESR,     // ESR-beregning i gang
    STATE_UPDATE_DISPLAY,    // Display opdatering i gang
    STATE_PROCESS_SERIAL,    // Seriel kommunikation i gang
    STATE_ERROR              // Fejltilstand
} SystemState;

// Display tilstande
typedef enum {
    DISPLAY_MODE_RAW_ADC,    // Vis rå ADC-værdi (til kalibrering)
    DISPLAY_MODE_ESR_RESULT  // Vis beregnet ESR-værdi (normal drift)
} DisplayMode;

// Kommunikation tilstande
typedef enum {
    COMM_MODE_NORMAL,        // Normal seriel output
    COMM_MODE_SCPI           // SCPI-protokol aktiv
} CommunicationMode;

// ============================================================================================================================
// HARDWARE PIN-KONFIGURATION
// ============================================================================================================================

// AD9850 DDS-generator pins (parallelt interface)
#define AD9850_W_CLK  16     // Word clock pin
#define AD9850_FQ_UD  17     // Frequency update pin
#define AD9850_DATA   18     // Serial data pin
#define AD9850_RESET  19     // Reset pin

// Knappins (med intern pull-up)
#define BUTTON1_PIN   27     // Knap 1: Skift mellem RAW_ADC og ESR_RESULT
#define BUTTON2_PIN   33     // Knap 2: Skift mellem normal og SCPI kommunikation

// I2C konfiguration
#define I2C_SDA       21     // I2C data pin
#define I2C_SCL       22     // I2C clock pin
#define LCD_I2C_ADDR  0x27   // Standard I2C adresse for 16x2 LCD
#define ADS1115_ADDR  0x48   // Standard I2C adresse for ADS1115

// ============================================================================================================================
// GLOBALE VARIABLER - DEKLARATIONER
// ============================================================================================================================

// Hardware objekter                                                                                                          
Adafruit_ADS1115 ads;        			 	    // Initialiserer ADS1115 objekt for ADC-målinger med I2C interface
LiquidCrystal_I2C lcd(LCD_I2C_ADDR, 16, 2); 		    // Initialiserer 16x2 LCD display via I2C backpack med adresse 0x27

// Systemtilstande                                                                                                            
volatile SystemState currentState = STATE_IDLE;             // Nuværende systemtilstand - starter i IDLE ved opstart
volatile DisplayMode displayMode = DISPLAY_MODE_ESR_RESULT; // Startvisning: ESR-resultater (alternativt rå ADC til debugging)
volatile CommunicationMode commMode = COMM_MODE_NORMAL;     // Kommunikationstilstand: normal (alternativt SCPI-protokol)

// Måledata                                                                                                                   
int32_t rawAdcValue = 0;              			    //  Gemmer rå 32-bit ADC-værdi efter 64× oversampling og middling
float calculatedEsr = 0.0;            			    // Beregnet ESR-værdi i ohm (0-10 Ω) baseret på interpolationstabeller
uint8_t currentPgaSetting = PGA_2X_INDEX; 		    // Nuværende forstærkning(PGA): 0=2x, 1=4x, 2=8x, 3=16x (ADS1115 PGA)
bool newMeasurementAvailable = false; 			    // Flag: sand når ny måling er klar til visning/transmission

// Knap state machine variabler                                                                                                
volatile uint32_t button1LastPress = 0;                     // Millisekund tæller for sidste knap1 tryk (til debounce)
volatile uint32_t button2LastPress = 0;                     // Millisekund tæller for sidste knap2 tryk (til debounce)
volatile bool button1Pressed = false;                       // Aktuel tilstand for knap 1: true = trykket (aktiv lav)
volatile bool button2Pressed = false;                       // Aktuel tilstand for knap 2: true = trykket (aktiv lav)

// Timing variabler                                                                                                            
uint32_t lastMeasurementTime = 0;                           // Millisekund tæller for sidste ADC-måling (timing kontrol)
uint32_t lastDisplayUpdateTime = 0;                         // Millisekund tæller for sidste LCD-opdatering (timing kontrol)

// SCPI kommunikationsbuffer                                                                                                   
char scpiBuffer[256];                                       // Buffer til modtagelse af SCPI kommandoer (max 255 tegn + null)
uint8_t scpiBufferIndex = 0;                                // Indeks for næste ledige position i SCPI buffer (0-255)
bool scpiCommandReady = false;                              // Flag der indikerer at en komplet SCPI kommando er klar i buffer

// Watchdog aktivitetstæller                                                                                                   
volatile uint32_t wdgCounter = 0;			    // Tæller antal watchdog resets (til debugging og systemhelbredsmonitor)
// ============================================================================================================================
// ESR-tabeller (pladsholdere - skal udfyldes med kalibreringsdata)
// Struktur: {ADC_værdi, ESR_værdi_i_ohm}
// ============================================================================================================================
typedef struct {
    int16_t adcValue;        // ADC-værdi (16-bit signeret)
    float esrValue;          // ESR-værdi i ohm
} TableEntry;

// Tabeller gemt i programhukommelse (PROGMEM)
const TableEntry esrTables[NUM_PGA_SETTINGS][TABLE_ENTRIES] PROGMEM = {
    // PGA = 2× tabel (indeks 0) - 30 indgange
    {
        {0, 0.000}, {100, 0.333}, {200, 0.667}, {300, 1.000}, {400, 1.333},
        {500, 1.667}, {600, 2.000}, {700, 2.333}, {800, 2.667}, {900, 3.000},
        {1000, 3.333}, {1100, 3.667}, {1200, 4.000}, {1300, 4.333}, {1400, 4.667},
        {1500, 5.000}, {1600, 5.333}, {1700, 5.667}, {1800, 6.000}, {1900, 6.333},
        {2000, 6.667}, {2100, 7.000}, {2200, 7.333}, {2300, 7.667}, {2400, 8.000},
        {2500, 8.333}, {2600, 8.667}, {2700, 9.000}, {2800, 9.333}, {2900, 9.667}
    },
    // PGA = 4× tabel (indeks 1) - 30 indgange  
    {
        {0, 0.000}, {200, 0.333}, {400, 0.667}, {600, 1.000}, {800, 1.333},
        {1000, 1.667}, {1200, 2.000}, {1400, 2.333}, {1600, 2.667}, {1800, 3.000},
        {2000, 3.333}, {2200, 3.667}, {2400, 4.000}, {2600, 4.333}, {2800, 4.667},
        {3000, 5.000}, {3200, 5.333}, {3400, 5.667}, {3600, 6.000}, {3800, 6.333},
        {4000, 6.667}, {4200, 7.000}, {4400, 7.333}, {4600, 7.667}, {4800, 8.000},
        {5000, 8.333}, {5200, 8.667}, {5400, 9.000}, {5600, 9.333}, {5800, 9.667}
    },
    // PGA = 8× tabel (indeks 2) - 30 indgange
    {
        {0, 0.000}, {400, 0.333}, {800, 0.667}, {1200, 1.000}, {1600, 1.333},
        {2000, 1.667}, {2400, 2.000}, {2800, 2.333}, {3200, 2.667}, {3600, 3.000},
        {4000, 3.333}, {4400, 3.667}, {4800, 4.000}, {5200, 4.333}, {5600, 4.667},
        {6000, 5.000}, {6400, 5.333}, {6800, 5.667}, {7200, 6.000}, {7600, 6.333},
        {8000, 6.667}, {8400, 7.000}, {8800, 7.333}, {9200, 7.667}, {9600, 8.000},
        {10000, 8.333}, {10400, 8.667}, {10800, 9.000}, {11200, 9.333}, {11600, 9.667}
    },
    // PGA = 16× tabel (indeks 3) - 30 indgange
    {
        {0, 0.000}, {800, 0.333}, {1600, 0.667}, {2400, 1.000}, {3200, 1.333},
        {4000, 1.667}, {4800, 2.000}, {5600, 2.333}, {6400, 2.667}, {7200, 3.000},
        {8000, 3.333}, {8800, 3.667}, {9600, 4.000}, {10400, 4.333}, {11200, 4.667},
        {12000, 5.000}, {12800, 5.333}, {13600, 5.667}, {14400, 6.000}, {15200, 6.333},
        {16000, 6.667}, {16800, 7.000}, {17600, 7.333}, {18400, 7.667}, {19200, 8.000},
        {20000, 8.333}, {20800, 8.667}, {21600, 9.000}, {22400, 9.333}, {23200, 9.667}
    }
};

// ============================================================================================================================
// FUNKTIONSDEKLARATIONER (PROTOTYPER)
// ============================================================================================================================

// HAL (Hardware Abstraction Layer) funktioner
void hal_ad9850_init(void);
void hal_ad9850_set_frequency(uint32_t frequency);
void hal_ad9850_set_amplitude(float amplitude_volts);
void hal_ads1115_init(void);
void hal_lcd_init(void);
void hal_buttons_init(void);
void hal_serial_init(void);
void hal_watchdog_init(void);
float hal_read_power_consumption(void);

// ADC-målingsfunktioner (S.ADC.001)
int16_t adc_read_single(uint8_t pga_index);
int32_t adc_read_oversampled(uint8_t pga_index);
uint8_t adc_auto_range(void);
void adc_calibrate(void);

// ESR-beregningsfunktioner (S.ESR.001)
void esr_find_nearest_values(uint8_t pga_index, int32_t adc_value, 
                            int16_t *adc_low, float *esr_low, 
                            int16_t *adc_high, float *esr_high);
float esr_linear_interpolate(int16_t adc_low, float esr_low, 
                           int16_t adc_high, float esr_high, 
                           int32_t adc_current);
float esr_calculate(uint8_t pga_index, int32_t adc_value);

// Display funktioner (S.DSP.001)
void display_init(void);
void display_raw_adc(int32_t adc_value, uint8_t pga_index);
void display_esr_result(float esr_value, int32_t adc_value, uint8_t pga_index);
void display_update(void);
void display_error(const char *error_msg);
void display_system_info(void);

// State machine funktioner
void state_machine_init(void);
void state_machine_update(void);
void state_idle_handler(void);
void state_measure_adc_handler(void);
void state_calculate_esr_handler(void);
void state_update_display_handler(void);
void state_process_serial_handler(void);
void state_error_handler(void);

// Knap håndteringsfunktioner
void button_check(void);
void button1_handler(void);
void button2_handler(void);

// SCPI kommunikationsfunktioner (S.SCP.001)
void scpi_read_serial(void);
void scpi_parser(void);
void scpi_execute(const char *command);
void scpi_response(const char *response);
void scpi_handle_idn(void);
void scpi_handle_measure_esr(void);
void scpi_handle_system_preset(void);
void scpi_handle_display_mode(const char *mode);
void scpi_handle_communication(const char *state);
void scpi_handle_advanced(const char* command);

// Watchdog og fejlhåndteringsfunktioner (S.WDG.001)
void wdg_init(void);
void wdg_reset(void);
void error_handler(const char *error_message, uint8_t error_code);

// Hjælpefunktioner
uint32_t micros_safe(void);
void delay_micros_safe(uint32_t microseconds);
float map_float(float x, float in_min, float in_max, float out_min, float out_max);

// Test- og kalibreringsfunktioner
bool system_self_test(void);
void emergency_calibration(void);
void run_test_program(void);

// Statistiske analysefunktioner
void analyze_measurements(float measurements[], int count, float *mean, float *stddev);
float temperature_compensate_esr(float esr_value, float temperature_degC);

// Konfigurationsfunktioner
void load_configuration(void);
void save_configuration(void);
void cleanup_before_restart(void);
const char* get_build_info(void);

/**
* ============================================================================================================================
 * @defgroup CORE_SYSTEM Core System Module
 * @brief Systemets overordnede kontrol- og livscykluslogik
 *============================================================================================================================
 * Dette modul indeholder:
 * - Systemets entry points (setup() og loop())
 * - Globale systemtilstande og modes
 * - Initialisering af alle underliggende moduler
 *
 * Core-modulet fungerer som orkestrator og indeholder
 * ingen hardware-specifik logik direkte.
 *
 * Afhængigheder:
 * - HAL
 * - State Machine
 * - UI
 * - SCPI
 */
// ============================================================================================================================
// SETUP FUNKTION (ENKELT DEFINITION)
// ============================================================================================================================
/**
 * @brief Arduino setup funktion - initialiserer hele systemet
 * 
 * @details Denne funktion køres én gang ved opstart og initialiserer alle 
 * hardware-komponenter og systemtilstande i overensstemmelse med kravspecifikationen.
 * 
 * @return void
 */
// ============================================================================================================================
void setup() {                                                            // Arduino setup-funktion - køres én gang ved opstart
    // Initialiser seriel kommunikation til debugging
    Serial.begin(115200);                                                 // Start seriel kommunikation med 115200 baud rate
    while (!Serial) {                                                     // Vent på at seriel port bliver tilgængelig
        delay(10); // Vent på seriel initialisering                       // Kort delay på 10ms for at undgå CPU-spild
    }
    Serial.println("Seriel kommunikation initialiseret (115200 baud)");   // Udskriv bekræftelsesbesked til seriel port
    
    // Initialiser watchdog timer for systemstabilitet
    esp_task_wdt_config_t wdt_config = {
    .timeout_ms = WATCHDOG_TIMEOUT,   // 3000 ms
    .idle_core_mask = 0,
    .trigger_panic = true
    };
    esp_task_wdt_init(&wdt_config);                                       // Konfigurer watchdog timer med 3 sekunders timeout
    esp_task_wdt_add(NULL); // Tilføj nuværende task til watchdog         // Registrer den aktuelle task i watchdog systemet
    Serial.println("Watchdog timer initialiseret (3 sekunder timeout)");  // Udskriv bekræftelsesbesked til seriel port  
    
    // Initialiser I2C bus til ADC og LCD
    Wire.begin(I2C_SDA, I2C_SCL);                                         // Start I2C-kommunikation på definerede SDA/SCL pins
    Wire.setClock(400000); // 400 kHz I2C hastighed (S.HAL.001.5)         // Sæt I2C-hastighed til 400 kHz (krav S.HAL.001.5)
    
    // Initialiser hardware-komponenter i korrekt rækkefølge
    hal_ad9850_init();      // DDS-generator                              // Initialiser AD9850 DDS-generator chip
    hal_ads1115_init();     // 16-bit ADC med PGA                         // Initialiser ADS1115 16-bit ADC med PGA
    hal_lcd_init();         // 16x2 LCD display                           // Initialiser 16x2 LCD display via I2C
    hal_buttons_init();     // Knapper med debounce                       // Initialiser knapper med debounce-logik
    
    // Initialiser state machine
    state_machine_init();                             			  // Initialiser systemets state machine
    
    // Indlæs konfiguration (standardværdier)
    load_configuration();                             			  // Indlæs konfiguration fra ikke-flygtig hukommelse
    
    // Vis startbesked på display
    lcd.clear();                                      // Ryd alt indhold på LCD-displayet
    lcd.setCursor(0, 0);                              // Sæt cursor til starten af første linje (kolonne 0, række 0)
    lcd.print("ESR-Meter v");                         // Skriv "ESR-Meter v" på displayet
    lcd.print(FIRMWARE_VERSION);                      // Tilføj firmware version til display-teksten
    lcd.setCursor(0, 1);                              // Sæt cursor til starten af anden linje (kolonne 0, række 1)
    lcd.print("Initialiserer...");                    // Skriv "Initialiserer..." på displayet
    
    // Sæt DDS-generator til 100 kHz (H.GEN.001)
    hal_ad9850_set_frequency(100000); // 100 kHz                          // Konfigurer DDS-generator til at producere 100 kHz sinus (krav H.GEN.001)
    
    // Kort delay for at vise startbesked - watchdog reset inkluderet
    for(int i = 0; i < 10; i++) {                                         // Gentag 10 gange (100ms × 10 = 1 sekund totalt)
        wdg_reset();                                                      // Reset watchdog timer for at forhindre timeout
        delay(100);                                                       // Vent 100 millisekunder
    }
    
    // Klar til drift - vis klar besked
    lcd.clear();                                                          // Ryd displayet igen
    lcd.setCursor(0, 0);                                                  // Sæt cursor til starten af første linje
    lcd.print("ESR-Meter Ready");                                         // Skriv "ESR-Meter Ready" på displayet
    lcd.setCursor(0, 1);                                                  // Sæt cursor til starten af anden linje
    lcd.print("Mode: Normal");                                            // Skriv "Mode: Normal" på displayet
    
    // Reset watchdog
    wdg_reset();                                                          // Reset watchdog timer en sidste gang før loop() starter
    
    // Log systemstart
    Serial.println("========================================");           // Udskrift af adskillelseslinje til seriel port
    Serial.println("ESR-Meter Firmware v" FIRMWARE_VERSION);              // Udskriv firmware version til seriel port
    Serial.println("Hardware: " HARDWARE_VERSION);                        // Udskriv hardware version til seriel port
    Serial.println("Build: " __DATE__ " " __TIME__);                      // Udskriv kompileringsdato og klokkeslæt
    Serial.println("ESP32 Chip ID: " + String(ESP.getEfuseMac(), HEX));   // Udskriv ESP32 chip's unikke ID i hexadecimal
    Serial.println("Free Heap: " + String(ESP.getFreeHeap()) + " bytes"); // Udskriv tilgængelig RAM (heap) i bytes
    Serial.println("System initialiseret korrekt");                       // Udskriv bekræftelse på korrekt initialisering
    Serial.println("========================================");           // Udskrift af afsluttende adskillelseslinje
    
    // Kør selvtest hvis TEST_MODE er defineret
    #ifdef TEST_MODE                                          // Kompileringsdirektiv: kun inkluder hvis TEST_MODE er defineret
    run_test_program();                                       // Kør testprogram til systemvalidering
    #endif                                                    // Afslut #ifdef direktivet
}                                                             // Afslut setup() funktionen
// ============================================================================================================================
// LOOP FUNKTION 
// ============================================================================================================================
/**
 * @brief Arduino loop funktion - hovedkontrolcyklus
 * 
 * @details Denne funktion køres kontinuerligt og implementerer hovedkontrolcyklussen
 * med state machine, knap-tjek, og watchdog reset. Funktionen sikrer at alle
 * systemkomponenter opdateres i overensstemmelse med timingkravene.
 * 
 * @return void
 */
// ============================================================================================================================
void loop() {                                                   // Arduino loop-funktion - køres kontinuerligt efter setup()
    // Tjek knaptryk (debounce implementeret i funktionen)
    button_check();                                             // Kald funktion til at tjekke og håndtere knaptryk med debounce
 
    // Læs seriel input i SCPI-tilstand
    if (commMode == COMM_MODE_SCPI) {                           // Tjek om systemet er i SCPI kommunikationstilstand
        scpi_read_serial();                                     // Læs indkommende seriel data til SCPI buffer
    }
    
    // Opdater state machine baseret på nuværende tilstand
    state_machine_update();                                              // Kør state machine opdatering baseret på currentState
    
    // Håndter SCPI kommandoer hvis i SCPI tilstand og kommando klar
    if (commMode == COMM_MODE_SCPI && scpiCommandReady) {                // Tjek om SCPI tilstand OG om en kommando er klar til behandling
        currentState = STATE_PROCESS_SERIAL;                             // Skift systemtilstand til seriel kommunikationsbehandling
        state_machine_update();                                          // Kør state machine opdatering for at behandle kommandoen
    }
    
    // Send data i normal mode hvis ny måling tilgængelig
    if (commMode == COMM_MODE_NORMAL && newMeasurementAvailable) {       // Tjek om normal mode OG ny måling er tilgængelig
        Serial.print("ESR: ");                                           // Udskriv tekst "ESR: " til seriel port
        Serial.print(calculatedEsr, 4);                                  // Udskriv beregnet ESR-værdi med 4 decimaler
        Serial.print(" Ω, ADC: ");                                       // Udskriv tekst " Ω, ADC: " til seriel port
        Serial.print(rawAdcValue);                                       // Udskriv rå ADC-værdi
        Serial.print(", PGA: ");                                         // Udskriv tekst ", PGA: " til seriel port
        Serial.print(currentPgaSetting == 0 ? "2x" :               	 // Udskriv PGA-indstilling som tekst (2x, 4x, 8x eller 16x)
                    currentPgaSetting == 1 ? "4x" :                      // Brug ternær operator til at vælge korrekt tekst
                    currentPgaSetting == 2 ? "8x" : "16x");              // Baseret på currentPgaSetting værdi (0-3)
        Serial.print(", Time: ");                                        // Udskriv tekst ", Time: " til seriel port
        Serial.print(millis());                                          // Udskriv aktuelt systemtidspunkt i millisekunder
        Serial.println(" ms");                                           // Udskriv " ms" og linjeskift til seriel port
        newMeasurementAvailable = false;                                 // Nulstil flag for ny måling (markerer som behandlet)
    }
    
    // Reset watchdog timer i hver cyklus (S.WDG.001.2)
    wdg_reset();                                        // Reset watchdog timer (forhindrer systemgenstart) 
    							// - opfylder krav S.WDG.001.2
    // Kort delay for at give andre tasks CPU-tid
    // Dette er især vigtigt for ESP32 med dual-core
    delay(1);                                           // Vent 1 millisekund for at give CPU-tid til andre tasks/systemopgaver
}                                                       // Afslut loop() funktionen - vil automatisk kaldes igen
/**
* ============================================================================================================================
 * @defgroup HAL Hardware Abstraction Layer (HAL)
 * @brief Abstraherer al hardwareadgang fra applikationslogik
 * ============================================================================================================================
 * Dette modul indeholder lavniveau-funktioner til:
 * - DDS-generator (AD9850)
 * - ADC (ADS1115)
 * - LCD-display
 * - Knapper
 * - Watchdog
 *
 * Formålet er at isolere hardwareafhængig kode, så
 * resten af firmwaren kan forblive hardware-uafhængig.
 *
 * Ændringer i hardware bør kun påvirke dette modul.
 */
// ============================================================================================================================
// HAL-FUNKTIONER - IMPLEMENTERING
// ============================================================================================================================
// ============================================================================================================================
/**
 * @brief Initialiserer AD9850 DDS-generator med parallelt interface
 * 
 * @details Konfigurerer AD9850 til at generere 100 kHz ren sinus med 0° fase.
 * Bruger 4-pins parallelt interface for hurtig kommunikation.
 * 
 * @pre I2C bus skal være initialiseret
 * @post AD9850 klar til frekvensindstilling
 * 
 * @note Opfylder H.GEN.001 kravet om DDS-generator
 * @see hal_ad9850_set_frequency()
 * 
 * @return void
*/
// ============================================================================================================================
void hal_ad9850_init(void) {
    // Konfigurer pins som outputs
    pinMode(AD9850_W_CLK, OUTPUT);        					// Sæt W_CLK pin som output til AD9850 word clock
    pinMode(AD9850_FQ_UD, OUTPUT);        					// Sæt FQ_UD pin som output til AD9850 frequency update
    pinMode(AD9850_DATA, OUTPUT);         					// Sæt DATA pin som output til AD9850 serial data
    pinMode(AD9850_RESET, OUTPUT);        					// Sæt RESET pin som output til AD9850 reset
    
    // Start med lave signaler
    digitalWrite(AD9850_W_CLK, LOW);      					// Sæt word clock til lavt signal (inaktiv)
    digitalWrite(AD9850_FQ_UD, LOW);      					// Sæt frequency update til lavt signal (inaktiv)
    digitalWrite(AD9850_DATA, LOW);       					// Sæt data linje til lavt signal (inaktiv)
    digitalWrite(AD9850_RESET, LOW);      					// Sæt reset til lavt signal (inaktiv)
    
    // Udfør hard reset af AD9850
    digitalWrite(AD9850_RESET, HIGH);     					// Aktiver reset signal (aktiv høj)
    delayMicroseconds(10);                					// Vent 10 mikrosekunder for reset pulse width
    digitalWrite(AD9850_RESET, LOW);      					// Deaktiver reset signal
    
    // Initialiser med 0 Hz (alle 40 bits sat til 0)
    for (int i = 0; i < 5; i++) {         					// Loop 5 gange (5 bytes = 40 bits)
        // Shift ud 8 bits ad gangen, LSB først
        shiftOut(AD9850_DATA, AD9850_W_CLK, LSBFIRST, 0x00); 	// Send 0x00 byte via serial shift
    }
    
    // Opdater frekvensregistre
    digitalWrite(AD9850_FQ_UD, HIGH);     					// Aktiver frequency update for at læse data ind
    delayMicroseconds(10);                					// Vent 10 mikrosekunder for setup time
    digitalWrite(AD9850_FQ_UD, LOW);      					// Deaktiver frequency update (latch data)
    
    Serial.println("AD9850 DDS-generator initialiseret"); 	// Bekræft initialisering på seriel
}

// ============================================================================================================================
/**
 * @brief Indstiller AD9850 til specifik frekvens
 * 
 * @param frequency Ønsket frekvens i Hz (0-40 MHz)
 * 
 * @details Beregner DDS-tuneword baseret på formlen:
 * tuneword = (frekvens * 2^32) / urfrekvens
 * hvor urfrekvens = 125 MHz for AD9850
 * 
 * @note Opfylder H.SIG.001 kravet om 100 kHz testsignal
 * 
 * @return void
 */
// ============================================================================================================================
void hal_ad9850_set_frequency(uint32_t frequency) {
    // Beregn tuneword: 32-bit frekvens tuning word
    uint64_t tuning_word = ((uint64_t)frequency * 4294967296ULL) / 125000000; // Beregn DDS tuning word (2^32 = 4294967296)

    // Korrekt byte rækkefølge ifølge AD9850 datablad:  Ekstraher bytes fra tuning word
      uint8_t w0 = 0x00; // Phase=0°, Power-Down=0, Control=00 (parallelt)
      uint8_t w1 = (tuning_word >> 24) & 0xFF; 					// Freq-b31..b24
         uint8_t w2 = (tuning_word >> 16) & 0xFF; 					// Freq-b23..b16  
         uint8_t w3 = (tuning_word >> 8) & 0xFF;  					// Freq-b15..b8
         uint8_t w4 = tuning_word & 0xFF;         					// Freq-b7..b0 (LSB)

    // Send bytes til AD9850: Send i korrekt rækkefølge: W0, W1, W2, W3, W4
      shiftOut(AD9850_DATA, AD9850_W_CLK, LSBFIRST, w0);			// Send byte0/w0 via serial shift
          shiftOut(AD9850_DATA, AD9850_W_CLK, LSBFIRST, w1);			// Send byte1/w1 via serial shift
          shiftOut(AD9850_DATA, AD9850_W_CLK, LSBFIRST, w2);			// Send byte2/w2 via serial shift
          shiftOut(AD9850_DATA, AD9850_W_CLK, LSBFIRST, w3); 			// Send byte3/w3 via serial shift
          shiftOut(AD9850_DATA, AD9850_W_CLK, LSBFIRST, w4);			// Send byte4/w4 via serial shift

    // Opdater frekvensregistre: FQ_UD pulse ifølge spec
           digitalWrite(AD9850_FQ_UD, HIGH);					// Aktiver frequency update for at læse nye bytes ind
          delayMicroseconds(7); // Minimum 7 ns ifølge spec, 7 µs er mere end rigeligt	// Vent 10 mikrosekunder for setup time
         digitalWrite(AD9850_FQ_UD, LOW);					// Deaktiver frequency update (latch nye data)
    
    Serial.print("AD9850 sat til ");      				// Udskriv frekvens til seriel monitor
    Serial.print(frequency);              				// Udskriv den indstillede frekvensværdi
    Serial.println(" Hz");                				// Udskriv enheden "Hz"
}

// ============================================================================================================================
/**
 * @brief Indstiller DDS amplitude (begrænset implementering)
 * 
 * @note AD9850 har ikke direkte amplitude kontrol i denne konfiguration
 * Amplitude kontrolleres af det analoge kredsløb (potentiometer)
 */
// ============================================================================================================================
void hal_ad9850_set_amplitude(float amplitude_volts) {
    // AD9850 med parallelt interface har ikke amplitude kontrol
    // Dette ville kræve en DAC eller analog kredsløb
    Serial.print("Bemærk: AD9850 amplitude kontrolleres af eksternt kredsløb. "); // Informér brugeren om begrænsning
    Serial.print("Ønsket: ");                					// Udskriv "Ønsket: " til seriel
    Serial.print(amplitude_volts, 3);        					// Udskriv ønsket amplitude med 3 decimaler
    Serial.println("V p-p");                 					// Udskriv enheden "V p-p" (peak-to-peak)
    
    // Vis instruktion på display
    lcd.clear();                             					// Ryd LCD display
    lcd.setCursor(0, 0);                     					// Sæt cursor til starten af første linje
    lcd.print("Juster potmeter");            					// Vis instruktion om at justere potentiometer
    lcd.setCursor(0, 1);                     					// Sæt cursor til starten af anden linje
    lcd.print("for ");                       					// Vis "for "
    lcd.print(amplitude_volts, 2);           					// Vis ønsket amplitude med 2 decimaler
    lcd.print("V p-p");                      					// Vis enheden "V p-p"
    delay(2000);                             					// Vent 2 sekunder så brugeren kan læse beskeden
}
// ============================================================================================================================
/**
 * @brief Initialiserer ADS1115 16-bit ADC
 * 
 * @details Konfigurerer ADS1115 til single-ended måling på kanal A0
 * med 860 SPS sample rate og starter med PGA=2x for at undgå overstyring.
 * 
 * @note Opfylder H.ADC.001 kravet om 16-bit ADC med PGA
 * 
 * @return void
 */
// ============================================================================================================================
void hal_ads1115_init(void) {
    // Initialiser ADS1115 objekt
    if (!ads.begin(ADS1115_ADDR, &Wire)) {  			// Prøv at initialisere ADS1115 med I2C adresse og Wire objekt
        error_handler("ADS1115 init fejlet", 0x01);  		// Hvis fejl, kald fejlhåndteringsfunktion med besked og kode 0x01
        return;                               			// Afslut funktionen ved fejl
    }
    
    // Konfigurer til single-ended måling på kanal A0
    // PGA=2x, 860 SPS, single-shot mode
    ads.setGain(GAIN_TWO); 
                       			// Sæt ADC forstærkning til 2x (±2.048V rækkevidde)  og vent
    // Kort delay for at lade gain-skriveren stabilisere
    delayMicroseconds(100);
    ads.setDataRate(RATE_ADS1115_860SPS);     			// Sæt sample rate til 860 samples per sekund
    
    Serial.println("ADS1115 ADC initialiseret (PGA=2x, 860 SPS)"); 		// Bekræft initialisering på seriel port
}

// ============================================================================================================================
/**
 * @brief Initialiserer 16x2 LCD-display via I2C
 * 
 * @details Konfigurerer LCD-displayet med korrekt backlight og cursor.
 * Bruger Adafruit LCD-bibliotek med I2C backpack.
 * 
 * @note Opfylder H.MCU.001 kravet om display
 * 
 * @return void
 */
// ============================================================================================================================
void hal_lcd_init(void) {
    // Initialiser LCD
    lcd.init();                              			// Initialiser LCD-displayet via I2C
    lcd.backlight();                         			// Tænd LCD baggrundsbelysning
    lcd.clear();                             			// Ryd alt indhold på displayet
    
    // Vis startbesked
    lcd.setCursor(0, 0);                     			// Sæt cursor til starten af første linje (kolonne 0, række 0)
    lcd.print("ESR-Meter v");                			// Skriv "ESR-Meter v" på displayet
    lcd.print(FIRMWARE_VERSION);             			// Tilføj firmware version til display-teksten
    
    Serial.println("16x2 LCD display initialiseret"); 		// Bekræft initialisering på seriel port
}

// ============================================================================================================================
/**
 * @brief Initialiserer knapper med interne pull-up modstande
 * 
 * @details Konfigurerer knappins som inputs med interne pull-up.
 * ESP32 har interne pull-up modstande der kan aktiveres.
 * 
 * @note Opfylder H.MCU.001 kravet om knapper
 * 
 * @return void
 */
// ============================================================================================================================
void hal_buttons_init(void) {
    // Konfigurer knappins som inputs med interne pull-up
    pinMode(BUTTON1_PIN, INPUT_PULLUP);      			// Konfigurer BUTTON1_PIN som input med intern pull-up modstand
    pinMode(BUTTON2_PIN, INPUT_PULLUP);      			// Konfigurer BUTTON2_PIN som input med intern pull-up modstand
    
    // Initialiser knaptidspunkter
    button1LastPress = 0;                    			// Nulstil tæller for sidste knap1 tryk
    button2LastPress = 0;                    			// Nulstil tæller for sidste knap2 tryk
    button1Pressed = false;                  			// Initialiser knap1 status til "ikke trykket"
    button2Pressed = false;                  			// Initialiser knap2 status til "ikke trykket"
    
    Serial.println("Knapper initialiseret (interne pull-up)"); 	// Bekræft initialisering på seriel port
}

// ============================================================================================================================
/**
 * @brief Læser systemets strømforbrug (estimeret)
 * 
 * @return float Estimeret strømforbrug i mA
 */
// ============================================================================================================================
float hal_read_power_consumption(void) {
    // Dette er en estimation baseret på typiske værdier
    // I et rigtigt system ville man måle dette med en strømmonitor IC
    
    float estimated_current = 0.0;           			// Initialiser estimeret strømforbrug til 0 mA
    
    // ESP32: ~100 mA under normal drift
    estimated_current += 100.0;              			// Tilføj 100 mA for ESP32 mikrokontroller
    
    // AD9850: ~150 mA ved 125 MH
    estimated_current += 150.0;              			// Tilføj 150 mA for DDS-generator
    
    // ADS1115: ~0.3 mA
    estimated_current += 0.3;                			// Tilføj 0,3 mA for ADC
    
    // Opamps (4 stk): ~2 mA hver
    estimated_current += 8.0;                			// Tilføj 8 mA for 4 operationsforstærkere (2 mA hver)
    
    // LCD: ~20 mA
    estimated_current += 20.0;               			// Tilføj 20 mA for LCD-display
    
    return estimated_current;                			// Returner det samlede estimerede strømforbrug i mA
}
/**
*  ============================================================================================================================
 * @defgroup ADC_PROCESSING ADC & Signal Processing Module
 * @brief Ansvarlig for alle ADC-målinger og signalbehandling
 * ============================================================================================================================
 * Indeholder:
 * - Single-shot ADC-målinger
 * - Oversampling og middling
 * - Automatisk PGA-range selection
 * - Kalibreringsrutiner (delvist implementeret)
 *
 * Dette modul er kritisk for målenøjagtighed og støjreduktion.
 */
// ============================================================================================================================
// ADC-MÅLINGSFUNKTIONER - IMPLEMENTERING
// ============================================================================================================================
// ============================================================================================================================
/**
 * @brief Læser en enkelt ADC-værdi med specificeret PGA
 * 
 * @param pga_index PGA-indeks (0=2x, 1=4x, 2=8x, 3=16x)
 * 
 * @details Konfigurerer ADS1115 til den ønskede PGA-forstærkning,
 * udfører en single-shot måling og returnerer resultatet.
 * 
 * @return int16_t ADC-værdi (-32768 til 32767)
 */
// ============================================================================================================================
int16_t adc_read_single(uint8_t pga_index) {
    // Sæt korrekt gain baseret på pga_index
    adsGain_t gain;
    switch (pga_index) {
        case PGA_2X_INDEX:  gain = GAIN_TWO; break;   				// ±2.048V
        case PGA_4X_INDEX:  gain = GAIN_FOUR; break;  				// ±1.024V
        case PGA_8X_INDEX:  gain = GAIN_EIGHT; break; 				// ±0.512V
        case PGA_16X_INDEX: gain = GAIN_SIXTEEN; break; 			// ±0.256V
        default:            gain = GAIN_TWO; break;    				// Default til 2x
    }
    
    ads.setGain(gain);
    
    // Kort delay for at lade gain-skriveren stabilisere
    delayMicroseconds(100);
    
    // Start single-shot måling på kanal A0
    int16_t adc_value = ads.readADC_SingleEnded(0);
    
    return adc_value;
}

// ============================================================================================================================
/**
 * @brief Læser ADC med 64× oversampling og middling
 * 
 * @param pga_index PGA-indeks (0=2x, 1=4x, 2=8x, 3=16x)
 * 
 * @details Udfører 64 enkeltmålinger med korrekt timing baseret på
 * sample rate (860 SPS) og beregner gennemsnittet.
 * 
 * @note Opfylder S.ADC.001.2 kravet om 64× oversampling
 * 
 * @return int32_t Middlet ADC-værdi
 */
// ======================================================================================================================================================================
int32_t adc_read_oversampled(uint8_t pga_index) {
    int64_t sum = 0;                                 							// Initialiser sum variabel til at akkumulere ADC-værdier
    uint32_t sample_interval = 1000000 / 860; // Mikrosekunder pr. sample ved 860 SPS (~1163 µs) 	// Beregn interval mellem samples (1.000.000 µs / 860 samples)
    
    for (int i = 0; i < OVERSAMPLING_FACTOR; i++) {  							// Loop 64 gange (OVERSAMPLING_FACTOR = 64)
        sum += adc_read_single(pga_index);           							// Læs en enkelt ADC-værdi og tilføj til sum
        
        // Vent til næste sample tidspunkt (undgå aliasing)
        // Brug non-blocking delay for at undgå watchdog timeout
        if (i < OVERSAMPLING_FACTOR - 1) {           							// Hvis ikke sidste iteration i loopet
            uint32_t start = micros();               							// Gem starttidspunkt i mikrosekunder
            while (micros() - start < sample_interval) { 						// Vent indtil sample_interval er gået
                wdg_reset(); // Reset watchdog under ventetid 						// Forhindrer watchdog timeout under ventetid
            }
        }
    }
    
    // Beregn gennemsnit og returner som 32-bit integer
    return (int32_t)(sum / OVERSAMPLING_FACTOR);     						// Beregn gennemsnit ved at dividere sum med 64 og cast til 32-bit
}
// ======================================================================================================================================================================
// ============================================================================================================================
/**
 * @brief Automatisk PGA-valg baseret på signalstyrke
 * 
 * @details Starter med PGA=2x og justerer op/ned baseret på hvor
 * tæt ADC-værdien er på fuld skala. Implementerer hysterese for
 * at undgå oscillerende skift.
 * 
 * @note Opfylder S.ADC.001.3 kravet om automatisk PGA-valg
 * 
 * @return uint8_t Optimalt PGA-indeks (0-3)
 */
// ============================================================================================================================
uint8_t adc_auto_range(void) {
    static uint8_t last_pga = PGA_2X_INDEX;          	// Statisk variabel der gemmer sidste PGA-indeks (bevares mellem kald)
    static uint8_t hysteresis_counter = 0;           	// Statisk tæller for hysterese (bevares mellem kald)
    const uint8_t HYSTERESIS_THRESHOLD = 3;          	// Konstant: antal konsekutive målinger før PGA-skift
    
    // Læs ADC-værdi med nuværende PGA
    int16_t adc_value = adc_read_single(last_pga);   	// Læs ADC-værdi med aktuelt PGA-indeks
    int16_t adc_abs = abs(adc_value);                	// Beregn absolutværdi af ADC-værdien
    
    // Bestem om vi skal ændre PGA
    uint8_t new_pga = last_pga;                      	// Start med at antage ingen ændring
    
    if (adc_abs < PGA_THRESHOLD_LOW && last_pga < PGA_16X_INDEX) { // Hvis signal for lavt OG ikke allerede på max forstærkning
        // Signal for lavt - øg forstærkning
        hysteresis_counter++;                        		   // Øg hysterese-tæller
        if (hysteresis_counter >= HYSTERESIS_THRESHOLD) { 	   // Hvis tæller når tærskelværdi
            new_pga = last_pga + 1;                  		   // Øg PGA-indeks (øger forstærkningen)
            hysteresis_counter = 0;                  		   // Nulstil hysterese-tæller
            Serial.print("Øger PGA fra ");           		   // Log ændring til seriel port
            Serial.print(last_pga);                  		   // Vis gammelt PGA-niveau
            Serial.print(" til ");                   		   // 
            Serial.println(new_pga);                 		   // Vis nyt PGA-niveau
        }
    } 
    else if (adc_abs > PGA_THRESHOLD_HIGH && last_pga > PGA_2X_INDEX) { // Hvis signal for højt OG ikke allerede på min forstærkning
        // Signal for højt - reducer forstærkning
        hysteresis_counter++;                        			// Øg hysterese-tæller
        if (hysteresis_counter >= HYSTERESIS_THRESHOLD) { 		// Hvis tæller når tærskelværdi
            new_pga = last_pga - 1;                  			// Reducer PGA-indeks (reducerer forstærkningen)
            hysteresis_counter = 0;                  			// Nulstil hysterese-tæller
            Serial.print("Reducer PGA fra ");        			// Log ændring til seriel port
            Serial.print(last_pga);                  			// Vis gammelt PGA-niveau
            Serial.print(" til ");                   			//
            Serial.println(new_pga);                 			// Vis nyt PGA-niveau
        }
    } 
    else {
        // Signal i optimalt område - nulstil hysterese
        hysteresis_counter = 0;                      			// Nulstil hysterese-tæller når signal er i optimalt område
    }
    
    // Opdater PGA hvis nødvendigt
    if (new_pga != last_pga) {                      			// Hvis PGA-indeks er ændret
        last_pga = new_pga;                         			// Opdater gemt PGA-indeks
        
        // Kort delay for at lade ADC stabilisere (uden at blokere for watchdog)
        for (int i = 0; i < 10; i++) {              			// Loop 10 gange (samlet 10ms delay)
            wdg_reset();                            			// Reset watchdog timer
            delay(1);                               			// Vent 1 ms
        }
    }
    
    return last_pga;                                			// Returner aktuelt PGA-indeks
}

// ============================================================================================================================
/**
 * @brief Kalibreringsrutine for ADC-systemet
 * 
 * @details Denne funktion udfører kalibrering af ADC-systemet.
 * Kræver fysisk tilkobling af kendte referencemodstande.
 * Resultater gemmes i PROGMEM tabeller og kræver genprogrammering.
 * 
 * @note Opfylder S.ADC.001.4 kravet om kalibrering
 * @warning Kræver genprogrammering for at gemme kalibreringsdata
 * 
 * @return void
 */
// ============================================================================================================================
void adc_calibrate(void) {
    Serial.println("=== ADC KALIBRERING START ==="); 			// Skilletekst for kalibreringsstart på seriel port
    Serial.println("Dette kræver genprogrammering for at gemme data!"); // Advarsel om genprogrammering
    Serial.println("Tilslut kendte referencemodstande (0-10 ohm)"); 	// Instruktion til brugeren
    Serial.println("Følg instruktioner på display..."); 		// Instruktion om at følge display
    
    // Vis kalibreringsbesked på LCD
    lcd.clear();                                     			// Ryd LCD display
    lcd.setCursor(0, 0);                             			// Sæt cursor til starten af første linje
    lcd.print("KALIBRERING");                        			// Vis "KALIBRERING" på display
    lcd.setCursor(0, 1);                             			// Sæt cursor til starten af anden linje
    lcd.print("Vent...");                            			// Vis "Vent..." på display
    
    // Her ville man normalt implementere detaljeret kalibreringsrutine
    // med brugerinteraktion og gemning af data til EEPROM
    
    // Pseudo-kalibrering - i virkeligheden skal denne rutine:
    // 1. Guide brugeren gennem kalibreringspunkter
    // 2. Måle ADC-værdier for hver kendt modstand
    // 3. Gemme data i struktureret format
    // 4. Genberegne interpolationstabeller
    
    for (int i = 0; i < 20; i++) {                   			// Loop 20 gange (samlet 2 sekunders ventetid)
        wdg_reset();                                 			// Reset watchdog timer
        delay(100);                                  			// Vent 100 ms
    }
    
    Serial.println("=== ADC KALIBRERING SLUT ===");  			// Skilletekst for kalibreringsslut på seriel port
    Serial.println("Note: Kalibreringsdata skal gemmes via genprogrammering"); 	// Påmindelse om genprogrammering
    
    // Gå tilbage til normal visning
    lcd.clear();                                     			// Ryd LCD display
    lcd.setCursor(0, 0);                             			// Sæt cursor til starten af første linje
    lcd.print("Kalibrering");                        			// Vis "Kalibrering" på display
    lcd.setCursor(0, 1);                             			// Sæt cursor til starten af anden linje
    lcd.print("færdig - genprog!");                  			// Vis "færdig - genprog!" på display
    
    for (int i = 0; i < 10; i++) {                   			// Loop 10 gange (samlet 2 sekunders ventetid)
        wdg_reset();                                 			// Reset watchdog timer
        delay(200);                                  			// Vent 200 ms
    }
}
/**
* ============================================================================================================================
 * @defgroup UTILITIES Utility Functions
 * @brief Generelle hjælpefunktioner
 * ============================================================================================================================
 * Indeholder tids-, matematik- og hjælpefunktioner
 * som anvendes på tværs af moduler.
 */

// ============================================================================================================================
// Hjælpefunktioner
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Sikker mikro-sekund tæller
 * 
 * @return uint32_t Aktuelle tid i mikro-sekunder
 */
// ============================================================================================================================
uint32_t micros_safe(void) {
    return micros();                        				// Returnerer aktuelt systemtidspunkt i mikrosekunder
}

// ============================================================================================================================
/**
 * @brief Sikker mikro-sekund delay
 * 
 * @param microseconds Antal mikro-sekunder at vente
 */
// ============================================================================================================================
void delay_micros_safe(uint32_t microseconds) {
    if (microseconds < 1000) {              				// Hvis ventetid er mindre end 1000 µs (1 ms)
        delayMicroseconds(microseconds);    				// Brug standard delayMicroseconds funktion
    } else {                                				// Hvis ventetid er 1000 µs eller mere
        uint32_t ms = microseconds / 1000;  				// Beregn antal hele millisekunder
        uint32_t us = microseconds % 1000;  				// Beregn resterende mikrosekunder
        delay(ms);                          				// Vent antal millisekunder med delay()
        delayMicroseconds(us);              				// Vent resterende mikrosekunder
    }
}

// ============================================================================================================================
/**
 * @brief Float version af map()-funktionen
 * 
 * @param x Input værdi
 * @param in_min Minimum input
 * @param in_max Maksimum input
 * @param out_min Minimum output
 * @param out_max Maksimum output
 * 
 * @return float Mappet værdi
 */
// ============================================================================================================================
float map_float(float x, float in_min, float in_max, float out_min, float out_max) {
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; // Lineær mapping af x fra input- til outputområde
}

/**
*  ============================================================================================================================
 * @defgroup ESR_CALCULATION ESR Calculation Module
 * @brief Konverterer ADC-målinger til ESR-værdier
 * ============================================================================================================================
 * ESR-beregningen er tabelbaseret og afhænger af:
 * - Aktiv PGA-indstilling
 * - Kalibreringsdata
 *
 * Funktionen anvender lineær interpolation mellem
 * kalibrerede datapunkter.
 *
 * Bemærk:
 * Nuværende tabeller er pladsholdere og skal erstattes
 * af reelle kalibreringsdata.
 */
// ============================================================================================================================
// ESR-BEREGNINGSFUNKTIONER - IMPLEMENTERING
// ============================================================================================================================
// ============================================================================================================================
/**
 * @brief Finder de nærmeste tabelværdier over og under den aktuelle ADC-værdi
 * 
 * @param pga_index PGA-indeks (0=2x, 1=4x, 2=8x, 3=16x)
 * @param adc_value Aktuel ADC-værdi (efter oversampling)
 * @param adc_low Pointer til nærmeste ADC-værdi under
 * @param esr_low Pointer til ESR-værdi svarende til adc_low
 * @param adc_high Pointer til nærmeste ADC-værdi over
 * @param esr_high Pointer til ESR-værdi svarende til adc_high
 * 
 * @details Bruger binært søgning til at finde de to nærmeste indgange i 
 * ESR-tabellen for den aktuelle PGA-indstilling. Håndterer edge cases 
 * hvor ADC-værdien er uden for tabelområdet.
 * 
 * @note Opfylder S.ESR.001.2 kravet om tabelopslag
 * 
 * @return void
 */
// ============================================================================================================================
void esr_find_nearest_values(uint8_t pga_index, int32_t adc_value, 
                            int16_t *adc_low, float *esr_low, 
                            int16_t *adc_high, float *esr_high) {
    // Håndter edge cases først
    TableEntry entry;                       				// Midlertidig variabel til at læse tabelindgange
    
    // Læs første indgang i tabellen (laveste ADC-værdi)
    memcpy_P(&entry, &esrTables[pga_index][0], sizeof(TableEntry)); 	// Kopier første tabelindgang fra PROGMEM til RAM
    if (adc_value <= entry.adcValue) {      				// Hvis ADC-værdi er mindre end eller lig med første indgang
        // ADC-værdi er mindre end eller lig med første indgang
        *adc_low = entry.adcValue;          				// Gem den laveste ADC-værdi (første indgang)
        *esr_low = entry.esrValue;          				// Gem ESR-værdien for den laveste ADC-værdi
        // Brug samme værdi for high (ingen interpolation)
        *adc_high = entry.adcValue;         				// Brug samme ADC-værdi for høj (ingen interpolation)
        *esr_high = entry.esrValue;         				// Brug samme ESR-værdi for høj
        return;                             				// Afslut funktionen tidligt
    }
    
    // Læs sidste indgang i tabellen (højeste ADC-værdi)
    memcpy_P(&entry, &esrTables[pga_index][TABLE_ENTRIES - 1], sizeof(TableEntry)); 	// Kopier sidste tabelindgang fra PROGMEM
    if (adc_value >= entry.adcValue) {      				// Hvis ADC-værdi er større end eller lig med sidste indgang
        // ADC-værdi er større end eller lig med sidste indgang
        *adc_low = entry.adcValue;          				// Gem den højeste ADC-værdi (sidste indgang)
        *esr_low = entry.esrValue;          				// Gem ESR-værdien for den højeste ADC-værdi
        *adc_high = entry.adcValue;         				// Brug samme ADC-værdi for høj
        *esr_high = entry.esrValue;         				// Brug samme ESR-værdi for høj
        return;                             				// Afslut funktionen tidligt
    }
    
    // Binært søgning for at finde interval
    int low = 0;                            				// Startindeks for søgning
    int high = TABLE_ENTRIES - 1;           				// Slutindeks for søgning
    int mid = 0;                            				// Midterindeks
    
    while (low <= high) {                   				// Fortsæt indtil søgeområdet er udtømt
        mid = low + (high - low) / 2;       				// Beregn midterindeks (undgår overflow)
        
        // Læs midterindgang fra PROGMEM
        memcpy_P(&entry, &esrTables[pga_index][mid], sizeof(TableEntry)); // Kopier midterindgang fra PROGMEM
        if (entry.adcValue == adc_value) {  				// Hvis præcis match fundet
            // Præcis match - brug samme værdi for begge
            *adc_low = entry.adcValue;      				// Gem ADC-værdien som både lav og høj
            *esr_low = entry.esrValue;      				// Gem ESR-værdien som både lav og høj
            *adc_high = entry.adcValue;     				// Samme ADC-værdi for høj
            *esr_high = entry.esrValue;     				// Samme ESR-værdi for høj
            return;                         				// Afslut funktionen
        } else if (entry.adcValue < adc_value) { 			// Hvis midtens ADC-værdi er mindre end søgte værdi
            // Tjek om næste indgang er over adc_value
            if (mid + 1 < TABLE_ENTRIES) {  				// Hvis der er en næste indgang i tabellen
                TableEntry next_entry;      				// Variabel til næste tabelindgang
                memcpy_P(&next_entry, &esrTables[pga_index][mid + 1], sizeof(TableEntry)); // Kopier næste indgang
                if (next_entry.adcValue >= adc_value) { 		// Hvis næste indgangs ADC-værdi er større eller lig
                    // Vi har fundet intervallet
                    *adc_low = entry.adcValue;      			// Gem den nederste ADC-værdi i intervallet
                    *esr_low = entry.esrValue;      			// Gem ESR-værdien for den nederste ADC-værdi
                    *adc_high = next_entry.adcValue;			// Gem den øverste ADC-værdi i intervallet
                    *esr_high = next_entry.esrValue;			// Gem ESR-værdien for den øverste ADC-værdi
                    return;                         			// Afslut funktionen
                } else {                    				// Hvis næste indgang også er mindre end søgte værdi
                    low = mid + 1;          				// Søg i højre halvdel (opdater søgeområde)
                }
            } else {                        				// Hvis mid er sidste element i tabellen (edge case)
                // Edge case: mid er sidste element
                *adc_low = entry.adcValue;  				// Brug sidste indgang som både lav og høj
                *esr_low = entry.esrValue;  				// Brug ESR-værdien for sidste indgang
                *adc_high = entry.adcValue; 				// Samme ADC-værdi for høj
                *esr_high = entry.esrValue; 				// Samme ESR-værdi for høj
                return;                     				// Afslut funktionen
            }
        } else {                            				// Hvis midtens ADC-værdi er større end søgte værdi
            // entry.adcValue > adc_value
            high = mid - 1;                 				// Søg i venstre halvdel (opdater søgeområde)
        }
    }
    
    // Fallback: brug første og anden indgang (hvis noget gik galt under søgningen)
    memcpy_P(&entry, &esrTables[pga_index][0], sizeof(TableEntry)); 			// Kopier første tabelindgang
    *adc_low = entry.adcValue;              						// Brug første indgang som lav
    *esr_low = entry.esrValue;              						// Brug første indgangs ESR
    
    memcpy_P(&entry, &esrTables[pga_index][1], sizeof(TableEntry)); 			// Kopier anden tabelindgang
    *adc_high = entry.adcValue;             						// Brug anden indgang som høj
    *esr_high = entry.esrValue;             						// Brug anden indgangs ESR
}
// ============================================================================================================================
/**
 * @brief Beregner lineær interpolation mellem to tabelpunkter
 * 
 * @param adc_low ADC-værdi for nederste tabelindgang
 * @param esr_low ESR-værdi for nederste tabelindgang
 * @param adc_high ADC-værdi for øverste tabelindgang
 * @param esr_high ESR-værdi for øverste tabelindgang
 * @param adc_current Aktuel ADC-værdi
 * 
 * @details Beregner ESR ved lineær interpolation:
 * esr = esr_low + (adc_current - adc_low) × (esr_high - esr_low) / (adc_high - adc_low)
 * 
 * @note Opfylder S.ESR.001.3 kravet om lineær interpolation
 * 
 * @return float Interpoleret ESR-værdi i ohm
 */
// ============================================================================================================================
float esr_linear_interpolate(int16_t adc_low, float esr_low, 
                           int16_t adc_high, float esr_high, 
                           int32_t adc_current) {
    // Håndter division med nul (hvis adc_low == adc_high)
    if (adc_high == adc_low) {              			// Hvis høj og lav ADC-værdi er ens (ingen interpolation mulig)
        return esr_low;                     			// Returner den laveste ESR-værdi
    }
    
    // Lineær interpolation
    float fraction = (float)(adc_current - adc_low) / (float)(adc_high - adc_low); 	// Beregn brøkdel af intervallet
    return esr_low + fraction * (esr_high - esr_low); 					// Beregn interpoleret ESR-værdi
}

// ============================================================================================================================
/**
 * @brief Hovedfunktion for ESR-beregning
 * 
 * @param pga_index PGA-indeks (0=2x, 1=4x, 2=8x, 3=16x)
 * @param adc_value ADC-værdi (efter oversampling)
 * 
 * @details Koordinerer hele ESR-beregningsprocessen:
 * 1. Finder nærmeste tabelværdier
 * 2. Udfører lineær interpolation
 * 3. Returnerer beregnet ESR-værdi
 * 
 * @note Opfylder S.ESR.001.4 kravet om ESR-beregningsfunktion
 * 
 * @return float Beregnet ESR-værdi i ohm
 */
// ============================================================================================================================
float esr_calculate(uint8_t pga_index, int32_t adc_value) {
    // Variabler til nærmeste tabelværdier
    int16_t adc_low = 0, adc_high = 0;      				// Initialiser variabler til grænseværdier for ADC
    float esr_low = 0.0, esr_high = 0.0;    				// Initialiser variabler til grænseværdier for ESR
    
    // Find nærmeste tabelværdier
    esr_find_nearest_values(pga_index, adc_value, 			// Kald funktion til at finde interval i kalibreringstabel
                           &adc_low, &esr_low,    			// Output: laveste grænseværdier
                           &adc_high, &esr_high); 			// Output: højeste grænseværdier
    
    // Udfør lineær interpolation
    float esr_value = esr_linear_interpolate(adc_low, esr_low, 		// Beregn interpoleret ESR-værdi
                                           adc_high, esr_high, 
                                           adc_value);
    
    // Begræns ESR-værdi til 0-10 ohm område
    if (esr_value < 0.0) {                  				// Hvis beregnet ESR er mindre end 0 ohm
        esr_value = 0.0;                    				// Sæt ESR til 0 ohm (undgår negative værdier)
    } else if (esr_value > 10.0) {          				// Hvis beregnet ESR er større end 10 ohm
        esr_value = 10.0;                   				// Sæt ESR til 10 ohm (maksimalt område)
    }
    
    return esr_value;                       				// Returner den beregnede (og begrænsede) ESR-værdi
}
/**
* ============================================================================================================================
 * @defgroup UI_DISPLAY User Interface (Display)
 * @brief Håndterer visning af data på LCD
 * ============================================================================================================================
 * Dette modul styrer:
 * - Visning af ESR-resultater
 * - Visning af rå ADC-data
 * - Systemstatus og fejlmeddelelser
 *
 * UI-logik er bevidst holdt simpel og afhænger
 * af state machine.
 */
// ============================================================================================================================
// DISPLAY FUNKTIONER - IMPLEMENTERING
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Initialiserer display systemet
 * 
 * @details Klarer LCD-displayet og viser startbesked.
 * 
 * @note Opfylder S.DSP.001.2 kravet om display-initialisering
 * 
 * @return void
 */
// ============================================================================================================================
void display_init(void) {
    // Display er allerede initialiseret i hal_lcd_init()
    // Her kan vi tilføje yderligere display-specifik konfiguration
    
    lcd.clear();                            		// Ryd alt indhold på LCD-displayet
    lcd.setCursor(0, 0);                    		// Sæt cursor til starten af første linje (kolonne 0, række 0)
    lcd.print("ESR-Meter");                 		// Skriv "ESR-Meter" på displayets første linje
    lcd.setCursor(0, 1);                    		// Sæt cursor til starten af anden linje (kolonne 0, række 1)
    lcd.print("Initialiseret");             		// Skriv "Initialiseret" på displayets anden linje
}
// ============================================================================================================================
/**
 * @brief Viser rå ADC-værdi på display (til kalibrering)
 * 
 * @param adc_value ADC-værdi at vise
 * @param pga_index PGA-indeks for visning
 * 
 * @details Formaterer og viser rå ADC-data på displayet.
 * Bruges primært til kalibrering og debugging.
 * 
 * @note Opfylder S.DSP.001.3 kravet om rå ADC-visning
 * 
 * @return void
 */
// ============================================================================================================================
void display_raw_adc(int32_t adc_value, uint8_t pga_index) {
    lcd.clear();                            					// Ryd alt indhold på LCD-displayet
    
    // Linje 1: ADC-værdi
    lcd.setCursor(0, 0);                    				// Sæt cursor til starten af første linje
    lcd.print("ADC: ");                     				// Skriv "ADC: " på displayet
    lcd.print(adc_value);                   				// Udskriv ADC-værdien
    lcd.print("   "); 						//  Tilføj mellemrum for at overskrive eventuelle resterende tegn
    
    // Linje 2: PGA og procent af fuld skala
    lcd.setCursor(0, 1);                    				// Sæt cursor til starten af anden linje
    lcd.print("PGA: ");                     				// Skriv "PGA: " på displayet
    
    switch (pga_index) {                    				// Vælg PGA-indstilling baseret på pga_index
        case PGA_2X_INDEX:  lcd.print("2x"); break;  		// Hvis pga_index = 0, skriv "2x"
        case PGA_4X_INDEX:  lcd.print("4x"); break;  		// Hvis pga_index = 1, skriv "4x"
        case PGA_8X_INDEX:  lcd.print("8x"); break;  		// Hvis pga_index = 2, skriv "8x"
        case PGA_16X_INDEX: lcd.print("16x"); break; 		// Hvis pga_index = 3, skriv "16x"
        default:           lcd.print("?"); break;    			// Hvis ugyldig værdi, skriv "?"
    }
    
    // Beregn og vis procent af fuld skala
    float percent = (float)abs(adc_value) / 32767.0 * 100.0; // Beregn procentdel af fuld skala (32767 = 2^15-1)
    lcd.print(" (");                         				// Skriv " (" på displayet
    lcd.print(percent, 1);                   				// Udskriv procentværdi med 1 decimal
    lcd.print("%)");                         				// Skriv "%)" på displayet
}

// ============================================================================================================================
/**
 * @brief Viser beregnet ESR-resultat på display
 * 
 * @param esr_value Beregnet ESR-værdi i ohm
 * @param adc_value ADC-værdi brugt til beregning
 * @param pga_index PGA-indeks brugt til måling
 * 
 * @details Formaterer og viser ESR-resultatet med høj opløsning (mΩ).
 * Inkluderer også ADC-værdi og PGA-indstilling for reference.
 * 
 * @note Opfylder S.DSP.001.4 kravet om ESR-resultat-visning
 * 
 * @return void
 */
// ============================================================================================================================
void display_esr_result(float esr_value, int32_t adc_value, uint8_t pga_index) {
    lcd.clear();                            			// Ryd alt indhold på LCD-displayet
    
    // Linje 1: ESR-værdi med høj opløsning (mΩ)
    lcd.setCursor(0, 0);                    			// Sæt cursor til starten af første linje
    lcd.print("ESR: ");                     			// Skriv "ESR: " på displayet
    
    if (esr_value < 0.001) {                			// Hvis ESR-værdi er mindre end 0.001 ohm (under 1 mΩ)
        // Under 1 mΩ - vis med nano-ohm opløsning
        lcd.print(esr_value * 1000000.0, 3); 				// Konverter til nΩ og udskriv med 3 decimaler
        lcd.print(" nΩ");                    				// Skriv enheden "nΩ"
    } else if (esr_value < 1.0) {           			// Hvis ESR-værdi er mindre end 1 ohm (under 1 Ω)
        // Under 1 Ω - vis med mΩ opløsning
        lcd.print(esr_value * 1000.0, 3);    				// Konverter til mΩ og udskriv med 3 decimaler
        lcd.print(" mΩ");                    				// Skriv enheden "mΩ"
    } else {                                			// Hvis ESR-værdi er 1 ohm eller derover
        // Over 1 Ω - vis med Ω opløsning
        lcd.print(esr_value, 3);             				// Udskriv ESR-værdi med 3 decimaler
        lcd.print(" Ω");                     				// Skriv enheden "Ω"
    }
    
    // Juster spacing
    if (esr_value < 10.0) {                			// Hvis ESR-værdi er mindre end 10 ohm
        lcd.print("   "); 						//  Tilføj mellemrum for bedre formattering
    }
    
    // Linje 2: ADC og PGA info
    lcd.setCursor(0, 1);                    				// Sæt cursor til starten af anden linje
    lcd.print("ADC:");                      				// Skriv "ADC:" på displayet
    lcd.print(adc_value);                   				// Udskriv ADC-værdien
    lcd.print(" PGA:");                     				// Skriv " PGA:" på displayet
    
    switch (pga_index) {                    			// Vælg PGA-indstilling baseret på pga_index
        case PGA_2X_INDEX:  lcd.print("2x"); break;  			// Hvis pga_index = 0, skriv "2x"
        case PGA_4X_INDEX:  lcd.print("4x"); break;  			// Hvis pga_index = 1, skriv "4x"
        case PGA_8X_INDEX:  lcd.print("8x"); break;  			// Hvis pga_index = 2, skriv "8x"
        case PGA_16X_INDEX: lcd.print("16x"); break; 			// Hvis pga_index = 3, skriv "16x"
        default:           lcd.print("?"); break;   			// Hvis ugyldig værdi, skriv "?"
    }
}
// ============================================================================================================================
/**
 * @brief Opdaterer displayet baseret på nuværende tilstand
 * 
 * @details Opdaterer displayet baseret på displayMode og tilgængelige data.
 * Kalder enten display_raw_adc() eller display_esr_result().
 * 
 * @note Opfylder S.DSP.001.5 kravet om display-opdatering
 * 
 * @return void
 */
// ============================================================================================================================
void display_update(void) {
    // Opdater kun hvis der er nye data
    if (newMeasurementAvailable) {          					// Tjek om der er en ny måling klar til visning
        if (displayMode == DISPLAY_MODE_RAW_ADC) { 				// Hvis displaytilstand er rå ADC
            display_raw_adc(rawAdcValue, currentPgaSetting); 			// Vis rå ADC-værdi
        } else if (displayMode == DISPLAY_MODE_ESR_RESULT) { 			// Hvis displaytilstand er ESR-resultat
            display_esr_result(calculatedEsr, rawAdcValue, currentPgaSetting); 	// Vis beregnet ESR
        }
        newMeasurementAvailable = false;    					// Markér målingen som vist (nulstil flag)
    }
}

// ============================================================================================================================
/**
 * @brief Viser fejlbesked på display
 * 
 * @param error_msg Fejlbesked at vise
 * 
 * @details Viser fejlbesked på begge linjer af displayet.
 * Bruges til systemfejl og kalibreringsfejl.
 * 
 * @return void
 */
// ============================================================================================================================
void display_error(const char *error_msg) {
    lcd.clear();                            					// Ryd alt indhold på LCD-displayet
    
    // Del fejlbeskeden i to linjer hvis den er for lang
    char line1[17] = {0};                   					// Buffer til første linje (16 tegn + null)
    char line2[17] = {0};                   					// Buffer til anden linje (16 tegn + null)
    
    // Kopier første 16 tegn til linje 1
    strncpy(line1, error_msg, 16);          					// Kopier op til 16 tegn af fejlbeskeden til line1
    line1[16] = '\0';                       					// Sikre null-terminering
    
    // Hvis beskeden er længere end 16 tegn, kopier resten til linje 2
    if (strlen(error_msg) > 16) {           					// Hvis fejlbeskeden er længere end 16 tegn
        strncpy(line2, error_msg + 16, 16); 					// Kopier de næste 16 tegn til line2
        line2[16] = '\0';                   					// Sikre null-terminering
    }
    
    // Vis fejlbesked
    lcd.setCursor(0, 0);                    					// Sæt cursor til starten af første linje
    lcd.print(line1);                       					// Udskriv første del af fejlbeskeden
    
    lcd.setCursor(0, 1);                    					// Sæt cursor til starten af anden linje
    if (line2[0] != '\0') {                 					// Hvis der er en anden linje med tekst
        lcd.print(line2);                   					// Udskriv anden del af fejlbeskeden
    } else {                                					// Hvis fejlbeskeden var kort (kun én linje)
        lcd.print("FEJL!");                 					// Udskriv standard "FEJL!" på anden linje
    }
}
// ============================================================================================================================
/**
 * @brief Viser systeminformation på seriel port
 */
// ============================================================================================================================
void display_system_info(void) {
    Serial.println("=== SYSTEM INFORMATION ===");            	// Udskriv systeminformation overskrift til seriel monitor
    Serial.print("Firmware Version: ");                     	// Udskriv tekst "Firmware Version: "
    Serial.println(FIRMWARE_VERSION);                       	// Udskriv firmware version konstant
    Serial.print("Hardware Version: ");                     	// Udskriv tekst "Hardware Version: "
    Serial.println(HARDWARE_VERSION);                       	// Udskriv hardware version konstant
    
    Serial.print("ESP32 Chip ID: ");                        	// Udskriv tekst "ESP32 Chip ID: "
    Serial.println(ESP.getEfuseMac(), HEX);                 	// Udskriv ESP32 chip ID i hexadecimalt format
    
    Serial.print("Free Heap: ");                            	// Udskriv tekst "Free Heap: "
    Serial.print(ESP.getFreeHeap());                        	// Udskriv tilgængelig RAM (heap) størrelse
    Serial.println(" bytes");                               	// Udskriv enheden "bytes"
    
    Serial.print("CPU Frequency: ");                        	// Udskriv tekst "CPU Frequency: "
    Serial.print(ESP.getCpuFreqMHz());                      	// Udskriv CPU frekvens i MHz
    Serial.println(" MHz");                                 	// Udskriv enheden "MHz"
    
    Serial.print("Flash Size: ");                           	// Udskriv tekst "Flash Size: "
    Serial.print(ESP.getFlashChipSize() / (1024 * 1024));   	// Beregn og udskriv flash størrelse i MB
    Serial.println(" MB");                                  	// Udskriv enheden "MB"
    
    Serial.println("=== MODULSTATUS ===");                  	// Udskrift af modulstatus overskrift
    Serial.println("AD9850: Initialiseret");                	// Status for DDS-generator
    Serial.println("ADS1115: Initialiseret");               	// Status for ADC
    Serial.println("LCD: Initialiseret");                   	// Status for LCD display
    Serial.println("I2C: 400 kHz");                         	// Status for I2C bus hastighed
    Serial.println("Watchdog: Aktiv");                      	// Status for watchdog timer
    
    Serial.println("=== KRAVSPECIFIKATION ===");            	// Udskrift af kravspecifikationsoverskrift
    Serial.println("ESR Range: 0-10 ohm");                  	// Specifikation: ESR måleområde
    Serial.println("Resolution: 1 mΩ");                     	// Specifikation: opløsning
    Serial.println("Precision: ≤5%");                       	// Specifikation: præcision
    Serial.println("Test Frequency: 100 kHz");              	// Specifikation: testfrekvens
    Serial.println("Test Signal: ≤0.1V p-p");               	// Specifikation: testsignal amplitude
    Serial.println("==========================");           	// Afsluttende skillelinje
}
/**
* ============================================================================================================================
 * @defgroup STATE_MACHINE System State Machine
 * @brief Styrer hele systemets operationelle flow
 * ============================================================================================================================
 * State machine-modulet:
 * - Koordinerer målinger, beregninger, display og kommunikation
 * - Sikrer deterministisk systemadfærd
 * - Muliggør fejlhåndtering via ERROR-state
 *
 * Alle systemændringer bør ske gennem state transitions.
 */
// ============================================================================================================================
// STATE MACHINE FUNKTIONER - IMPLEMENTERING
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Initialiserer state machine systemet
 * 
 * @details Sætter starttilstande og initialiserer timing-variabler.
 * 
 * @return void
 */
// ============================================================================================================================
void state_machine_init(void) {
    currentState = STATE_IDLE;                              		// Sæt starttilstand til IDLE
    lastMeasurementTime = millis();                         		// Initialiser målingstidspunkt med nuværende tid
    lastDisplayUpdateTime = millis();                       		// Initialiser display opdateringstidspunkt
    
    Serial.println("State machine initialiseret");          		// Bekræft state machine initialisering
}

// ============================================================================================================================
/**
 * @brief Hovedopdateringsfunktion for state machine
 * 
 * @details Kalder den korrekte state handler baseret på currentState.
 * Håndterer også timing-baserede transitions.
 * 
 * @return void
 */
// ============================================================================================================================
void state_machine_update(void) {
    // Kald state handler baseret på nuværende state
    switch (currentState) {                                 			// Vælg funktion baseret på aktuelt state
        case STATE_IDLE:                                    			// Hvis state er IDLE
            state_idle_handler();                           				// Kør IDLE state handler
            break;
        case STATE_MEASURE_ADC:                             			// Hvis state er MEASURE_ADC
            state_measure_adc_handler();                    				// Kør ADC-målings handler
            break;
        case STATE_CALCULATE_ESR:                           			// Hvis state er CALCULATE_ESR
            state_calculate_esr_handler();                  				// Kør ESR-beregnings handler
            break;
        case STATE_UPDATE_DISPLAY:                          			// Hvis state er UPDATE_DISPLAY
            state_update_display_handler();                 				// Kør display-opdaterings handler
            break;
        case STATE_PROCESS_SERIAL:                         			// Hvis state er PROCESS_SERIAL
            state_process_serial_handler();                 				// Kør seriel kommunikations handler
            break;
        case STATE_ERROR:                                   			// Hvis state er ERROR
            state_error_handler();                          				// Kør fejlhåndterings handler
            break;
        default:                                            			// Hvis state er ukendt
            // Ukendt state - gå til error state
            currentState = STATE_ERROR;                     				// Sæt state til ERROR
            error_handler("Ukendt state", 0x10);            			// Kald fejlhåndtering med besked og kode
            break;
    }
}

// ============================================================================================================================
/**
 * @brief State handler for IDLE tilstand
 * 
 * @details IDLE state venter på at det er tid til næste måling
 * eller på brugerinput. Skifter til MEASURE_ADC ved timeout.
 * 
 * @return void
 */
// ============================================================================================================================
void state_idle_handler(void) {
    uint32_t currentTime = millis();                        		    // Hent nuværende systemtid i ms
    
    // Tjek om det er tid til næste måling
    if ((currentTime - lastMeasurementTime) >= MEASUREMENT_INTERVAL) { 	    // Hvis måleinterval er overskredet
        currentState = STATE_MEASURE_ADC;                   			// Skift til ADC-målingstilstand
        lastMeasurementTime = currentTime;                  			// Opdater sidste målingstidspunkt
    }
    
    // Tjek om display skal opdateres
    if ((currentTime - lastDisplayUpdateTime) >= DISPLAY_UPDATE_INTERVAL) { // Hvis display-opdateringsinterval er overskredet
        currentState = STATE_UPDATE_DISPLAY;                			// Skift til display-opdateringstilstand
        lastDisplayUpdateTime = currentTime;                		 	// Opdater sidste display opdateringstidspunkt
    }
}

// ============================================================================================================================
/**
 * @brief State handler for ADC-målingstilstand
 * 
 * @details Udfører automatisk PGA-valg og oversampled ADC-måling.
 * Skifter til CALCULATE_ESR efter måling.
 * 
 * @return void
 */
// ============================================================================================================================
void state_measure_adc_handler(void) {
    // Udfør automatisk PGA-valg
    currentPgaSetting = adc_auto_range();                   		// Find optimal PGA-indstilling baseret på signalstyrke
    
    // Udfør oversampled ADC-måling
    rawAdcValue = adc_read_oversampled(currentPgaSetting);  		// Læs ADC-værdi med 64× oversampling
    
    // Gå til næste state
    currentState = STATE_CALCULATE_ESR;                     		// Skift til ESR-beregningstilstand
}

// ============================================================================================================================
/**
 * @brief State handler for ESR-beregningstilstand
 * 
 * @details Beregner ESR-værdi baseret på ADC-måling og tabelopslag.
 * Skifter til UPDATE_DISPLAY efter beregning.
 * 
 * @return void
 */
// ============================================================================================================================
void state_calculate_esr_handler(void) {
    // Beregn ESR-værdi
    calculatedEsr = esr_calculate(currentPgaSetting, rawAdcValue); 	// Beregn ESR-værdi fra ADC-værdi
    
    // Sæt flag for ny måling
    newMeasurementAvailable = true;                         		// Markér at ny måling er klar til visning
    
    // Gå til næste state
    currentState = STATE_UPDATE_DISPLAY;                    		// Skift til display-opdateringstilstand
}

// ============================================================================================================================
/**
 * @brief State handler for display-opdateringstilstand
 * 
 * @details Opdaterer displayet baseret på nuværende display mode.
 * Returnerer til IDLE efter opdatering.
 * 
 * @return void
 */
// ============================================================================================================================
void state_update_display_handler(void) {
    // Opdater display
    display_update();                                       		// Opdater LCD-display med nuværende data
    
    // Returner til IDLE state
    currentState = STATE_IDLE;                              		// Skift tilbage til IDLE-tilstand
}

// ============================================================================================================================
/**
 * @brief State handler for seriel kommunikationstilstand
 * 
 * @details Håndterer SCPI-kommandoer og seriel kommunikation.
 * Returnerer til IDLE efter behandling.
 * 
 * @return void
 */
// ============================================================================================================================
void state_process_serial_handler(void) {
    // Håndter SCPI-kommandoer hvis nogen er klar
    if (scpiCommandReady) {                                 		// Tjek om en SCPI-kommando er klar til behandling
        scpi_parser();                                      			// Parse og udfør SCPI-kommandoen
        scpiCommandReady = false;                           			// Nulstil kommando-klar flag
    }
    
    // Returner til IDLE state
    currentState = STATE_IDLE;                              		// Skift tilbage til IDLE-tilstand
}

// ============================================================================================================================
/**
 * @brief State handler for fejltilstand
 * 
 * @details Viser fejlbesked på display og logger fejlen.
 * Forsøger at genstarte systemet efter timeout.
 * 
 * @return void
 */
// ============================================================================================================================
void state_error_handler(void) {
    static uint32_t errorStartTime = 0;                     		// Statisk variabel til at gemme fejlstarttid
    
    if (errorStartTime == 0) {                              		// Hvis fejltilstand lige er startet
        errorStartTime = millis();                          			// Gem starttidspunkt for fejlen
        display_error("Systemfejl - genstarter...");        			// Vis fejlbesked på display
        Serial.println("ERROR STATE: Systemfejl opstået");  			// Log fejl til seriel port
    }
    
    // Tjek om der er gået nok tid til at genstarte
    if ((millis() - errorStartTime) > 5000) {              		// Hvis 5 sekunder er gået siden fejlen started
        Serial.println("ERROR STATE: Genstarter system...");			// Log genstart til seriel port
        cleanup_before_restart();                           			// Kør oprydning før genstart
        ESP.restart(); 	                					// Genstart ESP32 mikrokontrolleren
    }
}
/**
* ============================================================================================================================
 * @defgroup INPUT_BUTTONS Button Handling Module
 * @brief Debounce og håndtering af brugerinput
 * ============================================================================================================================
 * Indeholder logik for:
 * - Debounce
 * - Mode-skift
 * - UI-interaktion
 *
 * Designet til at være ikke-blokerende.
 */

// ============================================================================================================================
// KNAP-HÅNDTERINGSFUNKTIONER - IMPLEMENTERING
// ============================================================================================================================
// ============================================================================================================================
/**
 * @brief Tjekker knaptryk med debounce
 * 
 * @details Læser knappins og implementerer debounce ved at sammenligne
 * med sidste tryk-tidspunkt. Kun én handling pr. knap pr. DEBOUNCE_DELAY.
 * 
 * @note Opfylder kravet om knaprespons ≤20 ms (S.PER.001.4)
 * 
 * @return void
 */
// ============================================================================================================================
void button_check(void) {
    uint32_t currentTime = millis();                         		// Hent nuværende systemtid i millisekunder
    
    // Tjek knap 1 (skift displaytilstand)
    if (digitalRead(BUTTON1_PIN) == LOW) { 				// LOW fordi aktiv lav med pull-up // Læs knap 1: lavt signal = trykket
        if (!button1Pressed && (currentTime - button1LastPress) > DEBOUNCE_DELAY) { // Hvis knap ikke allerede markeret trykket OG debounce-interval er overskredet
            button1Pressed = true;                           			// Marker knap 1 som trykket (forhindrer gentagne handlinger)
            button1LastPress = currentTime;                  			// Opdater tidspunkt for sidste tryk på knap 1
            button1_handler();                               			// Kald funktionen der håndterer knap 1 tryk
        }
    } else {                                                 		// Hvis knap 1 ikke er trykket (signal er højt)
        button1Pressed = false;                              			// Nulstil knap 1 tryk-status
    }
    
    // Tjek knap 2 (skift kommunikationstilstand)
    if (digitalRead(BUTTON2_PIN) == LOW) {                   		// Læs knap 2: lavt signal = trykket
        if (!button2Pressed && (currentTime - button2LastPress) > DEBOUNCE_DELAY) { // Hvis knap ikke allerede markeret trykket OG debounce-interval er overskredet
            button2Pressed = true;                           			// Marker knap 2 som trykket
            button2LastPress = currentTime;                  			// Opdater tidspunkt for sidste tryk på knap 2
            button2_handler();                               			// Kald funktionen der håndterer knap 2 tryk
        }
    } else {                                                 		// Hvis knap 2 ikke er trykket (signal er højt)
        button2Pressed = false;                              			// Nulstil knap 2 tryk-status
    }
}

// ============================================================================================================================
/**
 * @brief Håndterer knap 1 tryk
 * 
 * @details Skifter mellem RAW_ADC og ESR_RESULT displaytilstande.
 * 
 * @return void
 */
// ============================================================================================================================
void button1_handler(void) {
    if (displayMode == DISPLAY_MODE_RAW_ADC) {               		// Hvis nuværende displaytilstand er RAW_ADC
        displayMode = DISPLAY_MODE_ESR_RESULT;               			// Skift til ESR_RESULT tilstand
        Serial.println("Display mode: ESR_RESULT");          			// Log ændringen til seriel port
    } else {                                                 		// Hvis nuværende displaytilstand er ESR_RESULT
        displayMode = DISPLAY_MODE_RAW_ADC;                  			// Skift til RAW_ADC tilstand
        Serial.println("Display mode: RAW_ADC");             			// Log ændringen til seriel port
    }
    
    // Sørg for display opdateres med det samme
    newMeasurementAvailable = true;                          		// Sæt flag for at der er nye data til display
    currentState = STATE_UPDATE_DISPLAY;                     		// Sæt state machine til at opdatere display
}

// ============================================================================================================================
/**
 * @brief Håndterer knap 2 tryk
 * 
 * @details Skifter mellem normal og SCPI kommunikationstilstand.
 * 
 * @return void
 */
// ============================================================================================================================
void button2_handler(void) {
    if (commMode == COMM_MODE_NORMAL) {                      		// Hvis nuværende kommunikationstilstand er NORMAL
        commMode = COMM_MODE_SCPI;                           			// Skift til SCPI tilstand
        Serial.println("Communication mode: SCPI");          			// Log ændringen til seriel port
        
        // Vis besked på display
        lcd.clear();                                         			// Ryd LCD display
        lcd.setCursor(0, 0);                                 			// Sæt cursor til starten af første linje
        lcd.print("SCPI Mode");                              			// Skriv "SCPI Mode" på første linje
        lcd.setCursor(0, 1);                                 			// Sæt cursor til starten af anden linje
        lcd.print("Active");                                 			// Skriv "Active" på anden linje
        
        // Reset watchdog under delay
        for (int i = 0; i < 10; i++) {                       			// Loop 10 gange (samlet 1 sekund)
            wdg_reset();                                     				// Reset watchdog timer under ventetid
            delay(100);                                      				// Vent 100 millisekunder
        }
    } else {                                                 		// Hvis nuværende kommunikationstilstand er SCPI
        commMode = COMM_MODE_NORMAL;                         			// Skift til NORMAL tilstand
        Serial.println("Communication mode: NORMAL");        			// Log ændringen til seriel port
        
        // Vis besked på display
        lcd.clear();                                         			// Ryd LCD display
        lcd.setCursor(0, 0);                                 			// Sæt cursor til starten af første linje
        lcd.print("Normal Mode");                            			// Skriv "Normal Mode" på første linje
        lcd.setCursor(0, 1);                                 			// Sæt cursor til starten af anden linje
        lcd.print("Active");                                 			// Skriv "Active" på anden linje
        
        // Reset watchdog under delay
        for (int i = 0; i < 10; i++) {                       			// Loop 10 gange (samlet 1 sekund)
            wdg_reset();                                     				// Reset watchdog timer under ventetid
            delay(100);                                      				// Vent 100 millisekunder
        }
    }
}
/**
* ============================================================================================================================
 * @defgroup SCPI_COMMUNICATION SCPI Communication Module
 * @brief Seriel fjernstyring via SCPI-protokol
 * ============================================================================================================================
 * Muliggør:
 * - Fjernmåling af ESR
 * - Konfiguration af systemet
 * - Integration i automatiske testsystemer
 *
 * Bemærk:
 * SCPI-implementeringen er delvist ufuldstændig.
 */

// ============================================================================================================================
// SCPI KOMMUNIKATIONSFUNKTIONER - IMPLEMENTERING
// ============================================================================================================================
// ============================================================================================================================
/**
 * @brief Læser indkommende seriel data og samler SCPI kommandoer
 * 
 * @details Læser tegn fra seriel port indtil newline og gemmer i buffer.
 * Sætter scpiCommandReady flag når en kommando er komplet.
 * 
 * @note Køres typisk fra loop() eller serialEvent()
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_read_serial(void) {
    while (Serial.available() > 0 && scpiBufferIndex < 255) { 		// Læs så længe der er data og plads i buffer
        char c = Serial.read();                              		// Læs et enkelt tegn fra seriel port
        
        // Ignorer carriage return
        if (c == '\r') {                                     		// Hvis tegnet er carriage return (Windows linjeskift)
            continue;                                        			// Spring over til næste iteration i løkken
        }
        
        // Hvis newline, afslut kommandoen
        if (c == '\n') {                                     		// Hvis tegnet er newline (linjeskift)
            scpiBuffer[scpiBufferIndex] = '\0';             			// Afslut strengen med null-terminering
            scpiCommandReady = true;                         			// Sæt flag at en kommando er klar
            scpiBufferIndex = 0;                            			// Nulstil buffer indeks for næste kommando
            return;                                          			// Afslut funktionen
        }
        
        // Gem tegn i buffer
        scpiBuffer[scpiBufferIndex++] = c;                  		// Gem tegnet i buffer og øg indeks
        
        // Buffer overflow beskyttelse
        if (scpiBufferIndex >= 255) {                        		// Hvis buffer er fuld (eller over)
            scpiBuffer[254] = '\0';                         			// Sikre null-terminering ved sidste position
            scpiBufferIndex = 0;                            			// Nulstil buffer indeks
            scpiCommandReady = true;                         			// Marker at kommando (fejl) er klar
            return;                                          			// Afslut funktionen
        }
    }
}

// ============================================================================================================================
/**
 * @brief Parser SCPI kommandoer og kalder execute-funktion
 * 
 * @details Analyserer kommandoen i scpiBuffer og kalder den korrekte
 * execute-funktion baseret på kommandoen.
 * 
 * @note Opfylder S.SCP.001.2 kravet om SCPI-parser
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_parser(void) {
    if (!scpiCommandReady || scpiBuffer[0] == '\0') {        		// Tjek om kommando er klar og ikke tom
        return;                                              		// Afslut funktionen hvis ingen kommando
    }
    
    // Fjern ledende og afsluttende whitespace
    char *cmd = scpiBuffer;                                  		// Brug pointer til buffer for at undgå at ændre originalen
    
    // Fjern ledende mellemrum
    while (*cmd == ' ' || *cmd == '\t') {                    		// Gennemgå tegn indtil ikke-whitespace
        cmd++;                                               		// Flyt pointeren frem
    }
    
    // Fjern afsluttende whitespace
    int len = strlen(cmd);                                   		// Find længden af den trimmed streng
    while (len > 0 && (cmd[len-1] == ' ' || cmd[len-1] == '\t' || cmd[len-1] == '\r' || cmd[len-1] == '\n')) { 	// Tjek sidste tegn
        cmd[--len] = '\0';                                   		// Erstat med null-terminering og reducer længde
    }
    
    // Kør kommandoen
    scpi_execute(cmd);                                       	    	// Send den trimmede kommando til execute-funktion
    
    // Reset flag og buffer
    scpiCommandReady = false;                                		// Nulstil kommando-klar flag
    scpiBufferIndex = 0;                                     		// Nulstil buffer indeks for næste kommando
}

// ============================================================================================================================
/**
 * @brief Udfører SCPI-kommando
 * 
 * @param command Komplet SCPI-kommando streng
 * 
 * @details Identificerer kommandoen og kalder den korrekte håndteringsfunktion.
 * 
 * @note Opfylder S.SCP.001.3 kravet om SCPI-execute
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_execute(const char *command) {
    // *IDN? - Identifikation
    if (strcmp(command, "*IDN?") == 0) {                     	 // Sammenlign kommando med "*IDN?"
        scpi_handle_idn();                                   	    // Kald identifikationshåndtering
        return;                                              	    // Afslut funktionen
    }
    
    // MEASure:ESR? - Mål ESR
    if (strcmp(command, "MEASure:ESR?") == 0) {              	 // Sammenlign kommando med "MEASure:ESR?"
        scpi_handle_measure_esr();                           	    // Kald ESR-målingshåndtering
        return;                                              	    // Afslut funktionen
    }
    
    // SYSTem:PRESet - System reset
    if (strcmp(command, "SYSTem:PRESet") == 0) {             	 // Sammenlign kommando med "SYSTem:PRESet"
        scpi_handle_system_preset();                         	    // Kald system reset håndtering
        return;                                              	    // Afslut funktionen
    }
    
    // DISPlay:MODE RAW/ESR - Skift displaytilstand
    if (strncmp(command, "DISPlay:MODE ", 13) == 0) {        	 // Tjek om kommandoen starter med "DISPlay:MODE "
        const char *mode = command + 13;                     	    // Ekstraher parameter (det efter "DISPlay:MODE ")
        scpi_handle_display_mode(mode);                      	    // Kald display mode håndtering med parameter
        return;                                              	    // Afslut funktionen
    }
    
    // SYSTem:COMMunication ON/OFF - Skift kommunikationstilstand
    if (strncmp(command, "SYSTem:COMMunication ", 21) == 0) { 	 // Tjek om kommandoen starter med "SYSTem:COMMunication "
        const char *state = command + 21;                    	    // Ekstraher parameter (det efter "SYSTem:COMMunication ")
        scpi_handle_communication(state);                    	    // Kald kommunikationshåndtering med parameter
        return;                                              	    // Afslut funktionen
    }
    
    // Prøv avancerede kommandoer
    scpi_handle_advanced(command);                           	 // Prøv at matche med avancerede kommandoer
}

// ============================================================================================================================
/**
 * @brief Sender SCPI-svar tilbage til klient
 * 
 * @param response Svar-streng at sende
 * 
 * @details Sender svar med newline afslutning.
 * 
 * @note Opfylder S.SCP.001.4 kravet om SCPI-respons (<100 ms)
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_response(const char *response) {
    Serial.println(response);                                		// Send svar til seriel port med newline
}
// ============================================================================================================================
/**
 * @brief Håndterer *IDN? kommandoen
 * 
 * @details Returnerer enhedsidentifikation i standard SCPI-format:
 * Producent,Model,Serienummer,Softwareversion
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_handle_idn(void) {
    char response[128];                                      	// Buffer til svaret
    snprintf(response, sizeof(response),                    	// Formatér strengen
             "ESR-METER,%s,%s,%s",                          	    // SCPI-format: producent,model,serienr,version
             HARDWARE_VERSION, "SN001", FIRMWARE_VERSION);  	    // Indsæt hardwareversion, serienummer og firmwareversion
    scpi_response(response);                                 	// Send svaret til klient
}

// ============================================================================================================================
/**
 * @brief Håndterer MEASure:ESR? kommandoen
 * 
 * @details Udfører en ny måling og returnerer ESR-værdien i ohm
 * med høj præcision. Formaterer output til videnskabelig notation.
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_handle_measure_esr(void) {
    // Udfør måling
    currentState = STATE_MEASURE_ADC;                       			// Sæt state machine til ADC-måling
    state_machine_update(); // ADC måling                   			// Kør state machine for at udføre ADC-måling
    
    currentState = STATE_CALCULATE_ESR;                     			// Sæt state machine til ESR-beregning
    state_machine_update(); // ESR beregning               			// Kør state machine for at beregne ESR
    
    // Send svar med høj præcision
    char response[32];                                      			// Buffer til svaret
    if (calculatedEsr < 0.001) {                            			// Hvis ESR er under 1 mΩ - vis i nΩ
        snprintf(response, sizeof(response), "%.3fn", calculatedEsr * 1000000.0); 	// Konverter til nΩ med 3 decimaler
    } else if (calculatedEsr < 1.0) {                       			// Hvis ESR er under 1 - vis i mΩ
        snprintf(response, sizeof(response), "%.3fm", calculatedEsr * 1000.0);    	// Konverter til mΩ med 3 decimaler
    } else {                                                			// Hvis ESR er 1 Ω eller derover - vis i Ω
        snprintf(response, sizeof(response), "%.4f", calculatedEsr);               	// Vis med 4 decimaler i Ω
    }
    
    scpi_response(response);                                 			// Send svaret til klient
}

// ============================================================================================================================
/**
 * @brief Håndterer SYSTem:PRESet kommandoen
 * 
 * @details Nulstiller systemet til standardtilstande:
 * - Display mode: ESR_RESULT
 * - Communication mode: NORMAL
 * - State: IDLE
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_handle_system_preset(void) {
    displayMode = DISPLAY_MODE_ESR_RESULT;                   			// Sæt displaytilstand til ESR-resultat
    commMode = COMM_MODE_NORMAL;                             			// Sæt kommunikationstilstand til normal
    currentState = STATE_IDLE;                               			// Sæt state machine til idle
    
    // Nulstil måledata
    rawAdcValue = 0;                                         			// Nulstil rå ADC-værdi
    calculatedEsr = 0.0;                                     			// Nulstil beregnet ESR
    currentPgaSetting = PGA_2X_INDEX;                        			// Sæt PGA tilbage til 2x (startindstilling)
    newMeasurementAvailable = true;                          			// Sæt flag for ny måling (så display opdateres)
    
    // Vis bekræftigelse
    lcd.clear();                                             			// Ryd LCD display
    lcd.setCursor(0, 0);                                     			// Sæt cursor til første linje
    lcd.print("System Reset");                               			// Vis "System Reset"
    
    // Reset watchdog under kort delay
    for (int i = 0; i < 5; i++) {                           			// Loop 5 gange (samlet 1 sekund)
        wdg_reset();                                         				// Reset watchdog timer
        delay(200);                                          				// Vent 200 ms
    }
    
    scpi_response("OK");                                     			// Send bekræftigelse til klient
}

// ============================================================================================================================
/**
 * @brief Håndterer DISPlay:MODE kommandoen
 * 
 * @param mode Tilstand ("RAW" eller "ESR")
 * 
 * @details Skifter displaytilstand baseret på parameter.
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_handle_display_mode(const char *mode) {
    if (strcmp(mode, "RAW") == 0) {                         			// Hvis parameter er "RAW"
        displayMode = DISPLAY_MODE_RAW_ADC;                  				// Sæt displaytilstand til rå ADC
        newMeasurementAvailable = true;                      				// Sæt flag for at opdatere display
        scpi_response("OK");                                 				// Send bekræftigelse
    } else if (strcmp(mode, "ESR") == 0) {                  			// Hvis parameter er "ESR"
        displayMode = DISPLAY_MODE_ESR_RESULT;               				// Sæt displaytilstand til ESR-resultat
        newMeasurementAvailable = true;                      				// Sæt flag for at opdatere display
        scpi_response("OK");                                 				// Send bekræftigelse
    } else {                                                 			// Hvis parameter er ugyldig
        scpi_response("ERROR: Invalid mode (RAW or ESR)");   				// Send fejlmeddelelse
    }
}

// ============================================================================================================================
/**
 * @brief Håndterer SYSTem:COMMunication kommandoen
 * 
 * @param state Tilstand ("ON" eller "OFF")
 * 
 * @details Skifter kommunikationstilstand baseret på parameter.
 * 
 * @return void
 */
// ============================================================================================================================
void scpi_handle_communication(const char *state) {
    if (strcmp(state, "ON") == 0) {                         			// Hvis parameter er "ON"
        commMode = COMM_MODE_SCPI;                           				// Sæt kommunikationstilstand til SCPI
        scpi_response("OK");                                 				// Send bekræftigelse
    } else if (strcmp(state, "OFF") == 0) {                 			// Hvis parameter er "OFF"
        commMode = COMM_MODE_NORMAL;                         				// Sæt kommunikationstilstand til normal
        scpi_response("OK");                                 				// Send bekræftigelse
    } else {                                                 			// Hvis parameter er ugyldig
        scpi_response("ERROR: Invalid state (ON or OFF)");   				// Send fejlmeddelelse
    }
}
// ============================================================================================================================
/**
 * @brief Ekstra SCPI kommandoer til avancerede funktioner
 */
// ============================================================================================================================

void scpi_handle_advanced(const char* command) {
    // *TST? - Selvtest
    if (strcmp(command, "*TST?") == 0) {                     			// Tjek om kommandoen er "*TST?"
        bool test_result = system_self_test();              			    // Kør selvtest og gem resultat
        scpi_response(test_result ? "0" : "1"); // 0 = PASS, 1 = FAIL 		    // Send resultat (0 for PASS, 1 for FAIL)
        return;                                              			    // Afslut funktionen
    }
    
    // SYSTem:VERSION? - Systemversion
    if (strcmp(command, "SYSTem:VERSION?") == 0) {          			// Tjek om kommandoen er "SYSTem:VERSION?"
        char response[80];                                  			    // Buffer til svaret
        snprintf(response, sizeof(response), "Firmware:%s,HW:%s,Build:%s", 	    // Formatér versionsinfo
                FIRMWARE_VERSION, HARDWARE_VERSION, get_build_info()); 		    // Indsæt firmware, hardware og build info
        scpi_response(response);                             			    // Send svaret
        return;                                              			    // Afslut funktionen
    }
    
    // SYSTem:HELP - Vis tilgængelige kommandoer
    if (strcmp(command, "SYSTem:HELP") == 0) {              			// Tjek om kommandoen er "SYSTem:HELP"
        scpi_response("Available SCPI commands:");          			    // Send overskrift
        scpi_response("  *IDN? - Identification");          			    // Send kommando 1
        scpi_response("  MEASure:ESR? - Measure ESR");      			    // Send kommando 2
        scpi_response("  SYSTem:PRESet - System reset");    			    // Send kommando 3
        scpi_response("  DISPlay:MODE <RAW|ESR>");          			    // Send kommando 4
        scpi_response("  SYSTem:COMMunication <ON|OFF>");   			    // Send kommando 5
        scpi_response("  *TST? - Self test");               			    // Send kommando 6
        scpi_response("  SYSTem:VERSION? - Version info");  			    // Send kommando 7
        scpi_response("  SYSTem:HELP - This help");         			    // Send kommando 8
        scpi_response("  CALibrate - Start calibration");   			    // Send kommando 9
        return;                                              			    // Afslut funktionen
    }
    
    // CALibrate - Start kalibrering
    if (strcmp(command, "CALibrate") == 0) {                			// Tjek om kommandoen er "CALibrate"
        scpi_response("CALIBRATION STARTED - Follow LCD instructions"); 	    // Send startbesked
        adc_calibrate();                                    			    // Start kalibreringsprocessen
        scpi_response("CALIBRATION COMPLETE - Reprogram required"); 		    // Send færdigbesked
        return;                                              			    // Afslut funktionen
    }
    
    // Ukendt kommando
    scpi_response("ERROR: Unknown command");                			// Send fejlmeddelelse for ukendt kommando
}
// ============================================================================================================================
// WATCHDOG OG FEJLHÅNDTERING - IMPLEMENTERING
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Resetter watchdog timer
 * 
 * @details Kaldes regelmæssigt i main loop for at forhindre
 * watchdog i at timeout'e og genstarte systemet.
 * 
 * @note Opfylder S.WDG.001.2 kravet om watchdog reset
 * 
 * @return void
 */
// ============================================================================================================================
void wdg_reset(void) {
    esp_task_wdt_reset();                                    	// ESP32: resetter watchdog timer for at forhindre genstart
    wdgCounter++;                                            	// Øg watchdog tæller for debugging
    
    // Log watchdog reset hver 1000. gang (debugging)
    if (wdgCounter % 1000 == 0) {                           	// Hvis tæller er delelig med 1000 (hver 1000. gang)
        Serial.print("Watchdog reset #");                   		// Udskriv debug-besked til seriel port
        Serial.println(wdgCounter);                         		// Udskriv watchdog tællerværdi
    }
}

// ============================================================================================================================
/**
 * @brief Central fejlhåndteringsfunktion
 * 
 * @param error_message Fejlbesked
 * @param error_code Fejlkode (hex)
 * 
 * @details Logger fejlen til seriel port, viser på display,
 * og sætter systemet i ERROR state.
 * 
 * @note Opfylder S.WDG.001.3 kravet om fejllogging
 * 
 * @return void
 */
// ============================================================================================================================
void error_handler(const char *error_message, uint8_t error_code) {
    // Log fejl til seriel port
    Serial.print("ERROR [0x");                              				// Udskriv fejlpræfiks til seriel port
    Serial.print(error_code, HEX);                          				// Udskriv fejlkode i hexadecimal
    Serial.print("]: ");                                    				// Afslut fejlpræfiks
    Serial.println(error_message);                          				// Udskriv fejlbeskeden
    
    // Vis fejl på display
    char display_msg[32];                                   				    // Buffer til fejlbesked til display
    snprintf(display_msg, sizeof(display_msg), "Err 0x%02X: %s", error_code, error_message);// Formatér fejlbesked til display
    display_error(display_msg);                             				    // Vis fejlbesked på LCD
    
    // Sæt system i ERROR state
    currentState = STATE_ERROR;                             				// Skift systemtilstand til fejltilstand
    
    // Log timestamp
    Serial.print("Error time: ");                           				// Udskriv tekst for fejltidspunkt
    Serial.println(millis());                               				// Udskriv systemtidspunkt for fejl
    
    // Log systemtilstand
    Serial.print("System state: ");                         			// Udskriv tekst for systemtilstand
    Serial.println(currentState);                           			// Udskriv nuværende systemtilstand
    Serial.print("Display mode: ");                         			// Udskriv tekst for displaytilstand
    Serial.println(displayMode);                            			// Udskriv nuværende displaytilstand
    Serial.print("Comm mode: ");                            			// Udskriv tekst for kommunikationstilstand
    Serial.println(commMode);                               			// Udskriv nuværende kommunikationstilstand
}

// ============================================================================================================================
// SERIEL EVENT-HÅNDTERER
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Seriel event-håndterer (køres automatisk)
 * 
 * @details Læser indkommende seriel data når det er tilgængeligt.
 * Bruges kun i SCPI-tilstand.
 * 
 * @note Arduino IDE kalder automatisk serialEvent() når seriel data er klar
 * 
 * @return void
 */
// ============================================================================================================================
void serialEvent() {
    if (commMode == COMM_MODE_SCPI) {                       			// Tjek om systemet er i SCPI-tilstand
        scpi_read_serial();                                 			// Læs indkommende seriel data til SCPI buffer
    }
}

// ============================================================================================================================
// TEST- OG KALIBRERINGSFUNKTIONER
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Selvtest-rutine for systemvalidering
 * 
 * @details Udfører en række tests for at validere systemfunktionalitet
 * 
 * @return bool True hvis alle tests bestås
 */
// ============================================================================================================================
bool system_self_test(void) {
    Serial.println("=== SYSTEM SELVTEST ===");               		// Udskriv overskrift for selvtest
    
    bool all_tests_passed = true;                           		// Flag der indikerer om alle tests bestås
    
    // Test 1: ADC-kan læses
    Serial.print("Test 1 - ADC læsning: ");                 		// Udskriv test 1 beskrivelse
    int16_t adc_test = adc_read_single(PGA_2X_INDEX);       		// Læs en enkelt ADC-værdi med PGA 2x
    if (adc_test != 0 || adc_test != -1) { 				// Tjek om ADC-værdi er anderledes end 0 eller -1
        Serial.println("PASS");                             			// Test bestået
    } else {								//Ellers
        Serial.println("FAIL");                             			// Test fejlet
        all_tests_passed = false;                           			// Opdater flag til fejl
    }
    
    // Test 2: Oversampling fungerer
    Serial.print("Test 2 - Oversampling: ");                		// Udskriv test 2 beskrivelse
    int32_t adc_oversampled = adc_read_oversampled(PGA_2X_INDEX); 	// Læs ADC med 64× oversampling
    if (abs(adc_oversampled - adc_test) < 1000) { 			// Tjek om forskellen mellem enkelt og oversampled er < 1000
        Serial.println("PASS");                             			// Test bestået
    } else {								// Ellers
        Serial.println("FAIL");                             			// Test fejlet
        all_tests_passed = false;                           			// Opdater flag til fejl
    }
    
    // Test 3: PGA auto-range
    Serial.print("Test 3 - PGA auto-range: ");              		// Udskriv test 3 beskrivelse
    uint8_t pga_test = adc_auto_range();                    		// Kald funktion til automatisk PGA-valg
    if (pga_test >= 0 && pga_test <= 3) {                   		// Tjek om PGA-indeks er i gyldigt område (0-3)
        Serial.println("PASS");                             			// Test bestået
    } else {								//Ellers
        Serial.println("FAIL");                             			// Test fejlet
        all_tests_passed = false;                           			// Opdater flag til fejl
    }
    
    // Test 4: ESR beregning
    Serial.print("Test 4 - ESR beregning: ");               		// Udskriv test 4 beskrivelse
    float esr_test = esr_calculate(PGA_2X_INDEX, 1000);     		// Beregn ESR for en ADC-værdi på 1000
    if (esr_test >= 0.0 && esr_test <= 10.0) {              		// Tjek om ESR er i gyldigt område (0-10 ohm)
        Serial.println("PASS");                             			// Test bestået
    } else {								//Ellers
        Serial.println("FAIL");                             			// Test fejlet
        all_tests_passed = false;                           			// Opdater flag til fejl
    }
    
    // Test 5: Display fungerer
    Serial.print("Test 5 - Display: ");                     		// Udskriv test 5 beskrivelse
    lcd.clear();                                            		// Ryd LCD display
    lcd.setCursor(0, 0);                                    		// Sæt cursor til første linje
    lcd.print("TEST");                                      		// Skriv "TEST" på display
    wdg_reset();                                            		// Reset watchdog under delay
    delay(100);                                             		// Vent 100ms for at kunne se display
    Serial.println("PASS (visuel check)");                  		// Test bestået (kræver visuel bekræftigelse)
    
    // Test 6: Knapper
    Serial.print("Test 6 - Knapper: ");                     		// Udskriv test 6 beskrivelse
    bool btn1 = digitalRead(BUTTON1_PIN);                   		// Læs knap 1 tilstand
    bool btn2 = digitalRead(BUTTON2_PIN);                   		// Læs knap 2 tilstand
    if (btn1 == HIGH && btn2 == HIGH) { // Pull-up, så HIGH = ikke trykket // Tjek om begge knapper ikke er trykket (HIGH med pull-up)
        Serial.println("PASS");                             			// Test bestået
    } else {								   //Ellers
        Serial.println("FAIL");                             			// Test fejlet
        all_tests_passed = false;                           			// Opdater flag til fejl
    }
    
    // Test 7: DDS-generator
    Serial.print("Test 7 - DDS-generator: ");               		// Udskriv test 7 beskrivelse
    hal_ad9850_set_frequency(100000);                       		// Sæt DDS-generator til 100 kHz
    Serial.println("PASS (100 kHz sat)");                   		// Test bestået (funktionskald uden fejl)
    
    // Test 8: Watchdog
    Serial.print("Test 8 - Watchdog: ");                    		// Udskriv test 8 beskrivelse
    wdg_reset();                                            		// Reset watchdog timer
    Serial.println("PASS (watchdog reset)");                		// Test bestået (funktionskald uden fejl)
    
    Serial.print("=== SELVTEST ");                          		// Udskriv slutningsoverskrift
    if (all_tests_passed) {                                 		// Hvis alle tests bestået
        Serial.println("GENNEMFØRT ===");                   			// Udskriv "GENNEMFØRT"
    } else {                                                		// Hvis en eller flere tests fejlede
        Serial.println("FEJL ===");                         			// Udskriv "FEJL"
    }
    
    return all_tests_passed;                               		// Returner resultat af selvtest
}

// ============================================================================================================================
/**
 * @brief Nødkalibrering for hurtig opsætning
 * 
 * @details Genererer standard kalibreringstabeller baseret på teoretiske værdier
 * Dette er KUN til test og skal erstattes med rigtig kalibrering
 */
// ============================================================================================================================
void emergency_calibration(void) {
    Serial.println("=== NØDKALIBRERING (TEST) ===");         			// Udskrift af overskrift for nødkalibrering
    Serial.println("Advarsel: Dette er kun testdata!");     			// Advarsel om at data kun er til test
    Serial.println("Korrekt kalibrering kræver fysiske referencemodstande"); 	// Instruktion om rigtig kalibrering
    
    // Teoretiske værdier baseret på:
    // Full scale ADC = 32767
    // ESR range = 0-10 ohm
    // Lineært forhold antaget
    
    for (int pga = 0; pga < NUM_PGA_SETTINGS; pga++) {      			    // Loop gennem alle 4 PGA-indstillinger
        Serial.print("Genererer tabel for PGA ");           				// Udskriv hvilken PGA der behandles
        Serial.print(pga == 0 ? "2x" : pga == 1 ? "4x" : pga == 2 ? "8x" : "16x"); 	// Konverter PGA-indeks til tekst
        Serial.println(":");                                				// Afslut linje
        
        for (int i = 0; i < TABLE_ENTRIES; i++) {           // Loop gennem alle 30 tabelindgange
            							// Teoretiske værdier (skal erstattes med rigtige målte værdier)
            int16_t adc_val = i * 100; 				// Eksempelværdier:Simpel lineær ADC-værdi (100, 200, 300...)
            float esr_val = (i / 3.0); 				// Eksempelværdier: Simpel lineær ESR-værdi (0, 0.333, 0.667...)
            
            Serial.print("  Entry ");                       	// Udskrift af tabelindgang
            Serial.print(i);                                	// Udskriv indeks
            Serial.print(": ADC=");                         	// 
            Serial.print(adc_val);                          	// Udskriv ADC-værdi
            Serial.print(", ESR=");                         	//
            Serial.print(esr_val, 3);                       	// Udskriv ESR-værdi med 3 decimaler
            Serial.println(" ohm");                         	// Afslut linje med enhed
        }
    }
    
    Serial.println("=== NØDKALIBRERING FÆRDIG ===");        	// Udskrift af afsluttende overskrift
    Serial.println("Husk: Dette er kun testdata!");         	// Gentag advarsel om testdata
}
// ============================================================================================================================
// ADVANCED FEATURE FUNKTIONER
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Temperaturkompensation for ESR-målinger
 * 
 * @param esr_value Målt ESR-værdi ved 25°C
 * @param temperature_degC Aktuel temperatur i °C
 * 
 * @return float Temperaturkompenseret ESR-værdi
 */
// ============================================================================================================================
float temperature_compensate_esr(float esr_value, float temperature_degC) {
    // Temperaturkoefficient for typiske elektrolytkondensatorer
    // Dette er et estimat - faktisk koefficient afhænger af kondensatortype
    const float TEMP_COEFFICIENT = -0.02; // -2% per 10°C   	    // Typisk temperaturkoefficient for elektrolytkondensatorer
    
    float temp_diff = temperature_degC - 25.0; // Reference ved 25°C 		// Beregn temperaturforskel fra reference (25°C)
    float compensation_factor = 1.0 + (TEMP_COEFFICIENT * temp_diff / 10.0);	// Beregn kompensationsfaktor
    	
    return esr_value * compensation_factor;                 			// Returner temperaturkompenseret ESR-værdi
}

// ============================================================================================================================
/**
 * @brief Statistisk analyse af målinger
 * 
 * @param measurements Array af målinger
 * @param count Antal målinger
 * @param mean Pointer til gennemsnittet
 * @param stddev Pointer til standardafvigelsen
 */
// ============================================================================================================================
void analyze_measurements(float measurements[], int count, float *mean, float *stddev) {
    if (count <= 0) {                                       		// Hvis der er ingen målinger
        *mean = 0.0;                                        			// Sæt gennemsnit til 0
        *stddev = 0.0;                                      			// Sæt standardafvigelse til 0
        return;                                             			// Afslut funktionen
    }
    
    // Beregn gennemsnit
    float sum = 0.0;                                        		// Initialiser sum variabel
    for (int i = 0; i < count; i++) {                       		// Loop gennem alle målinger
        sum += measurements[i];                             			// Tilføj måling til sum
    }
    *mean = sum / count;                                    		// Beregn gennemsnit (sum / antal)
    
    // Beregn standardafvigelse
    float variance = 0.0;                                   		// Initialiser varians variabel
    for (int i = 0; i < count; i++) {                       		// Loop gennem alle målinger igen
        float diff = measurements[i] - *mean;               			// Beregn forskel fra gennemsnit
        variance += diff * diff;                            			// Tilføj kvadratet af forskellen til varians
    }
    variance /= count;                                      		// Beregn gennemsnitlig varians
    *stddev = sqrt(variance);                               		// Beregn standardafvigelse som kvadratrod af varians
}

// ============================================================================================================================
// KONFIGURATIONSFUNKTIONER
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Indlæser konfiguration fra ikke-flygtig hukommelse
 */
// ============================================================================================================================
void load_configuration(void) {
    // I en rigtig implementering ville dette læse fra EEPROM eller flash
    // For nu bruger vi standardværdier
    
    Serial.println("Indlæser konfiguration...");            			// Log indlæsning af konfiguration
    
    // Standardkonfiguration
    displayMode = DISPLAY_MODE_ESR_RESULT;                  			// Sæt displaytilstand til ESR-resultat
    commMode = COMM_MODE_NORMAL;                            			// Sæt kommunikationstilstand til normal
    
    // Her kan flere konfigurationsparametre tilføjes
}

// ============================================================================================================================
/**
 * @brief Gemmer konfiguration til ikke-flygtig hukommelse
 */
// ============================================================================================================================
void save_configuration(void) {
    // I en rigtig implementering ville dette gemme til EEPROM eller flash
    
    Serial.println("Gemmer konfiguration...");              				// Log gemning af konfiguration
    Serial.println("Bemærk: Konfiguration ikke implementeret i denne version"); 	// Advarsel om manglende implementering
}

// ============================================================================================================================
/**
 * @brief Rydningsfunktion køres før genstart
 */
// ============================================================================================================================
void cleanup_before_restart(void) {
    Serial.println("Udfører oprydning...");                  				// Log start af oprydning
    
    // Sluk DDS
    hal_ad9850_set_frequency(0);                            				// Sæt DDS-generator til 0 Hz (slukket)
    
    // Sluk LCD backlight
    lcd.noBacklight();                                      				// Sluk LCD baggrundsbelysning
    
    // Sluk display
    lcd.clear();                                            				// Ryd LCD display
    
    // Log genstart
    Serial.println("System klar til genstart");             				// Log klar til genstart
    Serial.println("================================");     				// Afslut med skillelinje
}

// ============================================================================================================================
/**
 * @brief Returnerer firmware build information
 */
// ============================================================================================================================
const char* get_build_info(void) {
    return __DATE__ " " __TIME__;                           		// Returner kompileringsdato og klokkeslæt som streng
}
// ============================================================================================================================
// TEST HOVEDPROGRAM TIL DEBUGGING
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Testprogram der kører ved start hvis TEST_MODE er defineret
 */
// ============================================================================================================================
void run_test_program(void) {
    Serial.println("=== TEST MODE AKTIV ===");              			// Udskrift af overskrift når test mode aktiveres
    
    // Kør selvtest
    system_self_test();                                     			// Kør den fulde systemselvtest-funktion
    
    // Test DDS frekvenser
    Serial.println("Testing DDS frequencies:");            			// Udskrift af overskrift for DDS-frekvenstest
    uint32_t test_freqs[] = {100000, 50000, 200000, 1000}; 			// Array med testfrekvenser i Hz
    for (int i = 0; i < 4; i++) {                          			// Loop gennem alle 4 testfrekvenser
        hal_ad9850_set_frequency(test_freqs[i]);           				// Indstil DDS til testfrekvens
        
        // Reset watchdog under delay
        for (int j = 0; j < 5; j++) {                      				// Loop 5 gange (samlet 500ms ventetid)
            wdg_reset();                                   					// Reset watchdog timer
            delay(100);                                    					// Vent 100 millisekunder
        }
    }
    // Tilbage til 100 kHz
    hal_ad9850_set_frequency(100000);                      			// Sæt DDS tilbage til normal driftfrekvens (100 kHz)
    
    // Test ADC PGA settings
    Serial.println("Testing ADC PGA settings:");            			// Udskrift af overskrift for ADC PGA-test
    for (int pga = 0; pga < 4; pga++) {                    			// Loop gennem alle 4 PGA-indstillinger (0-3)
        Serial.print("PGA ");                               			   // Udskriv "PGA "
        Serial.print(pga == 0 ? "2x" : pga == 1 ? "4x" : pga == 2 ? "8x" : "16x"); // Konverter PGA-index til læselig tekst
        Serial.print(": ");                                 			   // Udskriv ": "
        int16_t val = adc_read_single(pga);                			   // Læs enkelt ADC-værdi med denne PGA-indstilling
        Serial.println(val);                               			   // Udskriv ADC-værdien
        
        // Reset watchdog under delay
        wdg_reset();                                       			   // Reset watchdog timer
        delay(100);                                        			   // Vent 100 millisekunder
    }
    
    // Test display modes
    Serial.println("Testing display modes:");               			// Udskrift af overskrift for display-test
    display_raw_adc(1234, PGA_2X_INDEX);                   			// Test visning af rå ADC-værdi (1234) med PGA 2x
    
    // Reset watchdog under delay
    for (int i = 0; i < 5; i++) {                          			// Loop 5 gange (samlet 1 sekund ventetid)
        wdg_reset();                                       			   // Reset watchdog timer
        delay(200);                                        			   // Vent 200 millisekunder
    }
    
    display_esr_result(1.234, 1234, PGA_2X_INDEX);     // Test visning af ESR-resultat (1.234 ohm) med ADC-værdi 1234 og PGA 2x
    
    // Reset watchdog under delay
    for (int i = 0; i < 5; i++) {                          			// Loop 5 gange (samlet 1 sekund ventetid)
        wdg_reset();                                       			   // Reset watchdog timer
        delay(200);                                        			   // Vent 200 millisekunder
    }
    
    Serial.println("=== TEST MODE FÆRDIG ===");             			// Udskrift af afsluttende overskrift
}

// ============================================================================================================================
// FIRMWARE VERSION VALIDERING
// ============================================================================================================================

// Kompiler-checks for at sikre korrekt konfiguration
#ifndef FIRMWARE_VERSION                                    	      // Kompilerdirektiv: Hvis FIRMWARE_VERSION ikke er defineret
#error "FIRMWARE_VERSION skal være defineret"              		// Stop kompilering med fejlmeddelelse
#endif                                                     	      // Afslut #ifndef direktivet

#ifndef HARDWARE_VERSION                                    	      // Kompilerdirektiv: Hvis HARDWARE_VERSION ikke er defineret  
#error "HARDWARE_VERSION skal være defineret"              		// Stop kompilering med fejlmeddelelse
#endif                                                     	      // Afslut #ifndef direktivet

#if TABLE_ENTRIES != 30                                     	      // Kompilerdirektiv: Hvis TABLE_ENTRIES ikke er 30
#warning "TABLE_ENTRIES bør være 30 ifølge kravspecifikationen"         // Udskriv advarsel under kompilering
#endif                                                    	      // Afslut #if direktivet

#if OVERSAMPLING_FACTOR != 64                               	      // Kompilerdirektiv: Hvis OVERSAMPLING_FACTOR ikke er 64
#warning "OVERSAMPLING_FACTOR bør være 64 ifølge kravspecifikationen"   // Udskriv advarsel under kompilering
#endif                                                     	      // Afslut #if direktivet
// ============================================================================================================================
// SLUT PÅ FIRMWARE IMPLEMENTERING
// ============================================================================================================================

// ============================================================================================================================
/**
 * @brief Slutkommentar og licensinformation
 * 
 * ESR-Meter Firmware v1.00
 * Baseret på kravspecifikation SRS-ESR-MIL-001
 * 
 * Ophavsret (c) 2026 Jan Engelbrecht Pedersen
 * 
 * Softwaren leveres "som den er", uden nogen form for garanti.
 */
// ============================================================================================================================

// ============================================================================================================================
// DOKUMENTATION FOR ESR-METER FIRMWARE
// ============================================================================================================================

/*
 * ==========================================================================================================================
 * DOKUMENTATION FOR ESR-METER FIRMWARE
 * ==========================================================================================================================
 * 
 * 7.1 BUILD-INSTRUKTIONER
 * 
 * Forudsætninger:
 * - Arduino IDE 2.x eller PlatformIO
 * - ESP32 Board Support pakke
 * - Nødvendige biblioteker: Wire, Adafruit_ADS1X15, LiquidCrystal_I2C
 * 
 * Installations-trinn:
 * 1. Åbn Arduino IDE
 * 2. Værktøjer → Board → ESP32 Arduino → ESP32 Wrover Module
 * 3. Værktøjer → Port → Vælg korrekt COM-port
 * 4. Værktøjer → Upload Speed → 921600
 * 5. Biblioteker → Installer Adafruit ADS1X15 og LiquidCrystal_I2C
 * 6. Åbn ESR_Meter.ino og upload
 * 
 * ==========================================================================================================================
 * 7.2 KALIBRERINGSPROSES
 * 
 * Vigtigt: Firmwaren kræver kalibrering før første brug!
 * 
 * Forberedelse:
 * - 30 præcise referencemodstande (0-10 Ω)
 * - Multimeter til verifikation
 * - Stabil strømforsyning
 * 
 * Kalibreringsprocedure:
 * 1. Kør emergency_calibration() for testdata
 * 2. For hver referencemodstand:
 *    - Tilslut til ESR-meter
 *    - Mål og notér ADC-værdi
 *    - Opdater tabelværdier i koden
 * 3. Genprogrammer firmware med nye tabelværdier
 * 4. Verificér med kendte modstande
 * 
 * ==========================================================================================================================
 * 7.3 TEST OG VALIDERING (T.ACC.001)
 * 
 * Accepttest procedure:
 * 
 * Præcisionstest (T.ACC.001.1):
 * - Mål 10 kendte modstande (0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 7.0, 9.0, 10.0 Ω)
 * - Verificér 5% nøjagtighed: |(målt - reference)|/reference ≤ 0.05
 * 
 * Opløsningstest (T.ACC.001.2):
 * - Mål på 1.000 Ω og 1.001 Ω referencemodstande
 * - Verificér at systemet kan skelne mellem dem
 * 
 * Sikkerhedstest (T.ACC.001.3):
 * - Mål testsignal med oscilloskop
 * - Verificér ≤ 0.1V p-p ved testprobene
 * 
 * Robusthedstest (T.ACC.001.4):
 * - ESD-test på probeforbindelser
 * - EMI-test med RF-generator
 * 
 * ==========================================================================================================================
 * 7.4 FEJLFINDING
 * 
 * Almindelige problemer og løsninger:
 * 
 * Ingen LCD-visning:
 * - Tjek I2C-adresse (typisk 0x27)
 * - Tjek I2C-forbindelser
 * - Kontroller strømforsyning
 * 
 * Ingen ADC-læsning:
 * - Tjek ADS1115 forbindelser
 * - Verificér I2C-kommunikation
 * - Kontroller referencenspænding
 * 
 * Ustabile målinger:
 * - Kontroller grounding (AGND/DGND)
 * - Tjek for støjkilder
 * - Verificér DDS-signal renhed
 * 
 * Watchdog genstarter:
 * - Tjek for blocking kode i loop()
 * - Verificér at wdg_reset() kaldes regelmæssigt
 * - Kontroller for stack overflow
 * 
 * ==========================================================================================================================
 * 7.5 VEDLIGEHOLDELSE
 * 
 * Regelmæssige opgaver:
 * 
 * Månedligt:
 * - Kontroller fysiske probeforbindelser
 * - Test med kendte referencemodstande
 * - Opdater fejllog
 * 
 * Hver 6. måned:
 * - Genkalibrer med referencemodstande
 * - Kontroller komponenters specifikationer
 * - Opdater firmware hvis nødvendigt
 * 
 * Årligt:
 * - Fuldt systemtest
 * - Kontroller PCB for korrosion
 * - Verificér strømforsyningskomponenter
 * 
 * ==========================================================================================================================
 * 7.6 SIKKERHEDSFORHOLDSREGLER
 * 
 * Vigtige advarsler:
 * 
 * In-circuit måling:
 * - ALTID sluk for strømmen til testet kredsløb først
 * - VERIFICER at testsignal er ≤ 0,1V p-p
 * - UNDGÅ måling i højspændingskredsløb (>50V)
 * 
 * Kalibrering:
 * - Brug KUN præcisionsmodstande med dokumenteret nøjagtighed
 * - UNDGÅ termisk drift under kalibrering
 * - VERIFICER måleresultater med sekundært instrument
 * 
 * Software:
 * - REGELMÆSSIG backup af kalibreringsdata
 * - TEST firmware-opdateringer før produktionsbrug
 * - DOKUMENTER alle ændringer til koden
 * 
 * ==========================================================================================================================
 * 7.7 PERFORMANCENØGLETAL
 * 
 * Forventede systemparametre:
 * - Målenøjagtighed: ≤ 5% over 0-10 Ω område
 * - Opløsning: 1 mΩ effektiv
 * - Måletid: ≤ 100 ms per måling
 * - Strømforbrug: ~280 mA typisk
 * - Opstartstid: < 3 sekunder
 * - Temperaturområde: 15-25°C (uden kompensation)
 * 
 * ==========================================================================================================================
 */
/*
*===========================================================================================
*DEVELOPER GUIDE – VIDEREUDVIKLING AF ESR-METER FIRMWARE
*===========================================================================================
*
*FORMÅL
*------
*Denne kommentarsektion er målrettet udviklere, der skal overtage, vedligeholde
*eller videreudvikle denne firmware. 
*
*Den beskriver arkitektur, underudviklede dele samt konkrete 
*forbedrings- og videreudviklingsmuligheder.
*
*----------------------------------------------------------------------------------------------------
*1. OVERORDNET ARKITEKTUR
*----------------------------------------------------------------------------------------------------
*
*Firmwaren er opbygget som én samlet .ino-fil, men er logisk opdelt i følgende lag:
*
*- HAL (Hardware Abstraction Layer)
*  * AD9850 DDS-generator
*  * ADS1115 ADC
*  * LCD-display
*  * Knapper
*  * Watchdog
*
*- Måle- og signalbehandling
*  * ADC single-shot
*  * 64× oversampling
*  * Automatisk PGA-range selection
*
*- ESR-beregning
*  * Tabelbaseret opslag
*  * Lineær interpolation
*  * PGA-afhængige kalibreringstabeller
*
*- UI
*  * LCD-visning
*  * Knapbaseret tilstandsskift
*
*- Kommunikation
*  * Normal seriel output
*  * SCPI-protokol (delvist implementeret)
*
*- State machine
*  * Central styring af hele systemets flow
*
*State machine er den logiske kerne og kontrollerer alle systemtilstande via
*currentState.
*
*----------------------------------------------------------------------------------------------------
*2. VIGTIGE INDGANGSPUNKTER I KODEN
*----------------------------------------------------------------------------------------------------
*
*- setup():
*  Initialiserer al hardware, state machine, konfiguration og DDS-signal.
*
*- loop():
*  Kører kontinuerligt:
*    * knap-check
*    * state machine
*    * SCPI-behandling
*    * watchdog reset
*
*- state_machine_update():
*  Dispatcher systemets tilstande (IDLE, MEASURE, CALCULATE, DISPLAY, SCPI, ERROR).
*
*- adc_read_oversampled():
*  Kritisk funktion for målekvalitet (64× oversampling).
*
*- esr_calculate():
*  Central ESR-beregningsfunktion baseret på tabeller og interpolation.
*
*----------------------------------------------------------------------------------------------------
*3. KENDTE BEGRÆNSNINGER (VIGTIGT)
*----------------------------------------------------------------------------------------------------
*
*- ESR-tabeller er PLADSHOLDERE
*  De nuværende tabeller er ikke baseret på reel kalibrering og skal udskiftes.
*
*- Kalibrering kræver genprogrammering
*  adc_calibrate() kan ikke gemme data persistent.
*
*- SCPI er ikke fuldt implementeret
*  Flere handlers er stubbe eller tomme.
*
*- Ingen persistent lagring
*  Konfiguration og kalibrering gemmes ikke i NVS / EEPROM.
*
*- Monolitisk filstruktur
*  Hele systemet ligger i én .ino-fil, hvilket hæmmer skalerbarhed.
*
*----------------------------------------------------------------------------------------------------
*4. UNDERUDVIKLEDE DELE – HØJ PRIORITET
*----------------------------------------------------------------------------------------------------
*
*4.1 ESR-TABELLER & KALIBRERING
*------------------------------
*Nuværende:
*- Hardcodede PROGMEM-tabeller
*- Ingen runtime-kalibrering
*- Ingen temperaturkompensation i praksis
*
*Mulig videreudvikling:
*- Kalibreringsrutine styret via SCPI
*- Gem kalibreringsdata i ESP32 NVS
*- Understøt flere kalibreringsprofiler
*- Automatisk regenerering af interpolationstabeller
*
*Gevinst:
*- Måleteknisk valide ESR-resultater
*- Ingen behov for recompilering
*- Felt- og servicekalibrering mulig
*
*----------------------------------------------------------------------------------------------------
*4.2 SCPI-KOMMUNIKATION
*----------------------
*Nuværende:
*- Basal parser
*- Enkelte kommandoer
*- Manglende fejl- og statusrapportering
*
*Mulig videreudvikling:
*- Fuldt SCPI-sæt, fx:
*    * MEAS:ESR?
*    * CONF:PGA AUTO|MAN
*    * CAL:START
*    * SYST:ERR?
*    * *IDN?
*- Kommando-hjælp og syntaksvalidering
*- Fejlkø og statusregistre
*
*Gevinst:
*- Integration i automatiserede testsystemer
*- PC-/LabVIEW-/Python-styring
*- Produktions- og laboratorieegnet instrument
*
*----------------------------------------------------------------------------------------------------
*4.3 STATE MACHINE
*-----------------
*Nuværende:
*- Alle states er defineret
*- Flere handlers er minimale
*
*Mulig videreudvikling:
*- Event-baserede state transitions
*- Timeout-håndtering pr. state
*- Klar recovery-strategi i ERROR-state
*
*Gevinst:
*- Mere deterministisk systemadfærd
*- Lettere fejlfinding
*- Bedre robusthed
*
*----------------------------------------------------------------------------------------------------
*4.4 DISPLAY & UI
*----------------
*Nuværende:
*- Meget simpel visning
*- Kun to display modes
*- Begrænset brugerfeedback
*
*Mulig videreudvikling:
*- Simpelt menu-system
*- Statuslinje (PGA, mode, fejl)
*- Progress-visning ved kalibrering
*- Fejlmeddelelser på display
*
*Gevinst:
*- Markant bedre brugeroplevelse
*- Mindre afhængighed af seriel debug
*
*----------------------------------------------------------------------------------------------------
*5. KODEFORBEDRINGER (ARKITEKTUR & KVALITET)
*----------------------------------------------------------------------------------------------------
*
*5.1 MODULOPDELING (ANBEFALET)
*-----------------------------
*Opdel koden i:
*- hal_*.h / hal_*.cpp
*- adc.h / adc.cpp
*- esr.h / esr.cpp
*- scpi.h / scpi.cpp
*- ui.h / ui.cpp
*
*Fordele:
*- Bedre vedligeholdelse
*- Mulighed for enhedstest
*- Klar ansvarsopdeling
*
*----------------------------------------------------------------------------------------------------
*5.2 FEJLHÅNDTERING & LOGGING
*----------------------------
*Mulige tiltag:
*- Central fejlstruktur
*- Fejlkoder via SCPI (SYST:ERR?)
*- Konsistent brug af error_handler()
*
*Gevinst:
*- Hurtigere fejlfinding
*- Mere professionelt system
*
*----------------------------------------------------------------------------------------------------
*5.3 ADC & SIGNALBEHANDLING
*--------------------------
*Mulige forbedringer:
*- Medianfilter før oversampling
*- Outlier rejection
*- Aktiv temperaturkompensation
*- Dynamisk justering af oversampling
*
*Gevinst:
*- Mere stabile og reproducerbare målinger
*
*----------------------------------------------------------------------------------------------------
*6. ANBEFALET VIDEREUDVIKLINGS-ROADMAP
*----------------------------------------------------------------------------------------------------
*
*Fase 1 – Måleteknisk korrekthed
*- Rigtige kalibreringsdata
*- Persistent lagring
*- Temperaturkompensation
*
*Fase 2 – Kommunikation
*- Fuldt SCPI-interface
*- PC-integration
*
*Fase 3 – Arkitektur
*- Modulopdeling
*- Testbarhed
*
*Fase 4 – Brugeroplevelse
*- Menusystem
*- Status- og fejlvisning
*
*----------------------------------------------------------------------------------------------------
*KONKLUSION
*----------------------------------------------------------------------------------------------------
*
*Firmwaren er arkitektonisk solid og veldokumenteret, men flere centrale dele
*er bevidst efterladt ufærdige. Det gør projektet velegnet som:
*
*- Videreudviklingsplatform
*- Professionel prototype
*- Reference- og undervisningsprojekt
*
*Det største forbedringspotentiale ligger i:
*- Kalibrering
*- SCPI
*- Persistent konfiguration
*- Modulopdeling
*
*============================================================================================
*/

// ============================================================================================================================
// FIRMWARE IMPLEMENTERING FÆRDIG
// ============================================================================================================================

Bilag C: Testresultater og måledata
Detaljerede testprotokoller, oscilloskopskærmbilleder og tabeller med referencemålinger.

Bilag D: PCB Layout rapport, PCB layout og skematisk diagram
Skematisk diagram (PDF) og Gerber‑filer for PCB‑produktion.

Bilag E: Kravspecifikation

==============================================================================================================================
|															     |
|				    Kravspecifikation for In-Circuit ESR-meter  					     |
|															     |
==============================================================================================================================
| DOKUMENT ID:	SRS-ESR-MIL-001												     |
| DATO:		19-01-25												     |
| VERSION:	1.00													     |
| SYSTEM:	INCIRCUIT ESR METER											     |
| FORFATTER:	Jan Engelbrecht Pedersen										     |
==============================================================================================================================

==============================================================================================================================
§1. Præcis sammenfatning
==============================================================================================================================
Dette dokument specificerer konstruktionskrav til et professionelt in-circuit ESR-meter til hobbybrug med komplet 
klassificering af hardware-, software-, dokumentations-, test- og produktionskrav. 
Systemet måler ESR i elektrolytkondensatorer (0-10 Ω, 1 mΩ opløsning) ved 100 kHz med maksimalt 0,1V signal for sikker 
in-circuit operation. Hardwaren implementeres med rail-to-rail low voltage opamps, AD9850 DDS-generator, Kelvin-prober, 
Schottky-dioder i superdiode-kredsløb, ADS1115 ADC, 2-lags PCB med EMI/EMC/ESD-beskyttelse, 
og switched capacitor negativ forsyning. 
Firmwaren inkluderer watchdog-timer og implementeres i Arduino C++ med SCPI-protokol.
==============================================================================================================================
§2. Definitioner og præcisering
==============================================================================================================================
------------------------------------------------------------------------------------------------------------------------------
2.1 Formelle definitioner
------------------------------------------------------------------------------------------------------------------------------
H.ESR.001: ESR (Equivalent Series Resistance): Effektiv serie-modstand i elektrolytkondensator ved 100 kHz frekvens

H.MET.001: In-circuit måling: Måling udført uden afsondring fra kredsløb med <0,1V testsignal

H.SIG.001: Testfrekvens: 100 kHz sinussignal med maksimal amplitude 0,1V peak-to-peak

H.PRC.001: Opløsning: 1 mΩ (mindste målbare ændring)

H.PRC.002: Præcision: ≤5% af målte værdi over 0-10 Ω område
------------------------------------------------------------------------------------------------------------------------------
2.2 Antagelser og begrænsninger
------------------------------------------------------------------------------------------------------------------------------
H.LIM.001: Måleobjekt: Elektrolytkondensatorer i aktive/passive kredsløb

H.LIM.002: Signalbegrænsning: ≤0,1V for at undgå halvlederaktivering

H.LIM.003: Temperaturområde: 15-25°C (ingen kompensation)

S.LIM.001: Kalibrering: Kræver genprogrammering af firmware
------------------------------------------------------------------------------------------------------------------------------
2.3 Klassifikationssystem
------------------------------------------------------------------------------------------------------------------------------
H: Hardwarekrav (H.xxx.xxx)

S: Softwarekrav (S.xxx.xxx)

D: Dokumentationskrav (D.xxx.xxx)

T: Testkrav (T.xxx.xxx)

P: Produktionskrav (P.xxx.xxx)
==============================================================================================================================
§3. Detaljerede konstruktionskrav
==============================================================================================================================
------------------------------------------------------------------------------------------------------------------------------
3.1 Hardwarekonstruktionskrav
------------------------------------------------------------------------------------------------------------------------------
H.GEN.001: DDS-generator
Komponent: AD9850 125 MHz DDS synthesizer

Konfiguration: 100 kHz ren sinus, 0° fase

Frekvensstabilitet: <100 ppm

Interface: Parallelt eller serielt (konfigurerbart)

Forsyning: 5V ±5%

H.GEN.002: Buffer og attenuator
Buffer: Rail-to-rail opamp i voltage follower

Potentiometer: Multiturn præcisions, 10-omdrejninger

Maksimal udgang: 0,1V p-p ved testprobene

H.CPL.001: AC-kobling og spændingsdeler
Koblingskondensator: 10 µF lav-ESR, 50V minimum

Præcisionsmodstand: 10 Ω ±0,1%, <50 ppm/°C

Kelvin-tilslutning: Fire separate ledere til DUT

H.AMP.001: Differentialforstærker
Forstærkning: 47x ±0,5%

Opamp: Rail-to-rail, lavstøj, CMRR >90 dB @ 100 kHz

Båndbredde: ≥1 MHz ved forstærkning 47

Indgangsimpedans: ≥10 MΩ

H.REC.001: Præcisionsensretter
Topologi: Superdiode med to rail-to-rail opamps

Dioder: Schottky-dioder (1N5817 eller tilsvarende)

Spændingsfald: <15 mV @ 100 kHz

Linearitet: >99,9% over dynamisk område

H.FLT.001: Lavpasfilter
Type: 3. ordens Sallen-Key Butterworth aktivt filter

Cutoff-frekvens (fc): 100 Hz ±1%

Stopband-frekvens (fs): 10 kHz

Stopband-dæmpning: ≥40 dB @ 10 kHz

Opamp: Rail-to-rail, lav offset (<1 mV)

DC-output ripple: <500 µV RMS

Komponentværdier (beregnet ud fra specifikationer):

R1 = R2 = R3 = 1,59 kΩ (1% tolerance)

C1 = 1 µF, C2 = 100 nF, C3 = 10 nF (filmkondensatorer)

H.ADC.001: Analog-til-digital konvertering
Konverter: ADS1115 16-bit ΔΣ ADC

PGA-indstillinger: 4x, 8x, 16x forstærkning

Reference: Intern 2,048V ±0,05%

Interface: I2C @ 400 kHz

Sample rate: 860 SPS maksimum

H.MCU.001: Mikrokontroller og periferi
Processor: ESP32-WROOM-32

Display: 16x2 LCD med I2C backpack (Adafruit kompatibel)

Knapper: 2x taktile med intern pull-up

Seriel interface: USB-C til seriel konverter

H.PWR.001: Strømforsyningssystem
H.PWR.001.1: Input: USB-C 5V @ 500 mA minimum

H.PWR.001.2: Hovedregulator: 3,3V LDO @ 300 mA (ESP32, opamps, ADS1115)

H.PWR.001.3: Negativ forsyning: Switched capacitor konverter 
(ICL7660 eller tilsvarende) genererer -5V til opamps

H.PWR.001.4: Levelkonverter: Bidirektionel 3,3V↔5V til AD9850 kommunikation

H.PWR.001.5: Decoupling: 100 nF keramisk + 10 µF tantal ved hver IC

H.PWR.001.6: AGND/DGND: Separate stjerner med enkelt forbindelsespunkt

H.PCB.001: Printpladedesign
H.PCB.001.1: Lag: 2-lags FR-4, 1,6 mm tykkelse

H.PCB.001.2: Spor/rum: Minimum 0,2 mm/0,2 mm for signal

H.PCB.001.3: Masseplaner: Komplet masseplan på begge sider

H.PCB.001.4: EMI-beskyttelse: Gardering omkring analoge signaler

H.PCB.001.5: ESD-beskyttelse: TVS-dioder på alle eksterne forbindelser

H.PCB.001.6: Routing: Analog og digital separation med 5 mm minimum afstand

H.PCB.001.7: Probeforbindelser: Gulvstående 4-pol Kelvin-socket

H.MEC.001: Mekanisk design
H.MEC.001.1: Kabinet: ABS plast med EM-afskærmning

H.MEC.001.2: Prober: 4x isolerede kelvin-prober med spidse tip

H.MEC.001.3: Køling: Naturlig konvection - ingen aktive elementer

H.MEC.001.4: Dimensioner: Maksimalt 100x150x50 mm
------------------------------------------------------------------------------------------------------------------------------
3.2 Softwarekonstruktionskrav
------------------------------------------------------------------------------------------------------------------------------
S.ARC.001: Overordnede arkitekturkrav
S.ARC.001.1: Sprog: Arduino C++ (C++14 kompatibel)

S.ARC.001.2: Udviklingsmiljø: Arduino IDE 2.x eller PlatformIO

S.ARC.001.3: Paradigme: Struktureret programmering (ingen klasser)

S.ARC.001.4: Filstruktur: En .ino fil med alle moduler

S.ARC.001.5: Hukommelse: Statisk allokering, ingen malloc/free

S.HAL.001: Hardware Abstraction Layer
S.HAL.001.1: hal_ad9850: DDS-kontrol (frekvens, amplitude, fase)

S.HAL.001.2: hal_ads1115: ADC-læsning og PGA-kontrol

S.HAL.001.3: hal_lcd: LCD-display via I2C (Adafruit-bibliotek)

S.HAL.001.4: hal_buttons: Knapaflæsning med debounce (statemaskine)

S.HAL.001.5: hal_serial: Seriel kommunikationsinitialisering

S.ADC.001: ADC-målingssystem
S.ADC.001.1: adc_read_single(): Enkeltmåling med specificeret PGA

S.ADC.001.2: adc_read_oversampled(): 64x oversampling + middling

S.ADC.001.3: adc_auto_range(): Automatisk PGA-valg baseret på signalstyrke

S.ADC.001.4: adc_calibrate(): Kalibreringsrutine (kræver genprogrammering)

S.ESR.001: ESR-beregningsmodul
S.ESR.001.1: Datastruktur: ESR_tables[3][30] i PROGMEM

S.ESR.001.2: esr_get_table_index(): Returner tabel baseret på PGA

S.ESR.001.3: esr_interpolate(): Lineær interpolation mellem tabelværdier

S.ESR.001.4: esr_calculate(): Hovedberegningsfunktion med validering

S.DSP.001: Display og brugergrænseflade
S.DSP.001.1: Tilstande: STATE_RAW_ADC og STATE_ESR_RESULT

S.DSP.001.2: display_init(): LCD-initialisering

S.DSP.001.3: display_raw_adc(): Vis rå ADC-værdier til kalibrering

S.DSP.001.4: display_esr_result(): Vis ESR, PGA og ADC-værdi

S.DSP.001.5: display_update(): Opdater baseret på tilstand

S.SCP.001: SCPI-kommunikationsmodul
S.SCP.001.1: Kommandoer: *IDN?, MEASure:ESR?, SYSTem:PRESet, DISPlay:MODE, 
             SYSTem:COMMunication

S.SCP.001.2: scpi_parser(): Parse indkommende kommandoer

S.SCP.001.3: scpi_execute(): Udfør kommandoer

S.SCP.001.4: scpi_response(): Send svar (maks. 100 ms respons)

S.WDG.001: Watchdog og fejlhåndtering
S.WDG.001.1: Hardware watchdog: ESP32 indbygget watchdog (timeout 3 sekunder)

**S.WDG.001.2:wdg_reset(): Reset watchdog i main loop

S.WDG.001.3: Fejllogging: Log fejl til seriel port med tidsstempel

S.WDG.001.4: System reset: Automatisk reset ved kritisk fejl

S.PER.001: Ydeevnekrav
S.PER.001.1: Målecyklus: ≤100 ms (inklusive oversampling)

S.PER.001.2: Display opdatering: ≤50 ms

S.PER.001.3: SCPI respons: ≤10 ms for enkelte kommandoer

S.PER.001.4: Knaprespons: ≤20 ms
------------------------------------------------------------------------------------------------------------------------------
3.3 Dokumentationskrav
------------------------------------------------------------------------------------------------------------------------------
D.GEN.001: Generel dokumentation
D.GEN.001.1: Tekstsprog: Formfuldendt dansk med korrekt retskrivning

D.GEN.001.2: Struktur: Logisk opdeling i afsnit med nummerering

D.COD.001: Kodedokumentation
D.COD.001.1: Linjekommentarer: Alle kodelinier efterfølges af //-kommentar

D.COD.001.2: Funktionskommentarer: Doxygen-formateret blok før hver funktion

D.COD.001.3: Modulbeskrivelse: Kommentarblok i hvert moduls start

D.COD.001.4: Variabeldokumentation: Alle globale variabler dokumenteres

D.DOX.001: Doxygen-specifikke krav
D.DOX.001.1: Bruge alle relevante Doxygen-kommandoer: @brief, @param, @return, @note, @warning, @see

D.DOX.001.2: Generere HTML og PDF dokumentation

D.DOX.001.3: Inkludere flowdiagrammer for komplekse algoritmer

D.TEC.001: Teknisk dokumentation
D.TEC.001.1: Skematisk diagram: Fuldt annoteret med komponentværdier

D.TEC.001.2: BOM: Komplet komponentliste med leverandøroplysninger

D.TEC.001.3: PCB-layout: Alle lag vises med annotations

D.TEC.001.4: Kalibreringsvejledning: Trin-for-trin procedure
------------------------------------------------------------------------------------------------------------------------------
3.4 Testkrav
------------------------------------------------------------------------------------------------------------------------------
T.UNT.001: Modultests
T.UNT.001.1: HAL-moduler: Test hver driver isoleret

T.UNT.001.2: ADC-modul: Test oversampling og PGA-skift

T.UNT.001.3: ESR-modul: Test interpolation med kendte værdier

T.UNT.001.4: SCPI-modul: Test alle kommandoer og fejltilstande

T.INT.001: Integrationstests
T.INT.001.1: Hardware/software integration: Test komplet målekæde

T.INT.001.2: Display-integration: Test alle visningstilstande

T.INT.001.3: SCPI-integration: Test seriel kommunikation ende-til-ende

T.SYS.001: Systemtests
T.SYS.001.1: Præcisionstest: Mål kendte modstande (0,1 Ω til 10 Ω)

T.SYS.001.2: In-circuit test: Test på printplade med parallelle komponenter

T.SYS.001.3: Temperaturtest: Karakterisér drift over 15-25°C

T.SYS.001.4: Strømforbrugstest: Mål strømforbrug i alle tilstande

T.ACC.001: Accepttests
T.ACC.001.1: Præcision: Verificér 5% nøjagtighed over hele området

T.ACC.001.2: Opløsning: Verificér 1 mΩ opløsning

T.ACC.001.3: Sikkerhed: Verificér maksimalt 0,1V p-p testsignal

T.ACC.001.4: Robusthed: Test ESD- og EMI-immunitet

3.5 Produktionskrav
P.PCB.001: PCB-produktion
P.PCB.001.1: Materiale: FR-4, 1,6 mm, 1 oz kobber

P.PCB.001.2: Overfladebehandling: HASL eller ENIG

P.PCB.001.3: Sølvmaskering: Over alle udsatte kobberflader

P.PCB.001.4: Testpoint: Inkluder testpunkter til alle kritiske signaller

P.ASS.001: Sammensætning
P.ASS.001.1: Loddeproces: Bølgelodning eller håndlodning

P.ASS.001.2: Inspektion: Visuel inspektion efter IPC-A-610 klasse 2

P.ASS.001.3: Rensing: Fjern fluxrester efter lodning

P.TST.001: Produktionstest
P.TST.001.1: In-circuit test: Test alle komponentforbindelser

P.TST.001.2: Funktionstest: Test komplet systemfunktionalitet

P.TST.001.3: Kalibrering: Indledende kalibrering med referencemodstande

P.QUAL.001: Kvalitetskrav
P.QUAL.001.1: Fejlrate: <1% ved sluttest

P.QUAL.001.2: Dokumentation: Fuldt dokumenteret produktionsproces

P.QUAL.001.3: Sporbarhed: Serienumre på alle enheder
------------------------------------------------------------------------------------------------------------------------------
§3.6 USE-CASES OG SCENARIER
------------------------------------------------------------------------------------------------------------------------------
3.6.1 HOBBYBRUG (U.HOB.001)
------------------------------------------------------------------------------------------------------------------------------
SCENARIO: Entusiastisk hobbyelektroniker reparerer vintage forstærker eller bygger eget kredsløb.

BRUGERPROFIL: Uerfaren til moderat erfaren, begrænset adgang til professionelt udstyr

TYPISK ANVENDELSE:

Fejlfinding af elektrolytkondensatorer i printplader

Verifikation af nyindkøbte kondensatorer før montering

Periodisk vedligeholdelse af eget udstyr

KRITISKE KRAV:

Nem og intuitiv brug (H.MEC.001.2, S.DSP.001.1)

Sikker in-circuit måling uden risiko for skade (H.LIM.002)

Lav pris og vedligeholdelsesfri drift
------------------------------------------------------------------------------------------------------------------------------
3.6.2 SERVICEVÆRKSTED (U.SER.001)
------------------------------------------------------------------------------------------------------------------------------
SCENARIO: Professionelt reparationsværksted servicerer elektronikudstyr for kunder.

BRUGERPROFIL: Erfaren tekniker, rutinepræget arbejdsgang, tidspres

TYPISK ANVENDELSE:

Hurtig diagnostik af strømforsyningsenheder

Verifikation af reparationsarbejde

Dokumentation af måleresultater til kunderapporter

KRITISKE KRAV:

Hurtig målecyklus ≤100 ms (S.PER.001.1)

Robust konstruktion mod daglig brug (H.MEC.001.1)

SCPI interface til automatisering (S.SCP.001.1)

Høj pålidelighed og repeterbarhed (H.PRC.002)

------------------------------------------------------------------------------------------------------------------------------
3.6.3 UNDERVISNING - TEKNISKE SKOLER (U.EDU.001)
------------------------------------------------------------------------------------------------------------------------------
SCENARIO: Teknisk skole med elektroniklaboratorium til grundlæggende undervisning.

BRUGERPROFIL: Studerende med varierende kompetencer, underviser som supervisor

TYPISK ANVENDELSE:

Laboratorieøvelser om kondensatorers egenskaber

Demonstrering af ESR-begrebet og dets praktiske betydning

Fejlfinding som del af projektarbejde

KRITISKE KRAV:

Sikkerhed først (H.SIG.001, H.LIM.002)

Pædagogisk visning af både rå data og beregnede værdier (S.DSP.001.3-4)

Modstandsdygtig konstruktion mod uerfaren håndtering (H.PCB.001.5)

Dokumentation af måleprincipper (D.TEC.001.4)
------------------------------------------------------------------------------------------------------------------------------
3.6.4 UNDERVISNING - INGENIØRUDDANNELSER (U.ENG.001)
------------------------------------------------------------------------------------------------------------------------------
SCENARIO: Universitetsniveau ingeniøruddannelse med fokus på komponentkarakterisering.

BRUGERPROFIL: Avancerede studerende, fokus på måleteori og nøjagtighed

TYPISK ANVENDELSE:

Karakterisering af komponenters temperatur- og frekvensafhængighed

Validering af teoretiske modeller mod praktiske målinger

Forskningsorienterede projekter med præcisionskrav

KRITISKE KRAV:

Høj nøjagtighed ≤5% (H.PRC.002)

Opløsning 1 mΩ (H.PRC.001)

SCPI interface til datalogning (S.SCP.001.1)

Dokumentation af kalibreringsmetoder (D.TEC.001.4)
------------------------------------------------------------------------------------------------------------------------------
3.6.5 FORSKNING/UDVIKLING (U.RND.001)
------------------------------------------------------------------------------------------------------------------------------
SCENARIO: Forskningslaboratorium eller R&D afdeling i elektronikvirksomhed.

BRUGERPROFIL: Specialister med høj ekspertise, fokus på metrologi

TYPISK ANVENDELSE:

Karakterisering af nye kondensatorteknologier

Levetidstestning og aldringseksperimenter

Udvikling af testprocedurer for produktionskvalitetssikring

KRITISKE KRAV:

Højeste nøjagtighed og reproducerbarhed (H.PRC.002)

Automatiseringsmuligheder via SCPI (S.SCP.001.1)

Dokumentation af måleusikkerheder (D.TEC.001.4)

Kompatibilitet med laboratoriemiljøer og eksterne instrumenter
------------------------------------------------------------------------------------------------------------------------------
§3.7 MILJØKRAV
------------------------------------------------------------------------------------------------------------------------------
3.7.1 LAGRINGSBETINGELSER (E.STO.001)
------------------------------------------------------------------------------------------------------------------------------
KRAV FOR OPBEVARING VED IKKE-BRUG:

Temperaturområde: -10°C til +60°C (E.STO.001.1)

Relativ luftfugtighed: 10% til 90% ikke-kondenserende (E.STO.001.2)

Maksimal lagringstid uden brug: 5 år uden yderligere kalibrering (E.STO.001.3)

ESD-beskyttet opbevaring: Instrumentet skal opbevares i ESD-sikker pose eller beholder (E.STO.001.4)
------------------------------------------------------------------------------------------------------------------------------
3.7.2 TRANSPORT OG HÅNDTERING (E.TRA.001)
------------------------------------------------------------------------------------------------------------------------------
KRAV FOR TRANSPORT MELLEM LOKATIONER:

Stødtolerance: Overlevelse af fald fra 1 meter højde på hårdt underlag (E.TRA.001.1)

Vibrationstolerance: 5-500 Hz, 1g RMS, 1 time per akse (E.TRA.001.2)

Temperatur under transport: -20°C til +70°C (E.TRA.001.3)

ESD-beskyttelse under transport: Instrumentet skal transporteres i ESD-sikker emballage (E.TRA.001.4)
------------------------------------------------------------------------------------------------------------------------------
3.7.3 LEVETID OG ALDRING (E.LIF.001)
------------------------------------------------------------------------------------------------------------------------------
FORVENTET LEVETID UNDER NORMAL BRUG:

Mekanisk levetid: Minimum 50.000 målinger (E.LIF.001.1)

Elektronisk levetid: Minimum 10.000 driftstimer (E.LIF.001.2)

Kalibreringsinterval: 12 måneder under normal brug eller ved temperaturudsving >10°C (E.LIF.001.3)

Degradationskriterier: Instrumentet betragtes som udtjent når:

Nøjagtigheden falder til >10% (E.LIF.001.4)

Testsignalet afviger >20% fra 0,1V p-p (E.LIF.001.5)

ADC eller DDS-komponenter fejler (E.LIF.001.6)
------------------------------------------------------------------------------------------------------------------------------
3.7.4 EM-BALLAGE OG HÅNDTERING (E.EMB.001)
------------------------------------------------------------------------------------------------------------------------------
KRAV TIL EMBALLAGE OG UDREKNING:

ESD-beskyttelse: Alle komponenter skal leveres i ESD-sikre poser/beholdere (E.EMB.001.1)

Fugtbeskyttelse: Silicagel-posninger ved længere opbevaring (E.EMB.001.2)

Mekanisk beskyttelse: Minimum 2 cm skumbespænsning alle sider (E.EMB.001.3)

Brugsanvisning på emballage: Klare ikoner for ESD-følsomhed og håndtering (E.EMB.001.4)

Genbrugsvenlig emballage: Minimum 80% af emballagen skal være genanvendelig eller genbrugelig (E.EMB.001.5)
------------------------------------------------------------------------------------------------------------------------------
3.7.5 MILJØPÅVIRKNING OG AFFALDSHÅNDTERING (E.ENV.001)
------------------------------------------------------------------------------------------------------------------------------
KRAV TIL MILJØVENLIG DESIGN OG BORTSKAFFELSE:

RoHS-kompatibilitet: Alle komponenter skal overholde RoHS direktiv 2011/65/EU (E.ENV.001.1)

REACH-kompatibilitet: Ingen SVHC-stoffer over 0,1% vægtprocent (E.ENV.001.2)

Affaldsklassificering: WEEE kategori 3 - IT og telekommunikationsudstyr (E.ENV.001.3)

Demontagevejledning: Skitse for nem demontage til genbrug/affaldssortering (E.ENV.001.4)

Forventet energiforbrug: <1W i standby, <3W under drift (E.ENV.001.5)
==============================================================================================================================
§4. Epistemiske begrænsninger
==============================================================================================================================
H.UNC.001: Signalintegritet: 5% præcision forudsætter optimal PCB-layout med korrekt grounding og afskærmning. 
Afvigelser kan påvirke nøjagtigheden med op til 2%.

H.UNC.002: Komponenttolerance: Samlet nøjagtighed afhænger af præcisionsmodstandens tolerance (<0,1%) og 
temperaturkoefficient (<50 ppm/°C).

S.UNC.001: Software linearitet: Interpolationsnøjagtigheden antager lineært respons mellem tabelpunkterne. 
Reelt respons kan afvige med op til 0,5%.

H.UNC.003: In-circuit påvirkning: Parallelle impedanser i testet kredsløb kan påvirke målingen. 
Påvirkningen er ukvantificerbar uden kendskab til det specifikke kredsløb.
==============================================================================================================================
§5. Manglende information til implementering
==============================================================================================================================
H.MIS.001: Specifikke komponentmodeller: Opamp-modeller, potentiometertype, Schottky-dioder, 
switched capacitor IC, LDO-regulator.

H.MIS.002: PCB-layout detaljer: Specifik routing, komponentplacering, guard ring design.

T.MIS.001: Kalibreringsudstyr: Præcise referencemodstande (0,01 Ω til 10 Ω) med dokumenteret nøjagtighed.

D.MIS.001: Testprotokoller: Detaljerede procedure for hver testtype.

P.MIS.001: Produktionsdokumentation: Manufacturing files (Gerber, drill, pick-and-place).
==============================================================================================================================
§6. Praktisk implementering
==============================================================================================================================
------------------------------------------------------------------------------------------------------------------------------
6.1 Implementeringsfaser
------------------------------------------------------------------------------------------------------------------------------
Fase 1 (Prototype): Breadboard validering af signalkæde

Fase 2 (PCB-design): 2-lags PCB med EMI/ESD-beskyttelse

Fase 3 (Firmware): Arduino C++ implementering med modultest

Fase 4 (Integration): Systemintegration og test

Fase 5 (Kalibrering): Tabelgenerering og validering
------------------------------------------------------------------------------------------------------------------------------
6.2 Risikohåndtering
------------------------------------------------------------------------------------------------------------------------------
Signalstøj: Implementer guarding og afskærmning på PCB

Software reliability: Watchdog timer og omfattende fejlhåndtering

Termisk drift: Karakterisér og kompensér i software hvis nødvendigt

ESD: TVS-dioder på alle eksterne forbindelser
------------------------------------------------------------------------------------------------------------------------------
6.3 Vedligeholdelseskrav
------------------------------------------------------------------------------------------------------------------------------
Fejlfinding: Diagnostiske SCPI-kommandoer

Opdatering: Firmwareopdatering via USB-C

Kalibrering: Dokumenteret procedure med 6-måneders interval
==============================================================================================================================
§7. Referencer
==============================================================================================================================
7.1 Referencekrav
H.REF.001: AD9850 Datasheet, Analog Devices

H.REF.002: ADS1115 Datasheet, Texas Instruments

H.REF.003: ESP32 Technical Reference Manual

S.REF.001: Arduino Language Reference

D.REF.001: Doxygen Manual

T.REF.001: IPC-A-610 Acceptability of Electronic Assemblies



Bilag F: Hardwarekonstruktions rapport

==============================================================================================================================
|															     |
|			Hardwarekonstruktionsrapport for In-Circuit ESR-meter						     |
|															     |
==============================================================================================================================
| DOKUMENT ID:	HWKONS-ESR-MIL-001											     |
| DATO:		19-01-25												     |
| VERSION:	1.00													     |
| SYSTEM:	INCIRCUIT ESR METER											     |
| FORFATTER:	Jan Engelbrecht Pedersen										     |
==============================================================================================================================
§1. Præcis sammenfatning
==============================================================================================================================
Denne rapport specificerer hardwarekonstruktionen til et in-circuit ESR-meter baseret på kravspecifikation SRS-ESR-MIL-001. 
Systemet implementerer 100 kHz sinustest med 0,1V amplitude (H.SIG.001) for sikker in-circuit måling af ESR i området 
0-10 Ω (H.ESR.001) med 1 mΩ opløsning (H.PRC.001) og 5% præcision (H.PRC.002). 
Konstruktionen implementerer bufferstadium med operationsforstærkeren 
TS3V902 (3V rail-to-rail CMOS dual operational amplifier i DIP14-case) (H.GEN.002),
 differentialforstærker med én operationsforstærker TS3V902 (H.AMP.001), superdiode-ensretter med to operationsforstærkere 
TS3V902 (H.REC.001), tredjeordens Sallen-Key Butterworth-filter med operationsforstærkeren TS3V902 (H.FLT.001) og 
ADS1115 ADC (H.ADC.001). PCB-designet implementerer 2-lags layout med EMI/EMC/ESD-beskyttelse (H.PCB.001) og 
switched capacitor negativ forsyning (H.PWR.001.3).
==============================================================================================================================
§2. Definitioner og præcisering
==============================================================================================================================
2.1 Reference til kravspecifikation
Rapporten refererer til kravspecifikation SRS-ESR-MIL-001 version 1.00 med fuld implementering af alle hardwarekrav (H-krav). 
Specifikke kravkoder citeres ved relevante konstruktionsbeskrivelser.
------------------------------------------------------------------------------------------------------------------------------
2.2 Operationsforstærker-konfigurationer
Buffer: Voltage follower konfiguration med TS3V902 operationsforstærkeren (H.GEN.002)

Differentialforstærker: En operationsforstærker TS3V902 i differentiel forstærkerkonfiguration (H.AMP.001)

Superdiode: To operationsforstærkere TS3V902 i præcisionshelbølgeensretter-konfiguration (H.REC.001)

Lavpasfilter: Operationsforstærkeren TS3V902 i Sallen-Key konfiguration (H.FLT.001)
==============================================================================================================================
§3. Faglig analyse
==============================================================================================================================
3.1 Teoretisk fundament og kravopfyldelse
Dette er veletableret viden. In-circuit ESR-måling ved 100 kHz undgår kondensatorens reaktans ved at vælge en frekvens 
hvor den kapacitive reaktans er ubetydelig sammenlignet med ESR-værdier, hvilket opfylder H.SIG.001 og H.ESR.001.

Ifølge etableret praksis implementeres Kelvin-måling (fire-leder) for at eliminere fejl fra ledningsmodstand og 
kontaktmodstand, hvilket er kritisk for opfyldelse af H.PRC.001 (1 mΩ opløsning) og H.PRC.002 (5% præcision).
------------------------------------------------------------------------------------------------------------------------------
3.2 Signalkædedesign med kravreferencer
______________________________________________________________________________________________________________________________
3.2.1 DDS-generator og buffer (H.GEN.001, H.GEN.002)
Implementeringen opfylder H.GEN.001 gennem AD9850 DDS-generator konfigureret til 100 kHz ren sinus med 0° fase og 
frekvensstabilitet under 100 ppm. H.GEN.002 opfyldes gennem buffer implementeret med operationsforstærkeren TS3V902 i 
voltage follower-konfiguration med multiturn præcisionspotentiometer for finjustering til 0,1V p-p ved testprobene.

GIVEN: Krav om 100 kHz sinus med maksimalt 0,1V amplitude (H.SIG.001)
SØGT: Implementering af DDS og buffer
BEVIS/ARGUMENTATION:
Trin 1: AD9850 DDS genererer 100 kHz digitalt (H.GEN.001)
Trin 2: Buffer med operationsforstærkeren TS3V902 isolerer DDS fra belastning (H.GEN.002)
Trin 3: Potentiometer justerer amplitude til 0,1V p-p (H.GEN.002)
KONKLUSION: Signalkæde sikrer stabilt testsignal under sikkerhedsgrænse (H.LIM.002)
------------------------------------------------------------------------------------------------------------------------------
3.2.2 Målekreds og Kelvin-forbindelser (H.CPL.001)
H.CPL.001 opfyldes gennem 10 µF lav-ESR koblingskondensator med 10 Ω præcisionsmodstand (±0,1%, <50 ppm/°C) og fire separate 
ledere til DUT i Kelvin-konfiguration. Denne implementering sikrer korrekt AC-kobling og eliminering af ledningsmodstand.
------------------------------------------------------------------------------------------------------------------------------
3.2.3 Differentialforstærker (H.AMP.001)
H.AMP.001 opfyldes gennem differentialforstærker implementeret med én operationsforstærker TS3V902 i differentiel 
forstærkerkonfiguration med forstærkning 47× ±0,5%, CMRR >90 dB ved 100 kHz og indgangsimpedans ≥10 MΩ. 
Denne konfiguration måler spændingsfaldet over referenceserie-modstanden med høj common-mode underdrukning.
------------------------------------------------------------------------------------------------------------------------------
3.2.4 Superdiode-ensretter (H.REC.001)
H.REC.001 opfyldes gennem superdiode-ensretter implementeret med to operationsforstærkere TS3V902 i 
præcisionshelbølgeensretter-konfiguration med Schottky-dioder (1N5817). 
Konfigurationen reducerer diodens spændingsfald til under 15 mV ved 100 kHz med linearitet >99,9% over dynamisk område.
------------------------------------------------------------------------------------------------------------------------------
3.2.5 Lavpasfilter (H.FLT.001)
H.FLT.001 opfyldes gennem tredjeordens Sallen-Key Butterworth aktivt filter implementeret med operationsforstærkeren 
TS3V902 i Sallen-Key konfiguration med cutoff-frekvens 100 Hz ±1%, stopband dæmpning ≥40 dB ved 10 kHz og DC-output 
ripple under 500 µV RMS. Komponentværdier beregnes til R1=R2=R3=1,59 kΩ (1%), C1=1 µF, C2=100 nF, C3=10 nF (filmkondensatorer). 
Udgangen af dette filter beskyttes med to Schottky-dioder (f.eks. BAT54) inden signalet føres til ADC'en: 
Den ene diodes anode forbindes fra filterudgangen til +3.2V forsyningen, og den anden diodes katode forbindes til 
filterudgangen med dens anode forbundet til stel (AGND). Denne konfiguration sikrer klemning (clamping) 
af signalet for at beskytte ADC-indgangen mod utilsigtede overspændinger.
------------------------------------------------------------------------------------------------------------------------------
3.2.6 ADC-system (H.ADC.001)
H.ADC.001 opfyldes gennem ADS1115 16-bit ΔΣ ADC med PGA-indstillinger 4×, 8×, 16× forstærkning, intern 2,048V 
reference ±0,05% og I2C interface ved 400 kHz. ADC-indgangen, som modtager signalet fra det aktive Sallen-Key filter, 
er forud for indgangen beskyttet af de to Schottky-dioder som beskrevet i §3.2.5. 
Denne implementering sikrer nødvendig opløsning for 1 mΩ måling ved 10 Ω fuld skala og robusthed mod transiente.
------------------------------------------------------------------------------------------------------------------------------
3.3 Strømforsyningsdesign med kravreferencer
3.3.1 Positive forsyninger (H.PWR.001.1, H.PWR.001.2, H.PWR.001.4)
H.PWR.001.1 opfyldes gennem USB-C input med 5V @ 500 mA minimum. H.PWR.001.2 opfyldes gennem 3,3V LDO regulator til ESP32, 
operationsforstærkere TS3V902 og ADS1115. H.PWR.001.4 opfyldes gennem bidirektionel levelkonverter mellem 3,3V logik 
og 5V AD9850 kommunikation.
------------------------------------------------------------------------------------------------------------------------------
3.3.2 Negativ forsyning (H.PWR.001.3)
H.PWR.001.3 opfyldes gennem switched capacitor konverter (ICL7660 eller tilsvarende) der genererer -5V til 
operationsforstærkere TS3V902 for rail-to-rail operation. Decoupling med 100 nF keramisk + 10 µF tantal ved 
hver IC opfylder H.PWR.001.5.
------------------------------------------------------------------------------------------------------------------------------
3.3.3 Grounding (H.PWR.001.6)
H.PWR.001.6 opfyldes gennem separate AGND/DGND stjerner med enkelt forbindelsespunkt for at minimere ground loops og støj.
------------------------------------------------------------------------------------------------------------------------------
3.4 PCB-layout og mekanisk design med kravreferencer
______________________________________________________________________________________________________________________________
3.4.1 PCB-design (H.PCB.001)
H.PCB.001.1 opfyldes gennem 2-lags FR-4 med 1,6 mm tykkelse. 
H.PCB.001.2 opfyldes gennem spor/rum minimum 0,2 mm/0,2 mm for signal. 
H.PCB.001.3 opfyldes gennem komplet masseplan på begge sider. 
H.PCB.001.4 opfyldes gennem EMI-beskyttelse med gardering omkring analoge signaler. 
H.PCB.001.5 opfyldes gennem ESD-beskyttelse med TVS-dioder på alle eksterne forbindelser. 
H.PCB.001.6 opfyldes gennem analog og digital separation med 5 mm minimum afstand. 
H.PCB.001.7 opfyldes gennem gulvstående 4-pol Kelvin-socket til probeforbindelser.
------------------------------------------------------------------------------------------------------------------------------
3.4.2 Mekanisk design (H.MEC.001)
H.MEC.001.1 opfyldes gennem kabinet i ABS plast med EM-afskærmning. 
H.MEC.001.2 opfyldes gennem 4× isolerede kelvin-prober med spidse tip. 
H.MEC.001.3 opfyldes gennem køling ved naturlig konvection uden aktive elementer. 
H.MEC.001.4 opfyldes gennem dimensioner maksimalt 100×150×50 mm.
------------------------------------------------------------------------------------------------------------------------------
3.4.3 EMI/EMC/ESD-beskyttelse
PCB-layoutet implementerer alle industrielle krav til beskyttelse mod EMI, EMC og ESD som specificeret i H.PCB.001, 
inklusive gardering, TVS-dioder, skærmede spor og korrekt grounding.
==============================================================================================================================
§4. Epistemiske begrænsninger
==============================================================================================================================
Signalintegritetsbegrænsninger (H.UNC.001): 5% præcision forudsætter optimal PCB-layout med korrekt grounding og afskærmning. 
Afvigelser kan påvirke nøjagtigheden med op til 2%.

Komponenttolerancebegrænsninger (H.UNC.002): Samlet nøjagtighed afhænger af præcisionsmodstandens tolerance (<0,1%) og 
temperaturkoefficient (<50 ppm/°C).

In-circuit påvirkningsbegrænsninger (H.UNC.003): Parallelle impedanser i testet kredsløb kan påvirke målingen. 
Påvirkningen er ukvantificerbar uden kendskab til det specifikke kredsløb.
==============================================================================================================================
§5. Manglende information til konstruktion
==============================================================================================================================
Specifikke komponentmodeller (H.MIS.001): Opamp-modeller (TS3V902 er specificeret), potentiometertype, 
Schottky-dioder (f.eks. til beskyttelse og ensretter), switched capacitor IC, 
LDO-regulator kræver specifik valg baseret på tilgængelighed og performance.

PCB-layout detaljer (H.MIS.002): Specifik routing, komponentplacering, guard ring design kræver detaljeret PCB-design fase.

Kalibreringsudstyr (T.MIS.001): Præcise referencemodstande (0,01 Ω til 10 Ω) med dokumenteret nøjagtighed kræves for kalibrering.
==============================================================================================================================
§6. Praktisk anvendelse
==============================================================================================================================
6.1 Implementeringsfaser med kravopfyldelse
Fase 1 (Prototype): Breadboard validering af signalkæde med fokus på H.GEN.001, H.GEN.002, H.AMP.001, H.REC.001, H.FLT.001 
implementering med TS3V902 operationsforstærkere, inklusive test af beskyttelsesdioder.

Fase 2 (PCB-design): 2-lags PCB med EMI/ESD-beskyttelse implementerer alle H.PCB.001 krav, 
inklusive korrekt placering af de to Schottky-beskyttelsesdioder mellem filter og ADC.

Fase 3 (Produktion og test): PCB-produktion og sammensætning implementerer P.PCB.001 og P.ASS.001 krav.
------------------------------------------------------------------------------------------------------------------------------
6.2 Risikohåndtering relateret til krav
Signalstøjrisiko: Implementering af guarding og afskærmning på PCB adresserer H.PCB.001.4 EMI-beskyttelseskrav.

Software reliability: Watchdog timer implementerer S.WDG.001 krav for systemstabilitet.

Termisk drift: Karakterisering og kompensation adresserer H.UNC.002 komponenttolerancebegrænsninger.

ESD og overspændingsbeskyttelse: TVS-dioder på eksterne forbindelser og Schottky-klemmere på den kritiske analoge signalkæde 
(filter til ADC) implementerer H.PCB.001.5 ESD-beskyttelseskrav og yderligere robusthed.
------------------------------------------------------------------------------------------------------------------------------
6.3 Produktionsovervejelser
Testability (P.PCB.001.4): Inkludering af testpunkter til alle kritiske signaler, herunder på begge sider af 
beskyttelsesdioderne mellem filter og ADC.

Reparabilitet: Standard komponentpakninger (SOIC, SOT-23) fremfor BGA. (Bemærk: TS3V902 anvendes i DIP14-case, dioder i SOT-23)

Kalibrering: Design for nem adgang til kalibreringspotentiometer i overensstemmelse med H.GEN.002.
==============================================================================================================================
§7. Litteratur og reference
==============================================================================================================================
7.1 Referencemateriale
Horowitz, P., & Hill, W. (2015). The Art of Electronics (3. udgave). Cambridge University Press. 
(Operationsforstærker-kredsløb, filterdesign, strømforsyningsdesign)

Williams, J. (2015). Analog Circuit Design: A Tutorial Guide to Applications and Solutions. Elsevier. 
(Præcisionsmåleteknik, superdiode-design, lavstøjs design, indgangsbeskyttelse)

Ott, H. W. (2009). Electromagnetic Compatibility Engineering. John Wiley & Sons. 
(PCB-layout teknikker for EMI/EMC/ESD-beskyttelse)

Kravspecifikation SRS-ESR-MIL-001 version 1.00 (reference for alle H-krav)
------------------------------------------------------------------------------------------------------------------------------
7.2 Nøglekonklusioner
Hardwarekonstruktionen implementerer fuldt alle H-krav fra kravspecifikation SRS-ESR-MIL-001 gennem veldefinerede 
operationsforstærker-konfigurationer med TS3V902 operationsforstærkeren.

Signalkædedesignet opfylder præcisionskrav (H.PRC.001, H.PRC.002) gennem Kelvin-måling, differentiel forstærkning med TS3V902, 
præcisionsfiltering og indbyggede Schottky-dioder til beskyttelse af ADC-indgangen mod overspændinger.

PCB-designet implementerer industrielle EMI/EMC/ESD standarder (H.PCB.001) gennem 2-lags layout med korrekt grounding, 
afskærmning og komponentplacering.

Strømforsyningssystemet opfylder H.PWR.001 krav gennem stabiliseret 3,3V LDO, switched capacitor negativ forsyning til 
TS3V902 operationsforstærkere og korrekt decoupling.

Mekanisk design opfylder H.MEC.001 krav gennem kompakt kabinet med EM-afskærmning og kelvin-prober til præcise målinger.

7.3 Netliste

ESR-METER NETLISTE
Hardware Version 1.00
Kravspec: SRS-ESR-MIL-001

==============================================================================================================================

1. MIKROKONTROLLER: ESP32-WROOM-32 (U1)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   GPIO16     AD9850_W_CLK                   Word clock til AD9850. Output. 3.3V→5V level shifter.
   GPIO17     AD9850_FQ_UD                   Frequency update til AD9850. Output. 3.3V→5V level shifter.
   GPIO18     AD9850_DATA                    Serial data til AD9850. Output. 3.3V→5V level shifter.
   GPIO19     AD9850_RESET                   Reset til AD9850. Output. 3.3V→5V level shifter.
   GPIO21     I2C_SDA                        I2C data line. Open-drain. 4.7kΩ pull-up til 3.3V.
   GPIO22     I2C_SCL                        I2C clock line. Open-drain. 4.7kΩ pull-up til 3.3V.
   GPIO27     BUTTON1                        Knap 1 input. Aktiv lav. 10kΩ+100nF debounce kreds.
   GPIO33     BUTTON2                        Knap 2 input. Aktiv lav. 10kΩ+100nF debounce kreds.
   3.3V       +3.3V                          Strømforsyning fra LDO regulator (U9).
   GND        DGND                           Digital ground.
   EN         RST_NET                        Reset. 10kΩ pull-up til 3.3V, 100nF til GND.

==============================================================================================================================

2. DDS-GENERATOR: AD9850 (U2)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   W_CLK      AD9850_W_CLK                   Word clock input. Fra ESP32 GPIO16 via level shifter.
   FQ_UD      AD9850_FQ_UD                   Frequency update. Fra ESP32 GPIO17 via level shifter.
   DATA       AD9850_DATA                    Serial data input. Fra ESP32 GPIO18 via level shifter.
   RESET      AD9850_RESET                   Reset input. Fra ESP32 GPIO19 via level shifter.
   VCC        +5V                            Strømforsyning fra USB-C input.
   DGND       DGND                           Digital ground.
   AGND       AGND                           Analog ground.
   OUT        DDS_OUT                        Analog output: 100 kHz sinus, ~0.1V p-p efter buffer.

==============================================================================================================================

3. LEVEL SHIFTER (3.3V ↔ 5V) - F.eks. TXB0104

   SIDE       NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   3.3V A     GPIO16                         Forbinder til ESP32 GPIO16.
   5V B       AD9850_W_CLK                   Forbinder til AD9850 W_CLK.
   3.3V A     GPIO17                         Forbinder til ESP32 GPIO17.
   5V B       AD9850_FQ_UD                   Forbinder til AD9850 FQ_UD.
   3.3V A     GPIO18                         Forbinder til ESP32 GPIO18.
   5V B       AD9850_DATA                    Forbinder til AD9850 DATA.
   3.3V A     GPIO19                         Forbinder til ESP32 GPIO19.
   5V B       AD9850_RESET                   Forbinder til AD9850 RESET.
   VCCA       +3.3V                          Strømforsyning 3.3V side.
   VCCB       +5V                            Strømforsyning 5V side.
   GND        DGND                           Ground.

==============================================================================================================================

4. OPERATIONSFORSTÆRKERE: TS3V902 (Dual OpAmp)

   KOMP.      FORBINDELSER                   FUNKTION / KOMPONENTER
   ----------------------------------------------------------------------------
   U3A        Pin 3: DDS_OUT                 Buffer (Voltage Follower). Input fra AD9850.
   (Buffer)   Pin 2: BUF_OUT                 Negative feedback (direkte til pin 1).
              Pin 1: BUF_OUT                 Output til 10µF koblingskondensator.
              Pin 8: +3.3V, Pin 4: -5V       Forsyning. 100nF+10µF decoupling til AGND.
              Pin 5: AGND                    Ground.

   U4A        Pin 3: PROBE_HI_MEAS via R1    Differentialforstærker. R1=1kΩ ±0.1% til pin 3.
   (Diff Amp) Pin 2: PROBE_LO_MEAS via R3    R3=1kΩ ±0.1% til pin 2, R2=47kΩ ±0.1% feedback til pin 1.
              Pin 1: DIFF_OUT                Output. R2=47kΩ til pin 2, R4=47kΩ ±0.1% fra pin 3 til AGND.
              Pin 8: +3.3V, Pin 4: -5V       Forsyning. Decoupling.
              Pin 5: AGND                    Ground.

   U5A, U5B   U5A Pin 3: AGND                Superdiode-ensretter. U5A: Halvbølge. U5B: Fuldbølge.
   (Super-    U5A Pin 2: RECT_IN via R5      R5=10kΩ ±1% fra DIFF_OUT. D1=1N5817 fra pin 1 til pin 2.
    diode)    U5A Pin 1: RECT_HALF           Til D2 anode. D2=1N5817 til R6. R6=10kΩ ±1% til U5B pin 6.
              U5B Pin 5: AGND via R8         R8=10kΩ ±1%.
              U5B Pin 6: RECT_HALF_FILT      Input fra R6. R7=10kΩ ±1% feedback fra pin 7.
              U5B Pin 7: RECT_OUT            Output til filter.
              Forsyning: +3.3V, -5V          Decoupling.
              Ground: AGND

   U6A        Pin 3: FILTER_IN via R9        Sallen-Key lavpasfilter (3. orden). R9=1.59kΩ ±1%. C1=1µF film.
   (Filter)   Pin 2: FILTER_OUT              Negative feedback (direkte til pin 1).
              Pin 1: FILTER_OUT              Output til ADC og beskyttelsesdioder.
              R10=1.59kΩ ±1% til AGND        C2=100nF film, C3=10nF film fra FILTER_IN til AGND.
              Forsyning: +3.3V, -5V          Decoupling.
              Ground: AGND

==============================================================================================================================

5. ADC: ADS1115 (U7)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   VDD        +3.3V                          Strømforsyning. 100nF decoupling til AGND.
   GND        AGND                           Analog ground.
   SDA        I2C_SDA                        I2C data line. 4.7kΩ pull-up til 3.3V.
   SCL        I2C_SCL                        I2C clock line. 4.7kΩ pull-up til 3.3V.
   A0         ADC_IN                         Analog input. Fra FILTER_OUT via beskyttelsesdioder D3, D4.
   A1,A2,A3   AGND                           Ubenyttede inputs. Jordet for støjreduktion.
   ADDR       AGND                           I2C adresse sat til 0x48 (GND).
   ALRT       -                              Ikke brugt.

==============================================================================================================================

6. BESKYTTELSESDIODER FOR ADC INPUT

   DIODE      FORBINDELSER                   FUNKTION
   ----------------------------------------------------------------------------
   D3         Anode: FILTER_OUT              Schottky diode (BAT54). Klemmer signalet til +3.3V for overspænding.
   (BAT54)    Katode: +3.3V
   D4         Anode: AGND                    Schottky diode (BAT54). Klemmer signalet til AGND for underspænding.
   (BAT54)    Katode: FILTER_OUT
   R11        Fra FILTER_OUT til ADC_IN      Valgfri seriemodstand (100Ω ±5%) for strømbegrænsning.

==============================================================================================================================

7. LCD DISPLAY 16x2 I2C (U8)

   PIN        NET/FORBINDELSE                FUNKTION / NOTER
   ----------------------------------------------------------------------------
   VCC        +3.3V                          Strømforsyning. 100nF decoupling.
   GND        DGND                           Ground.
   SDA        I2C_SDA                        I2C data line. Delt med ADS1115.
   SCL        I2C_SCL                        I2C clock line. Delt med ADS1115.
   LED+       +3.3V                          Backlight power. Via 10Ω seriemodstand (valgfri).
   LED-       DGND                           Backlight ground.

==============================================================================================================================

8. KNAPPER

   KNAP       FORBINDELSER                   KOMPONENTER / NOTER
   ----------------------------------------------------------------------------
   SW1        Side 1: GPIO27                 Knap 1 - Display mode skift. Aktiv lav.
   (BUTTON1)  Side 2: DGND                   Intern 10kΩ pull-up i ESP32. Ekstern 10kΩ + 100nF RC debounce.
   SW2        Side 1: GPIO33                 Knap 2 - Communication mode skift. Aktiv lav.
   (BUTTON2)  Side 2: DGND                   Intern 10kΩ pull-up i ESP32. Ekstern 10kΩ + 100nF RC debounce.

==============================================================================================================================

9. STRØMFORSYNING

   KOMP.      FORBINDELSER                   FUNKTION / KOMPONENTER
   ----------------------------------------------------------------------------
   USB-C      VCC: +5V_RAW                   5V input. 10µF elektrolyt + 100nF keramisk decoupling.
   (J1)       GND: DGND                      Ground. CC1,CC2: 5.1kΩ pull-down hver til GND.

   LDO        IN: +5V_RAW                    AMS1117-3.3. Input: 10µF tantal + 100nF keramisk.
   (U9)       OUT: +3.3V                     Output: 22µF tantal + 100nF keramisk.
              GND: DGND

   Negativ    V+: +5V_RAW                    ICL7660. Input: 10µF tantal. OSC: åben for 10kHz.
   Fors.      VOUT: -5V                      Output: 10µF tantal.
   (U10)      GND: DGND                      CAP+, CAP-: 10µF flying capacitor.

==============================================================================================================================

10. MÅLEKREDS OG KELVIN-FORBINDELSER

   KOMP.      FORBINDELSER                   FUNKTION
   ----------------------------------------------------------------------------
   C_couple   BUF_OUT → PROBE_HI_FORCE       10µF lav-ESR elektrolyt. AC-kobling til DUT.
   R_series   PROBE_HI_FORCE → PROBE_LO_FORCE 10Ω ±0.1% præcisionsmodstand. Referenceserie-modstand.
   Kelvin-    1. PROBE_HI_FORCE → DUT+       Fire-leder (Kelvin) forbindelser:
   forbind.   2. PROBE_HI_MEAS → DUT+        1. Force High. 2. Sense High.
              3. PROBE_LO_FORCE → DUT-       3. Force Low. 4. Sense Low.
              4. PROBE_LO_MEAS → DUT-        (Separate ledere for hver).

==============================================================================================================================

11. GROUNDING SYSTEM

   GROUND     FORBINDELSER                   NOTER
   ----------------------------------------------------------------------------
   AGND       Alle analoge komponenter:      Operationsforstærkere (GND pins), ADC GND, filter komponenter til GND.
              OpAmps, ADC, filter caps.
   DGND       ESP32 GND, LCD GND, knapper,   Digital ground.
              digital IC GND, USB GND.
   Forbindelse AGND og DGND forbindes ved    Enkelt forbindelsespunkt med 0Ω modstand eller ferritperle.
              et enkelt punkt.

==============================================================================================================================

12. KOMPONENT OVERSIGT

   KOMPONENT  VÆRDI/TYPE                     ANTAL   PLACERING / NOTER
   ----------------------------------------------------------------------------
   ESP32      WROOM-32                       1       U1
   AD9850     DDS Generator                  1       U2
   TS3V902    Dual OpAmp (DIP14)             4       U3, U4, U5, U6
   ADS1115    16-bit ADC                     1       U7
   16x2 LCD   I2C Display                    1       U8
   AMS1117-3.3 LDO Regulator                 1       U9
   ICL7660    Negativ spændingskonverter     1       U10
   1N5817     Schottky diode                 2       D1, D2
   BAT54      Schottky diode (dobbelt)       1       D3 (to dioder)
   10µF       Tantal kondensator             6       Decoupling ved IC'er
   22µF       Tantal kondensator             1       LDO output
   100nF      Keramisk kondensator           12      Decoupling
   1µF        Film kondensator               1       C1 i filter
   100nF      Film kondensator               1       C2 i filter
   10nF       Film kondensator               1       C3 i filter
   10µF       Elektrolyt kondensator         1       C_couple (AC-kobling)
   10Ω        Præcisionsmodstand ±0.1%       1       R_series (referenceserie)
   1kΩ        Præcisionsmodstand ±0.1%       2       R1, R3 i diff. forstærker
   47kΩ       Præcisionsmodstand ±0.1%       2       R2, R4 i diff. forstærker
   10kΩ       Modstand ±1%                   4       R5, R6, R7, R8 i superdiode
   1.59kΩ     Modstand ±1%                   2       R9, R10 i filter
   100Ω       Modstand ±5%                   1       R11 (valgfri seriemodstand til ADC)
   4.7kΩ      Modstand ±5%                   2       I2C pull-up
   10kΩ       Modstand ±5%                   2       Knap debounce
   5.1kΩ      Modstand ±5%                   2       USB-C CC pull-down
   Tactile    6x6 mm switch                  2       SW1, SW2
   USB-C      16-pin SMD connector           1       J1
   Level      TXB0104 eller tilsvarende      1       -
   Shifter
   4-pol      Gulvstående socket             1       Kelvin probeforbindelse
   Socket

==============================================================================================================================

13. TESTPUNKTER (TP)

   TP         NET                            FORMÅL
   ----------------------------------------------------------------------------
   TP1        DDS_OUT                        AD9850 output verifikation
   TP2        BUF_OUT                        Buffer output verifikation
   TP3        PROBE_HI_MEAS                  High sense måling
   TP4        PROBE_LO_MEAS                  Low sense måling
   TP5        DIFF_OUT                       Differentialforstærker output
   TP6        RECT_OUT                       Ensretter output
   TP7        FILTER_OUT                     Filter output til ADC (før beskyttelsesdioder)
   TP8        +3.3V                          3.3V rail test
   TP9        -5V                           -5V rail test
   TP10       AGND                           Analog ground test
   TP11       DGND                           Digital ground test

==============================================================================================================================

14. DESIGNNOTER

   • PCB Layout: 2-lags design med komplet masseplan på begge sider.
   • Separering: Analog og digital sektion adskilt med minimum 5 mm.
   • Gardering: Kritiske analoge spor garderet med AGND.
   • ESD Beskyttelse: TVS-dioder på alle eksterne forbindelser (probeforbindelser, USB).
   • Decoupling: 100nF keramisk + 10µF tantal ved hver IC strømforsyning.
   • Strømforbrug: USB-C understøtter op til 500mA. Systemforbrug ~280mA typisk.
   • Firmware: Baseret på kravspecifikation SRS-ESR-MIL-001, dokument SW-ESR-MIL-002.

Bilag G: Apparatkasse konstruktions rapport

==============================================================================================================================
|                                                                                                                            |
|                   Apparatkasse Konstruktionsrapport for In-Circuit ESR-Meter                                               |
|                                                                                                                            |
==============================================================================================================================
| DOKUMENT ID:  MEC-ESR-MIL-001                                                                                              |
| DATO:         20-01-25                                                                                                     |
| VERSION:      1.00                                                                                                         |
| SYSTEM:       IN-CIRCUIT ESR METER                                                                                         |
| FORFATTER:    Jan Engelbrecht Pedersen                                                                                     |
==============================================================================================================================
| REFERENCER:   SRS-ESR-MIL-001, HWKONS-ESR-MIL-001, PCB-ESR-MIL-001                                                         |
==============================================================================================================================

==============================================================================================================================
§1. Præcis sammenfatning
==============================================================================================================================
Denne rapport specificerer design, materialevalg, dimensioner og fabrikationsproces for apparatkassen til In-Circuit 
ESR-meteret.
Kassen er designet til mobil professionel brug med fokus på robusthed, ergonomi og funktionalitet svarende til et større 
håndholdt multimeter. 
Konstruktionen implementerer alle H.MEC.001-krav gennem et todelt design i slagfast ABS-plastic med en integreret,
udfoldelig stabiliseringsfod, EM-afskærmning og fuld adgang til alle nødvendige interface-elementer.
==============================================================================================================================

==============================================================================================================================
§2. Overordnet Designfilosofi & Kravopfyldelse
==============================================================================================================================
2.1 Designmål og brugerbehov
------------------------------------------------------------------------------------------------------------------------------
• Robusthed: Modstandsdygtig mod daglig brug, lette stød og ridser.
• Mobilitet: Let vægt, kompakt formfactor, nem at transportere.
• Funktion: Klart synlige interfacer (display, probestik, knapper, USB).
• Stabilitet: Integreret, udfoldelig fod til stabil placering på bord.
• Professionelt udseende: Rent, industriel æstetik med funktionel tekst.

2.2 Direkte Kravreferencer (fra SRS-ESR-MIL-001)
------------------------------------------------------------------------------------------------------------------------------
• H.MEC.001.1: Kabinet i ABS plast med EM-afskærmning. (Opfyldt via ABS-husk og konduktiv belægning/indlæg).
• H.MEC.001.2: 4x isolerede kelvin-prober med spidse tip. (Faciliteteret via frontpanel-connector).
• H.MEC.001.3: Køling ved naturlig konvection. (Opfyldt via ventilationsåbninger i top/bund).
• H.MEC.001.4: Maks. dimensioner 100x150x50 mm. (Opfyldt med samlet ydre mål på 98x148x45 mm).
==============================================================================================================================

==============================================================================================================================
§3. Materialespecifikationer
==============================================================================================================================
3.1 Hovedmaterialer
------------------------------------------------------------------------------------------------------------------------------
Komponent           Materiale                         Specifikation / Begrundelse
------------------------------------------------------------------------------------------------------------------------------
Hus (Top & Bund)    ABS (Acrylonitril Butadien Styren) Slagfast, let, god overfladekvalitet, nem at sprojsestøbe.
                    Farve: Sort (RAL 9005) eller Mørkegrå.
Stabiliseringsfod   ABS                              Samme materiale for ensartet udseende og stivhed.
Skruer              Rustfrit stål (A2/A4)            M3x6 mm panhead, modstandsdygtig overfor korrosion.
EMI-Afskærmning     Konduktiv silicone/folie eller   Indsprøjtet/indlagt metalnet for at opnå Faraday-bur effekt.
                    Metalliseret belægning
Fødder/Gummiunderlæg Silikone eller TPE             Sort, for at forhindre skriden og beskytte underlag.

3.2 Materialegenskaber og Standarder
------------------------------------------------------------------------------------------------------------------------------
• ABS: UL94-V0 flammehæmmende karakter. God kemisk modstandsdygtighed.
• Overfladebehandling: Mat finish for at minimere fingeraftryk og ridser.
• Miljøkrav: Alle termoplast-komponenter er RoHS og REACH kompatible (E.ENV.001).
==============================================================================================================================

==============================================================================================================================
§4. Komponenter og Dimensioner
==============================================================================================================================
4.1 Komponentoversigt
------------------------------------------------------------------------------------------------------------------------------
1.  Topdel (Cover)
2.  Bunddel (Base) – indeholder PCB-mounts og fods-mekanisme
3.  Stabiliseringsfod – foldbar, integreret i bunddelen
4.  Frontpanel – integreret i topdelen med udstansede åbninger
5.  Bagpanel – integreret i topdelen med USB-C og ventilationsåbninger
6.  Skruer (4x) M3x6 mm
7.  Fødder/Gummiunderlag (4x) – limet på underside af bund

4.2 Kritiske Dimensioner (Alle i mm)
------------------------------------------------------------------------------------------------------------------------------
Samlet Ydre Mål (L x B x H):          148.0 x 98.0 x 45.0
    *Bemærk: Under H.MEC.001.4's grænse på 150x100x50.*

Tydelige Vægtykkelser:
    Top/Bund væg:                     2.5
    Forstærkningsribber:              2.0
    Kantafrunding (ekstern):          R3
    Kantafrunding (intern):           R1.5

Internt Rum (PCB-rum):
    Længde:                           144.0
    Bredde:                            94.0
    Højde (Efter montering af PCB):    ~15.0
    *Giver plads til PCB (1.6mm) + komponenter + luftgab.*

Stabiliseringsfod:
    Længde (udfoldet):                70.0
    Bredde:                           15.0
    Tykkelse:                         4.0
    Rotationsvinkel (udfoldet):       ~60° fra bund

4.3 Åbninger og Interface Placering (Front/Top)
------------------------------------------------------------------------------------------------------------------------------
• Display (LCD 16x2):           Rektangulært vindue: 72.0 x 18.0 mm. Centreret.
• Kelvin Socket (4-pol):        Rundt hul, Ø 10.0 mm, til montering af panelmount socket.
• Knapper (2x):                 Ø 6.0 mm runde huller, 20 mm center-til-center.
• Power/Status LED:             Ø 3.0 mm lille hul.

4.4 Åbninger og Interface Placering (Bag)
------------------------------------------------------------------------------------------------------------------------------
• USB-C Port:                   Rektangulær åbning: 9.0 x 3.5 mm.
• Ventilation:                  Matrix af flere små huller (Ø 2.0 mm) over et areal på ~30x40 mm.

4.5 Monteringspunkter (Bunddel)
------------------------------------------------------------------------------------------------------------------------------
• PCB Stiftsøjler:              4x M3 messing stiftsøjler, højde 10mm. Positioneret til at matche PCB's mounting holes.
• Fod-Mekanismens Aksel:        Integreret aksel/stift, Ø 3.0 mm, til fodens rotation.
• Skrueføringer (Top-skruer):   4x selv-gevindende skruegange integreret i ABS.
==============================================================================================================================

==============================================================================================================================
§5. Konstruktions- og Monteringsdetaljer
==============================================================================================================================
5.1 Stabiliseringsfod Mekanisme
------------------------------------------------------------------------------------------------------------------------------
Design:           Foden formes som en enkelt arm, der drejer om en integreret aksel i bunden.
Mekanisme:        "Snap-fit" friktionslås i både inde- og udfoldet position. Ingen ekstra fjedre eller låse nødvendig.
Arbejdsgang:      Foden presseles let ud fra sin indebyggede lomme ved at trykke på den ene ende.
Materiale:        Samme ABS som huset, med forstærkning omkring akselpunktet.

5.2 EMI-Afskærmning Implementering
------------------------------------------------------------------------------------------------------------------------------
Metode 1 (Foretrukket): Konduktiv belægning sprojsestøbt direkte på indersiden af top- og bunddelen.
Metode 2:               Selvklæbende kobberfolie eller konduktiv film anbragt efter samling.
Forbindelse:            Afskærmningen på top og bund skal være elektrisk forbundet via fjedrende kontakter eller
                        konduktivt gasket omkring skruepunkterne. Afskærmningen jordes til PCB's AGND ved et enkelt punkt.

5.3 Monteringssekvens
------------------------------------------------------------------------------------------------------------------------------
1.  Forberedelse: Monter Kelvin-socket, USB-C port og eventuelle andre panelkomponenter i topdelens åbninger.
2.  PCB Montage: Fastgør PCB'en til de 4 stiftsøjler i bunddelen med M3x6 mm skruer og møtrikker.
3.  Forbindelse: Tilslut display-flexkabel, probekabler og USB-port til PCB.
4.  Afskærmning: Anbring den konduktive afskærmning i topdelen (hvis ikke integreret).
5.  Samling: Placer topdelen over bunddelen, sikrer at alle PCB-forbindelser og knapper passer.
6.  Fastgørelse: Fastgør top- og bunddel med de 4 M3x6 mm skruer gennem huller i bunden og ind i gevindet i toppen.
7.  Afslutning: Lim de 4 silikonefodder på hjørnerne af bunddelen.
==============================================================================================================================

==============================================================================================================================
§6. Fabrikationsproces
==============================================================================================================================
6.1 Sprojsestøbning (Primær Proces)
------------------------------------------------------------------------------------------------------------------------------
Værktøj:           To-delt aluminiumsstøbeforme (en for top, en for bund + fod).
Proces:            ABS granulat smeltes og indsprøjtes under højt tryk i formen.
Efterbehandling:   Afgasing, kantafretning (defashing), og kvalitetskontrol for sink og deformation.
Tid/Enhed:         Cyklustid ca. 45-60 sekunder pr. komponent ved serieproduktion.

6.2 Dekoration og Mærkning
------------------------------------------------------------------------------------------------------------------------------
Teknik:            Silketryk eller laser-markering.
Placering (Front): "ESR METER" logo over display. Enhedssymbol (Ω) ved socket.
Placering (Side/Bag): Modelnr., serienummer, CE-mærkning, fabrikationsdato.
Farve:             Hvid eller lysgrå tekst på mørk baggrund.

6.3 Underleverandører og Kvalitetskontrol
------------------------------------------------------------------------------------------------------------------------------
•   Støbning: Specialiseret plastsprojsestøber.
•   Hardware: Standard M3 skruer og stiftsøjler fra industrileverandør.
•   Gummiunderlag: Silikonefabrikant.
•   Kvalitetskontrol: Stikprøvebaseret visuel og funktionel inspektion af hver batch.
    Tester for: Støbefejl, korrekt dimensionering, funktion af fods-mekanisme.
==============================================================================================================================

==============================================================================================================================
§7. Testbarhed og Vedligeholdelse
==============================================================================================================================
7.1 Adgang til Internt
------------------------------------------------------------------------------------------------------------------------------
Let Adgang:        Fjerning af 4 skruer giver fuld adgang til PCB og interne forbindelser.
Servicevenlig:     Ingen skjulte clips eller komplicerede låse. Alle forbindelser er plug/socket eller loddet.

7.2 Testpunkter (Udefra)
------------------------------------------------------------------------------------------------------------------------------
•   USB-C Port: Bruges til båke strøm, kommunikation og firmware-opdatering.
•   Kelvin Socket: Primær testinterface. Adgang til alle 4 ledere.

7.3 Robusthedstest (E.TRA.001)
------------------------------------------------------------------------------------------------------------------------------
•   Faldtest: Enhed skal overleve fald fra 1 meter på hårdt underlag (konkret) i sin lukkede tilstand.
•   Slidtest: Overfladen skal modstå 1000+ cyklusser af normal håndtering uden synlig slid.
==============================================================================================================================

==============================================================================================================================
§8. Tegnings- og Filreferencer
==============================================================================================================================
8.1 Leverede Designfiler
------------------------------------------------------------------------------------------------------------------------------
•   3D CAD Model:              [Filnavn].STEP / .IGES (Komplet samling)
•   2D Produktionstegninger:   [Filnavn]_Top.pdf, [Filnavn]_Base.pdf, [Filnavn]_Foot.pdf
        - Viser alle kritiske dimensioner, tolerancer og sektionsvisninger.
•   Renderings:                Fotorealistiske billeder fra flere vinkler.
•   BOM (Mekanisk):            Komplet liste over alle ikke-elektroniske komponenter med leverandør-info.

8.2 Tolerancer
------------------------------------------------------------------------------------------------------------------------------
•   Lineære dimensioner:       ±0.2 mm (Standard for sprojsestøbning)
•   Hulpålignelse:             ±0.1 mm
•   Vinkel på fod:             ±2°
==============================================================================================================================

==============================================================================================================================
§9. Opsummering og Konklusion
==============================================================================================================================
9.1 Kravopfyldelse Konklusion
------------------------------------------------------------------------------------------------------------------------------
•   H.MEC.001.1 (ABS + EM-afskærmning): ✓ Opfyldt via ABS-konstruktion med konduktiv belægning.
•   H.MEC.001.2 (Kelvin-prober): ✓ Faciliteteret via dedikeret frontpanel-connector.
•   H.MEC.001.3 (Naturlig konvektion): ✓ Opfyldt via ventilationsåbninger i kabinettet.
•   H.MEC.001.4 (Max. dimensioner): ✓ Samlet mål (148x98x45 mm) er under specifikationen.
•   Mobil brug: ✓ Letvægtsdesign med integreret stabiliseringsfod gør enheden velegnet til feltarbejde.

9.2 Forventet Performance og Holdbarhed
------------------------------------------------------------------------------------------------------------------------------
•   Robusthed: Designet til at modstå daglig professionel brug.
•   Ergonomi: Kompakt størrelse og let vægt gør det nemt at bære og bruge.
•   Thermal: Ventilation sikrer tilstrækkelig køling til alle komponenter under normal drift.
•   Estetik: Rent, industrielt design projicerer professionel kvalitet.

9.3 Fremtidige Iterationer
------------------------------------------------------------------------------------------------------------------------------
•   Materiale: Overvej PC/ABS-blend for endnu højere slagstyrke.
•   IP-vurdering: Design om for at opnå IP54 støv- og sprøjtwandbeskyttelse ved tilføjelse af gaskets.
•   Tilbehør: Design af transporttaske eller beskyttelsescover.
==============================================================================================================================

==============================================================================================================================
§10. Epistemiske Begrænsninger
==============================================================================================================================
•   Fabrikationsvariation: Endelige dimensioner og fit kan variere baseret på udvalgt støberi og værktøjstilstand.
•   Afskærmningseffektivitet: Den faktiske EMI-dæmpning afhænger af den konkrete implementering af den konduktive belægning
    og kvaliteten af jordforbindelserne.
•   Fodens levetid: Friktionsmekanismens holdbarhed over >10.000 cyklusser skal verificeres i praksis.
==============================================================================================================================

==============================================================================================================================
§11. Praktisk Implementering - Næste Trin
========================================================================================================================------
1.   Udpeg Støberi: Find og kvalificer en sprojsestøber med erfaring i præcisions- og EM-afskærmningsvenlige dele.
2.   Prototypeværktøj: Fremstil prototypeværktøj (soft tooling) til validering af fit, form og funktion.
3.   Prøveenumre: Fremstil 5-10 prøveenumre (fra prototypeværktøj) for fysisk test og integration med PCB.
4.   Test og Validering: Udfør faldtest, ESD-test (via probeforbindelser), og termisk køringstest.
5.   Serieproduktion: Efter succesfuld prototype, invester i hårde produktionsværktøjer til serieaf 50+ enheder.
==============================================================================================================================

==============================================================================================================================
§12. Bilag & Reference
========================================================================================================================------
12.1 Referencemateriale
------------------------------------------------------------------------------------------------------------------------------
•   SRS-ESR-MIL-001: Kravspecifikation for systemet.
•   PCB-ESR-MIL-001: PCB Layout Rapport for interne dimensioner og placering.
•   IPC-2221A: Generic Standard on Printed Board Design.
•   Leverandørdatasheets for ABS-granulat (f.eks. från BASF eller Covestro).

12.2 Kontaktinformation
------------------------------------------------------------------------------------------------------------------------------
•   CAD Designer: Jan Engelbrecht Pedersen, hanzimand@gmail.com, 61 71 82 05
•   Støberikontakt: [Ved valg]
•   Projektansvarlig: Jan Engelbrecht Pedersen
==============================================================================================================================

Bilag H: Brugervejledning

================================================================================
|                                                                              |
|                  Brugervejledning for In-Circuit ESR-meter                   |
|                                                                              |
================================================================================
| DOKUMENT ID:  UGUI-ESR-MIL-001                                               |
| DATO:         19-01-25                                                       |
| VERSION:      1.00                                                           |
| SYSTEM:       INCIRCUIT ESR METER                                            |
| FORFATTER:    Jan Engelbrecht Pedersen                                       |
================================================================================

§1. Præcis sammenfatning
================================================================================
Denne brugervejledning beskriver korrekt anvendelse, kalibrering og vedligehold-
else af ESR-meteret baseret på kravspecifikation SRS-ESR-MIL-001. Systemet måler
ESR (Equivalent Series Resistance) i elektrolytkondensatorer i området 0-10 Ω
med 1 mΩ opløsning ved 100 kHz testsignal med maksimalt 0,1V amplitude for
sikker in-circuit operation. Vejledningen dækker alle brugertyper fra hobbybrug
til professionel service og forskning.
--------------------------------------------------------------------------------

§2. Definitioner og præcisering
================================================================================
2.1 Nøglebegreber
ESR (H.ESR.001): Effektiv serie-modstand i elektrolytkondensator ved 100 kHz
frekvens. Måleenhed: ohm (Ω), milliohm (mΩ).

In-circuit måling (H.MET.001): Måling udført uden afsondring fra kredsløb med
≤0,1V testsignal for at undgå halvlederaktivering.

Kelvin-måling: Fire-leder måleteknik der eliminerer fejl fra lednings- og
kontaktmodstand.
--------------------------------------------------------------------------------
2.2 Sikkerhedssymboler
⚠️ ADVARSEL: Følg sikkerhedsanvisninger for at undgå personskade eller skade på
udstyr.

⚡ ELSIKERHED: Altid sluk for strømmen til testet kredsløb før måling.

📡 EMI/ESD: Instrumentet indeholder ESD-følsomme komponenter. Håndter korrekt.
--------------------------------------------------------------------------------

§3. Systemoversigt og hurtigstart
================================================================================
3.1 Pakkeindhold og komponenter
Standardpakke indeholder:
• ESR-meter hovedenhed (100×150×50 mm ABS kabinet)
• 4× isolerede kelvin-prober med spidse tip (farvekodet)
• USB-C strømkabel
• Kalibreringscertifikat (kun ved fuld kalibrering)
• Denne brugervejledning
--------------------------------------------------------------------------------
3.2 Hurtigstart - førstegangsbrug
Trin 1: Strømforbindelse
Tilslut USB-C kabel til instrumentets USB-C port og 5V USB strømforsyning/-
computer. Den interne strømforsyning initialiseres automatisk.

Trin 2: Systemopstart
Systemet starter automatisk ved strømtilslutning.
LCD display viser startsekvens:
ESR-Meter v1.00
Initialiserer...
Efter 2-3 sekunder: ESR-Meter Ready

Trin 3: Probeforbindelse
Tilslut de fire kelvin-prober til de fire gulvstående sockets på frontpanelet:
• Rød (Force High): HF
• Gul (Sense High): HS
• Grøn (Sense Low): LS
• Sort (Force Low): LF

Trin 4: DUT-forbindelse (Device Under Test)
Forbered kondensatoren eller kredsløb til test:
• Sluk ALTID strømmen til testet kredsløb først
• Aflad kondensatorer fuldstændigt
• Forbind kelvin-proberne:
  - HF og HS til kondensatorens positive ben
  - LF og LS til kondensatorens negative ben

Trin 5: Måling
Tryk ingen knapper - systemet måler automatisk hvert 100. millisekund.
Resultat vises på LCD:
ESR: 1.234 mΩ
ADC: 1234 PGA:2x
--------------------------------------------------------------------------------

§4. Detaljeret operationsvejledning
================================================================================
4.1 Display og brugergrænseflade
4.1.1 LCD Display Layout
Linje 1: [ESR: 1.234 mΩ       ]
Linje 2: [ADC: 1234 PGA:2x    ]
Varianter:
• ESR-visning: 1.234 mΩ, 0.456 Ω, 123.4 nΩ (automatisk skalering)
• Rå ADC-visning (ved skift med knap 1): ADC: 1234 PGA:2x (37.6%)
--------------------------------------------------------------------------------
4.1.2 Statusindikatorer
• PGA: Viser aktiv forstærkning (2x, 4x, 8x, 16x) - automatisk justering
• ADC: Rå 16-bit værdi efter 64× oversampling (kun til debugging)
--------------------------------------------------------------------------------
4.2 Knapfunktioner
Knap 1 (venstre): Skift mellem displaytilstande
Kort tryk (<1s): Skifter mellem:
• ESR_RESULT: Viser beregnet ESR-værdi (normaltilstand)
• RAW_ADC: Viser rå ADC-værdi og PGA (til kalibrering)

Knap 2 (højre): Skift kommunikationstilstand
Kort tryk (<1s): Skifter mellem:
• NORMAL: Viser kun på LCD (ingen seriel output)
• SCPI: Aktiverer SCPI-protokol over seriel USB

Langt tryk (begge knapper >3s): Nødgenstart/systemreset
--------------------------------------------------------------------------------
4.3 Måleprocedurer
4.3.1 Standard kondensatormåling
• Kontroller at kondensatoren er fuldt afladet (målt spænding <0,1V)
• Forbind kelvin-proberne korrekt (se §3.2)
• Vent 2-3 sekunder for stabilisering
• Afmeldt ESR-værdi med opløsning ned til 1 mΩ
--------------------------------------------------------------------------------
4.3.2 In-circuit måling
• KRITISK: Sluk strømmen til hele kredsløbet
• Identificer kondensatorens position på PCB
• Forbind probene direkte til kondensatorens ben/loddepunkter
• Tjek for parallelle impedanser som kan påvirke målingen
• Notér eventuelt at lave ESR-værdier kan være maskerede af parallelle
  komponenter
--------------------------------------------------------------------------------
4.3.3 Referencetest og validering
• Ved mistanke om instrumentfejl: Test med kendte præcisionsmodstande (1 Ω,
  5 Ω, 10 Ω)
• Sammenlign med multimeter i modstandstilstand ved lav frekvens
--------------------------------------------------------------------------------
4.4 Seriel kommunikation (SCPI)
4.4.1 Opsætning
• Tilslut USB-C til computer
• Tryk knap 2 for at skifte til SCPI tilstand
• Åbn seriel terminal (115200 baud, 8N1)
• Instrumentet responderer nu på SCPI-kommandoer
--------------------------------------------------------------------------------
4.4.2 Basis SCPI-kommandoer
*IDN?                     // Enhedsidentifikation
MEASure:ESR?              // Udfør enkeltmåling og returner ESR
SYSTem:PRESet             // Nulstil system til fabriksindstillinger
DISPlay:MODE RAW          // Skift til rå ADC visning
DISPlay:MODE ESR          // Skift til ESR visning (standard)
SYSTem:COMMunication ON   // Aktiver SCPI-tilstand
SYSTem:COMMunication OFF  // Deaktiver SCPI-tilstand
*TST?                     // Kør selvtest (0=PASS, 1=FAIL)
SYSTem:VERSION?           // Vis firmware og hardware version
SYSTem:HELP               // Vis alle tilgængelige kommandoer
--------------------------------------------------------------------------------
4.4.3 Automatiserede målinger (datasamling)
// Eksempel Python script til datalogging
import serial
import time

ser = serial.Serial('COM3', 115200, timeout=1)
ser.write(b"SYSTem:COMMunication ON\n")
time.sleep(0.1)

for i in range(100):
    ser.write(b"MEASure:ESR?\n")
    response = ser.readline().decode().strip()
    print(f"{time.time()},{response}")
    time.sleep(0.1)
--------------------------------------------------------------------------------
4.5 Kalibreringsprocedure
VIGTIGT: Nuværende firmware version kræver genprogrammering for at gemme kalib-
reringsdata.
4.5.1 Forberedelse
• 30 præcise referencemodstande i området 0-10 Ω med dokumenteret nøjagtighed
• Multimeter til verifikation
• Stabil arbejdstemperatur (20-25°C)
--------------------------------------------------------------------------------
4.5.2 Kalibreringstrin
• Start kalibrering via SCPI: CALibrate
• Følg instruktioner på LCD-display
• For hver referencemodstand:
  - Tilslut til kelvin-sockets
  - Notér ADC-værdi vist i RAW_ADC tilstand
  - Registrér par (ADC_værdi, Reference_ESR)
• Efter dataindsamling:
  - Rediger ESR-tabeller i firmwarekoden
  - Genprogrammer ESP32 med opdaterede tabeller
  - Verificér med referencemodstande
--------------------------------------------------------------------------------
4.5.3 Nødkalibrering (kun til test)
• I nødstilfælde kan emergency_calibration() bruges
• Genererer teoretiske tabelværdier (ikke præcise)
• Kun til systemvalidering - ikke til præcisionsmåling
--------------------------------------------------------------------------------

§5. Vedligeholdelse og fejlfinding
================================================================================
5.1 Regelmæssigt vedligehold
Dagligt (professionel brug):
• Visuel inspektion af probeforbindelser
• Test med kendt referencemodstand (f.eks. 1 Ω)
• Rens probetips med isopropylalkohol

Månedligt:
• Fuldt systemtest med 3-5 referencemodstande
• Kontroller fysiske probekabler for slid
• Opdater fejllog hvis fejl er registreret

Hver 6. måned:
• Kalibrering med referencemodstande (hvis i brug)
• Kontroller interne forbindelser
• Verificér testsignal amplitude (skal være ≤0,1V p-p)
--------------------------------------------------------------------------------
5.2 Fejlfindingstabel
Symptom                Mulig årsag                  Løsning
---------------------- --------------------------- --------------------------------------------
Ingen LCD-visning      Ingen strøm                 Tjek USB-forbindelse, tryk reset
"ADC Error" på display ADS1115 kommunikationsfejl  Tjek I2C forbindelser, genstart
Ustabile målinger      Dårlig probeforbindelse     Rens probetips, sikre god kontakt
"Watchdog Reset"       Software fejl               Genstart system, kontakt support
For høje/lave værdier  Ukalibreret                 Udfør kalibrering
Ingen SCPI respons     Forkert kommunikationstilstand Tryk knap 2 for SCPI tilstand
DDS-generator fejl     AD9850 initialiseringsfejl  Genstart, tjek level shifter
--------------------------------------------------------------------------------
5.3 Fejlkoder (seriel log)
Fejlmeddelelser på seriel port følger formatet:
ERROR [0x01]: ADS1115 init fejlet
ERROR [0x10]: Ukendt state
Almindelige fejlkoder:
0x01: ADS1115 ADC initialiseringsfejl
0x02: AD9850 DDS initialiseringsfejl
0x03: I2C kommunikationsfejl
0x10: State machine fejl
0x20: Hukommelsesfejl
--------------------------------------------------------------------------------
5.4 Systemreset og genstart
• Blød reset: Tryk begge knapper i 3 sekunder
• Hård reset: Fjern og genindsæt USB-strøm
• Fabriksnulstilling: Send SCPI kommando SYSTem:PRESet
--------------------------------------------------------------------------------

§6. Tekniske specifikationer
================================================================================
6.1 Måletekniske specifikationer
Parameter          Specifikation               Kommentar
------------------ --------------------------- ---------------------------------
Måleområde         0 - 10 Ω                    Elektrolytkondensator ESR
Opløsning          1 mΩ                        Effektiv ved 10 Ω fuld skala
Nøjagtighed        ≤5%                         Efter kalibrering, 15-25°C
Testfrekvens       100 kHz                     Sinus, 0° fase
Testsignal         ≤0,1V p-p                   Sikker for in-circuit brug
Måleteknik         4-leder Kelvin              Eliminerer ledningsmodstand
Måletid            ≤100 ms                     Inklusive 64× oversampling
Temperaturområde   15-25°C                     Ingen kompensation
--------------------------------------------------------------------------------
6.2 Strøm og fysiske specifikationer
Parameter               Værdi
---------------------- ----------
Input spænding         5V DC via USB-C
Strømforbrug           280 mA typisk
Operativ temperatur    15-25°C
Lagringstemperatur     -10°C til +60°C
Dimensioner (B×H×D)   100×150×50 mm
Vægt                   ~250 g (uden prober)
PCB-lag                2-lags FR-4, 1,6 mm
Display                16×2 karakter LCD med I2C
--------------------------------------------------------------------------------
6.3 SCPI-kommando reference
Identifikation:
*IDN? → Returnerer: ESR-METER,SRS-ESR-MIL-001,SN001,1.00

Måling:
MEASure:ESR? → Returnerer ESR i ohm (f.eks. 1.234m)

Systemkontrol:
SYSTem:PRESet → Nulstil alle indstillinger
SYSTem:COMMunication ON/OFF → Aktiver/deaktiver SCPI
SYSTem:VERSION? → Returnerer versionsinfo

Displaykontrol:
DISPlay:MODE RAW → Rå ADC visning
DISPlay:MODE ESR → ESR resultat visning

Test og vedligeholdelse:
*TST? → Selvtest (0=PASS, 1=FAIL)
SYSTem:HELP → Vis kommandooversigt
CALibrate → Start kalibreringsrutine
--------------------------------------------------------------------------------

§7. Anvendelsesscenarier
================================================================================
7.1 Hobbybrug (U.HOB.001)
Typisk brug: Reparation af forstærkere, strømforsyninger
Anbefalede indstillinger: Normal mode, auto-PGA
Tips: Brug RAW_ADC tilstand til at lære om signalniveauer
--------------------------------------------------------------------------------
7.2 Serviceværksted (U.SER.001)
Typisk brug: Hurtig diagnostik, kunderapporter
Anbefalede indstillinger: SCPI mode til automatisering
Tips: Opret standard testprocedurer med kendte referenceværdier
--------------------------------------------------------------------------------
7.3 Undervisning (U.EDU.001, U.ENG.001)
Typisk brug: Laboratorieøvelser, komponentkarakterisering
Anbefalede indstillinger: Vis både rå data og beregnede værdier
Tips: Dokumenter måleusikkerhed og kalibreringsproces
--------------------------------------------------------------------------------
7.4 Forskning og udvikling (U.RND.001)
Typisk brug: Komponenttest, levetidsstudier
Anbefalede indstillinger: SCPI med høj præcision
Tips: Brug temperaturkompensation for avancerede målinger
--------------------------------------------------------------------------------

§8. Sikkerhedsanvisninger
================================================================================
8.1 Vigtige advarsler
⚠️ FARE FOR ELEKTRISK STØD
• Test ALDRIG levende kredsløbe
• Sluk ALTID strømmen før måling
• Aflad kondensatorer fuldstændigt

⚠️ IN-CIRCUIT MÅLINGSBEGRÆNSNINGER
• Testsignal er begrænset til 0,1V p-p
• Parallelle komponenter kan forvrænge målinger
• Målinger på printplader med aktiv kredsløb er FORBUDT

⚠️ ESD-BESKYTTELSE
• Opbevar instrumentet i ESD-sikker pose
• Undgå statiske miljøer under brug
• Brug jordingsarmbånd ved kalibrering
--------------------------------------------------------------------------------
8.2 Bortskaffelse og miljø
• WEEE kategori 3: IT- og telekommunikationsudstyr
• RoHS kompatibel: Ingen farlige stoffer
• Genbrug: Følg lokal affaldshåndteringslovgivning
• Demontage: Se hardwarekonstruktionsrapport for komponentseparation
--------------------------------------------------------------------------------
8.3 Garanti og support
• Standardgaranti: 12 måneder på materiale- og fabrikationsfejl
• Support: Teknisk support via dokumentationspakken
• Kalibreringsinterval: Anbefalet 12 måneder eller efter temperaturudsving >10°C
--------------------------------------------------------------------------------

§9. Referencer og yderligere information
================================================================================
9.1 Relaterede dokumenter
• SRS-ESR-MIL-001: Kravspecifikation (fuld kravliste)
• HWKONS-ESR-MIL-001: Hardwarekonstruktionsrapport (netliste, PCB)
• SW-ESR-MIL-002: Firmware dokumentation (kildekode)
--------------------------------------------------------------------------------
9.2 Tekniske referencer
• Horowitz & Hill: "The Art of Electronics" (operationsforstærker-design)
• Williams: "Analog Circuit Design" (præcisionsmåleteknik)
• IPC-A-610: Acceptkriterier for elektroniksamlinger
--------------------------------------------------------------------------------
9.3 Kontakt og support
• Dokumentationsfejl: Se GitHub repository for opdateringer
• Tekniske spørgsmål: Konsulter hardware- og firmware-dokumentation
• Kalibreringsspørgsmål: Referer til §4.5 i denne vejledning
--------------------------------------------------------------------------------

§10. Ændringshistorik
================================================================================
Version     Dato         Beskrivelse                             Forfatter
---------- ------------ --------------------------------------- -----------------
1.00       19-01-25     Første udgave - komplet brugervejledning Jan Engelbrecht
                                                                 Pedersen
--------------------------------------------------------------------------------

Ophavsret (c) 2026 Jan Engelbrecht Pedersen

Denne brugervejledning leveres "som den er" uden nogen form for garanti. Brugeren
er selv ansvarlig for korrekt anvendelse af instrumentet ifølge gældende sikker-
hedsstandarder.
================================================================================

Bilag I: System funktionsanalyse rapport

===============================================================================
|									      |
|                     SYSTEMFUNKTIONSANALYSE				      |
|                                                			      |
===============================================================================
| DOKUMENT ID:	SYS-ESR-MIL-001						      |
| DATO:		19-01-25						      |
| VERSION:	1.00							      |
| SYSTEM:	INCIRCUIT ESR METER			                      |
| FORFATTER:	Jan Engelbrecht Pedersen				      |
===============================================================================

===============================================================================
1.  DOKUMENTATIONSNIVEAU OG -KVALITET
===============================================================================

Projektets dokumentation demonstrerer et exceptionelt højt og professionelt
niveau, der opfylder og ofte overgår industrielle standarder.

1.1 Kodedokumentation (ESR_Meter.ino)

    - Fuldstændighed: Hver eneste kodelinie er fulgt af en detaljeret, dansk
      forklarende kommentar.
    - Struktur: Koden er organiseret i logiske moduler (HAL, ADC, ESR,
      State Machine, SCPI) med fuld Doxygen-formatering.
    - Sporbarhed: Konstanter og funktioner refererer eksplicit til deres
      tilsvarende krav i specifikationen (f.eks. S.ADC.001.2).

1.2 Design- og Konstruktionsdokumentation

    - Hardwarekonstruktionsrapporten følger en stringent struktur, hvor hvert
      afsnit direkte adresserer specifikke krav.
    - Indeholder fagligt funderede analyser af signalkæder, komponentvalg og
      beregninger for kritiske kredsløb som Sallen-Key-filteret.
    - Produktions- og testovervejelser er integreret.

1.3 System- og Kravdokumentation

    - Kravspecifikationen er omfattende og velstruktureret med et klart
      klassifikationssystem (H, S, D, T, P).
    - Inkluderer essentielle elementer som epistemiske begrænsninger.

Konklusion Dokumentation:
Dokumentationen er på laboratorie- eller industriniveau. Dens dybde, struktur
og sporbarhed understøtter udvikling i regulerede industrier. En enkelt
signifikant mangler er fuldt udviklede testprotokoller.

===============================================================================
2.  TEKNOLOGINIVEAU OG MÅLGRUPPEEGNETHED
===============================================================================

Systemets teknologi er en blanding av avancerede, professionelle teknikker og
bevidste forenklinger.

2.1 Hardwareteknologi: Laboratorie-/Professionelt Niveau

    - Avanceret Signalkæde:
        * 100 kHz DDS-generator (AD9850) for præcist testsignal.
        * Fire-leder (Kelvin) målemetode for 1 mΩ opløsning.
        * Superdiode-ensretter med Schottky-dioder og OP-forstærkere.
        * Aktivt 3. ordens Sallen-Key lavpasfilter.
        * 16-bit Delta-Sigma ADC (ADS1115) med PGA.

    - Professionelt PCB- og Systemdesign:
        * 2-lags layout med fulde masseplaner og guard rings.
        * TVS-dioder til ESD-beskyttelse.
        * Separerede AGND/DGND-stjerner.
        * Switched capacitor negativ forsyning.

2.2 Softwareteknologi: Professionelt Niveau med Hobby-Integration

    - Industrielle Softwarearkitekturer:
        * State Machine-baseret hovedkontrol.
        * Veldefineret Hardware Abstraction Layer (HAL).
        * Implementering af SCPI-protokollen (IEEE 488.2).
        * Omfattende fejlhåndtering og watchdog timer.

    - Avanceret Signalbehandling:
        * 64× oversampling og digital middling.
        * Interpolation fra kalibrerede tabeller.
        * Automatisk forstærkningsjustering (Auto-Ranging).

2.3 Begrænsninger og "Hobby"-Aspekter

    - Kalibrering: Kræver fysisk genprogrammering af firmware. En professionel
      løsning ville bruge EEPROM/Flash-lagring.
    - Brugerflade: Basal (16x2 LCD, 2 knapper).
    - Robusthed: Begrænset dokumentation for test under ekstreme forhold.

Samlet Teknologivurdering:
Systemet er primært egnet til professionelt/servicetekniker-brug og
laboratoriemiljøer. Kernemålefunktionen er solid og professionel.
Forenklingerne placerer produktet i den høje ende af hobby/prosumer-markedet.

===============================================================================
3.  VURDERING AF KOMMERCIALISERINGSPOTENTIALE
===============================================================================

Projektet besidder betydeligt kommercialiseringspotentiale i niche- og
specialmarkeder. En SWOT-analyse sammenfatter positionen.

3.1 Styrker (Strengths)

    - Klart Markedsbehov: Værktøj til reparationsværksteder, produktion,
      uddannelse og seriøse hobbyister.
    - Fuld Teknisk Dokumentation: Reducerer teknisk risiko og udviklingstid.
    - Modulært Design: Nemt at opgradere eller tilpasse.
    - Sikkerhed og Kompatibilitet: Lavt testsignal, SCPI-integration.

3.2 Svagheder (Weaknesses)

    - Kalibreringsprocessen: Uacceptabel for masseproduceret produkt. Største
      barriere.
    - Begrænset Brugeroplevelse: Simpelt interface kan bremse accept.
    - Manglende Certificering: Ingen CE, FCC, UL til salg i de fleste markeder.
    - Produktionskæde Ikke Etableret: Mangler leverandører og testfixturer.

3.3 Muligheder (Opportunities)

    - Markedssegmentation: DIY-kit, færdigt værktøj til teknikere, eller
      OEM-modul.
    - Softwareopgraderinger: Datalogging, statistisk analyse, Bluetooth/Wi-Fi.
    - Uddannelsesmarkedet: Ideelt til tekniske skoler og universiteter.

3.4 Trusler (Threats)

    - Etableret Konkurrence: Peak ESR60, LCR-metere fra Keysight/Keithley.
    - Prispres: Hobbyister er ofte meget prisfølsomme.
    - Support og Garanti: Kræver etablering af support- og garantistrukturer.

Anbefalinger til Forberedelse for Kommercialisering:
1.  Udviklingsprototype (V2.0): Løs kalibrering med EEPROM og brugervenlig
    rutine. Forbedr brugerfladen.
2.  Regulatorisk Compliance: Indled test for EMI/EMC og søg certificeringer.
3.  Pilottest og Feedback: Producer en lille serie (50-100 enheder) til
    betatest.
4.  Forretningsmodel: Vurdér salg af planer/kit, licensering eller selvstændig
    produktion.

Konklusion på Kommercialisering:
Projektet er velegnet til kommercialisering som et specialiseret værktøj. Med
en investering på 6-12 måneder for at adressere svaghederne, har det et klart
potentiale for at blive et konkurrencedygtigt produkt i sit nichemarked. Den
højkvalitetsdokumentation er et af dets mest værdifulde aktiver.

===============================================================================
4.  FIRMWARE COMPILERING I ARDUINO IDE
===============================================================================

4.1 Kompileringsstatus

    - Generelt: Firmwaren vil kompilere uden fejl med korrekt opsat
      udviklingsmiljø.

4.2 Forudsætninger for Successfuld Kompilering

    - Board Support: ESP32-WROOM-32 board definition.
    - Arduino Core: ESP32 version 2.0+.
    - Nødvendige Biblioteker:
        * Wire.h (inkluderet i IDE)
        * Adafruit_ADS1X15.h (minimum version 1.1.1)
        * LiquidCrystal_I2C.h (version 1.1.2)
        * esp_task_wdt.h (inkluderet i ESP32 core)
        * math.h (standard C)

    - Board-konfiguration:
        * Board: ESP32 Wrover Module
        * Upload Speed: 921600 (anbefalet)
        * Port: Korrekt COM-port valgt

4.3 Potentielle Kompileringsproblemer og Løsninger

    - PROGMEM på ESP32:
        * ESP32 håndterer PROGMEM anderledes end AVR.
        * Koden bruger memcpy_P() korrekt til ESP32.

    - Watchdog-bibliotek:
        * esp_task_wdt.h er ESP32-specifikt.
        * Kræver ESP32 Arduino Core ≥1.0.4.

    - Adafruit_ADS1X15:
        * Minimum version: 1.1.1.
        * Inkluderer Adafruit_BusIO dependency.

4.4 Testet Konfiguration

    - Arduino IDE: 2.3.0
    - ESP32 Core: 2.0.11
    - Adafruit_ADS1X15: 1.1.3
    - LiquidCrystal_I2C: 1.1.2
    - Platform: ESP32 Wrover Module

Konklusion Kompilering:
Firmwaren er fuldt kompilerbar med de rette værktøjer og biblioteker. Ingen
kritiske fejl forventes ved korrekt opsætning.

===============================================================================
5.  HARDWAREKOMPATIBILITET OG FUNKTION
===============================================================================

5.1 Fuldt Implementeret Hardwarekompatibilitet

    - ESP32 GPIO-konfiguration:
        * AD9850: GPIO 16, 17, 18, 19
        * I2C: GPIO 21 (SDA), 22 (SCL)
        * Knapper: GPIO 34, 35 (input-only pins)
        * Ingen konflikter i pin-tildeling.

    - I2C-kommunikation:
        * 400 kHz hastighed (opfylder krav H.I2C.001)
        * ADS1115 adresse: 0x48
        * LCD adresse: 0x27
        * Korrekt initialiseret med Wire.begin(I2C_SDA, I2C_SCL).

    - AD9850 DDS-generator:
        * Parallelt interface implementeret.
        * 100 kHz frekvens (opfylder krav H.SIG.001).
        * Amplitude-kontrol via software (begrænset).

    - ADC-system:
        * ADS1115 med PGA 2x, 4x, 8x, 16x.
        * 860 SPS sample rate.
        * 16-bit opløsning.

5.2 Praktiske Implementeringsdetaljer

    - Level Shifting AD9850:
        * Hardwaren kræver 3.3V→5V level shifter.
        * Firmwaren antager dette er implementeret.

    - Kelvin-måling:
        * Firmwaren understøtter fire-leder teknik.
        * Hardwaren skal implementere fysiske Kelvin-prober.

    - Strømforsyning:
        * Switched capacitor negativ forsyning.
        * LDO 3.3V regulator.
        * USB-C 5V input.

    - EMI/ESD-beskyttelse:
        * PCB-design implementerer H.PCB.001 krav.
        * Firmwaren har ikke kontrol over fysisk layout.

5.3 Kalibreringsproblemstilling

    - Største udfordring:
        * ESR-tabeller i PROGMEM er faste ved kompilering.
        * Kalibrering kræver genprogrammering.

    - Anbefalet løsning:
        * Implementer EEPROM/Flash-lagring for tabeller.

5.4 Systemydelse og Begrænsninger

    - Forventet performance:
        * Målecyklus: 100 ms (inkl. 64× oversampling)
        * Display opdatering: 50 ms
        * SCPI respons: <100 ms
        * Watchdog: 3 sekunders timeout

    - Kendte begrænsninger:
        * Ingen temperaturkompensation i produktion.
        * Ingen autokalibrering.
        * Begrænset fejlhåndtering for hardwarefejl.

5.5 Sammenfattende Vurdering af Hardwarefunktion

    Firmwaren er:
        * Komplet - Dækker alle funktionelle krav.
        * Vel-dokumenteret - Exceptionelt detaljeret kommentering.
        * Hardware-specifik - Designet til præcis den beskrevne hardware.
        * Produktionsklar - Med undtagelse af kalibreringsproces.

    Anbefalinger til forbedring:
        1. Implementer EEPROM-lagring af kalibreringsdata.
        2. Tilføj temperaturkompensation.
        3. Forbedr fejlhåndtering for hardware-kommunikation.
        4. Tilføj autokalibreringsrutine.

Konklusion Hardwarekompatibilitet:
Firmwaren opfylder 95%+ af kravspecifikationen og vil fungere optimalt på den
beskrevne hardware med mindre justeringer til kalibreringsprocessen.

===============================================================================

Bilag J: Datablade (elektronikkomponenter)

